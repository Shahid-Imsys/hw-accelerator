Imsys Tools 0.15.0 -- MASM
Microprogram version: 1.1.0.3

FILE: Tmpgm/Depthwise_stride1_1A_short_pp.mas
                                               (00001) 
                                               (00002) (( Bottleneck 2.
                                               (00003) (( This bottleneck implemementation will do a diffrent schema.
                                               (00004) (( Load the three first data rows as before. Start doing pointwize and depthwise convolution on the first 8+8 channels.
                                               (00005) (( Find out where to write that back to cm. Once enough data is written to CM read it back and start over again.
                                               (00006) (( Also do the side stepping by incrementing in Y-drirection since that would simplify copying of data.
                                               (00007) 
                                               (00008) (( Start with reducing / removing the PW2 operation.
                                               (00009) (( The PW2 operations can be done at a later stage or seperatlely.
                                               (00010) 
FILE: Definitions/Definitions_wide.mas
                                               (00001) *INIT*
                                               (00002) 
                                               (00003) MICROINSTRUCTION SIZE IS 10;
                                               (00004) MICROPROGRAM LENGTH IS 100;
                                               (00005) 
                                               (00006) 
                                               (00007) *FIELDS*
                                               (00008) (
                                               (00009) (
                                               (00010) (
                                               (00011) (
                                               (00012) (
                                               (00013) (
                                               (00014) (
                                               (00015) (		  **********************************
                                               (00016) (		  *				   *
                                               (00017) (		  *	      I M S Y S		   *
                                               (00018) (		  *				   *
                                               (00019) (		  *   CPU MICROPROGRAM ASSEMBLER   *
                                               (00020) (		  *				   *
                                               (00021) (		  *        DEFINITION PART         *
                                               (00022) (		  *				   *
                                               (00023) (		  *	       For the		   *
                                               (00024) (		  *        GP2000 processor        *
                                               (00025) (		  *				   *
                                               (00026) (		  **********************************
                                               (00027) (
                                               (00028) (
                                               (00029) (		      Copyright Imsys AB (2001)
                                               (00030) (
                                               (00031) (
                                               (00032) (
                                               (00033) (
                                               (00034) 'CPU. STRING/REG. MEM, LATCH AND D-BUS SELECTOR.
                                               (00035) (		 +======+=====+=====+	 +===+======================+
                                               (00036) (		 !	V     V     V	 V   V			    !
                                               (00037) (		 !   +-----+-----+-----+---+----+		    !
                                               (00038) (		 !   ! PS  ! MS  ! SB  ! B ! R	!		    !
                                               (00039) (		 ! +>! CTR ! CTR ! CTR !REG!CTR !		    !
                                               (00040) (		 ! ! +-----+-----+-----+---+----+		    !
                                               (00041) ( PE-field  -----!-+    !     !     !    !---'                      !
                                               (00042) (		 !	V     V     V	 V	 +=======+	+===+
                                               (00043) (		 !    +-----------------------+  !	 V	V   !
                                               (00044) ( GAS-field -----!-+->!    GMEM ADDRESS       !  !     +-----------+!
                                               (00045) (		 ! !  !      Selector	      !  !     !Latch Sel. !!
                                               (00046) (		 ! !  +-----------------------+  !     +-----------+!
                                               (00047) (		 ! !		!		 !	     !	    !
                                               (00048) (		 ! !		+==========+	 !  M	     V	    !
                                               (00049) (		 ! !		V	   !	 !  A  +-----------+!
                                               (00050) (		 ! !	+---------------+  !	 !  P  !   LATCH   !!
                                               (00051) (		 ! +--->!Register/String!  !	 !  R  +-----------+!
                                               (00052) (		 !	!    Memory.	!  !	 !  !	     V	    !
                                               (00053) (		 !	!  1024x8 bits	!  !	 ! +-------+ !	    !
                                               (00054) (		 !	+---------------+  !	 +-!  MBM  !-+	    !
                                               (00055) (		 !   +--+	V	   !	 ! +---+---+ !	    !
                                               (00056) (Y-bus f ALU>====+==>!YE!>======+================+     V     !	    !
                                               (00057) (		     +--+		   !	 !	     !	    !
                                               (00058) (		D  F  Y  Y  P  E  D  D	D  !  Y  !  D  M  Y  !	    !
                                               (00059) (		A  L  S  B  O  X  F  F	F  !  F  !  F  B  P  !	    !
                                               (00060) (MAPR-field==>	T  G  W  U  R  C  M  I	C  !  L  !  S  M  R  !	    !
                                               (00061) (	   +=>	A  S  P  S  T  E     O	L  !  I  !  P	  I  !	    !
                                               (00062) (	   !	1     P     S  P	C  V  P	 V	  O  V	    !
                                               (00063) (	   !  +------------------------------------------------+    !
                                               (00064) (	   !  ! 0  1  3  4  E  7  8  9	A  6  B  C  D  5  F  2 !    !
                                               (00065) (DS-field =+=>! 	       Data source selector	       !    !
                                               (00066) (	      +------------------------------------------------+    !
                                               (00067) (					!			    !
                                               (00068) (					!			    !	D-bus to
                                               (00069) (					+===========================+=> ALU,CLC
                                               (00070) (					!				CLC
                                               (00071) (					!
                                               (00072) (					!
                                               (00073) (					+==============!>!==> Data TO PAD
                                               (00074) '2901 ALU DESIGN
                                               (00075) (	       . . . . . . . .2 x 2901 . . . . . . . . . . . .
                                               (00076) (	       .	  +===========+================+     .
                                               (00077) (	       .	  V	      ! 	       !     .
                                               (00078) (	       .     +---------+      !       +=======+!     .
                                               (00079) (	R7    ------>! R shift !<-----!-------!-------!!------- R0
                                               (00080) (	       .     +---------+      !       V       !!     .
                                               (00081) (	       .	  !	      !  +---------+  !!     .
                                               (00082) (	Q7    ------------V-----------!->! Q shift !<-!!------- Q0
                                               (00083) (	       .     +---------+      !  +---------+  !!     .
                                               (00084) (	       .     !	  B    !      !       !       !!     .
                                               (00085) (  A-field    ======>!A-adr    !      V       V       !!     .
                                               (00086) (  B-field    ======>!B-adr    !    +-----------+     !!     .
                                               (00087) (              .     !    A  B !    ! F       Q'!     !!     .
                                               (00088) (	       .     +---------+    !Q Register !     !!     .
                                               (00089) (	       .	  !  !	    +-----------+     !!     .
                                               (00090) (	       .  +=======+  !		  !Q	      !!     .
                                               (00091) (	       .  !	  !  !	    ZERO  +===========+!     .
                                               (00092) (  D-bus      ==========+ !  !	     !	  !	       !     .
                                               (00093) (	       .  !	V V  V	     V	  V	       !     .
                                               (00094) (	       .  !   +--------------------------+     !     .
                                               (00095) (  ALUS-field =======>! ALU data source selector !     !     .
                                               (00096) (	       .  !   +--------------------------+     !     .
                                               (00097) (	       .  !	      !        !	       !     .
                                               (00098) (	       .  !	      V        V	       !     .
                                               (00099) (	       .  !   +--------------------------+------------> F7 (Sign)
                                               (00100) (	       .  !   !       R        S	 !<------------ Carry In
                                               (00101) (  ALUF-field =======>! 	 ALU   F	 !------------> Carry Out
                                               (00102) (	       .  !   +--------------------------+------------> Zero
                                               (00103) (	       .  !		       !	       !     .
                                               (00104) (	       .  +===========+        +===============+     .
                                               (00105) (	       .	      V        V		     .
                                               (00106) (	       .      +--------------------------+	     .
                                               (00107) (  ALUD-field =======>!   Output data selector	 !	     .
                                               (00108) (	       .      +--------------------------+	     .
                                               (00109) (	       .		   !			     .
                                               (00110) (	       . . . . . . . . . . !. . . . . . . . . . . . ..
                                               (00111) (				   V --------------------------> Y-MSB
                                               (00112) (				 Y-BUS
                                               (00113) 'DEFINITION REVISION
                                               (00114) (
                                               (00115) (==========================================================================
                                               (00116) (		   R E V I S I O N   H I S T O R Y:
                                               (00117) (		   ================================
                                               (00118) (
                                               (00119) (..DATE.. SIGN. VERS  .......SHORT DESCRIPTION............  ..SOLVE PROBL..
                                               (00120) (
                                               (00121) (87-11-12  jo	12    Started to uppdate for the VLSI design. changes marked (V)
                                               (00122) (88-02-22  JO	22    ENTERED CHANGES DEFINED IN MEETING SB.BS,JO 88-02-18
                                               (00123) (88-03-02  jo	27    Entered new DSOURCES, LATCH is loaded as in old days.
                                               (00124) (88-05-04  jo	55    exchanged reg names to W6....WF from TBFLGS...PCL
                                               (00125) (88-05-05  jo	62    Shanges in field definition (AUX1 covers COND)
                                               (00126) (88-05-24  jo	74    Defined SEQC=1F ( IF CTR=0 CONTINUE, ... )
                                               (00127) (88-05-25  jo	77    New definitions for COUNTER load. (short and long)
                                               (00128) (88-05-27  bs	83    1. Set/Reset ALLRAS moved from CUIRQ to PC-field
                                               (00129) (		      2. Added and corrected definitions for LOADADP and LOADADH
                                               (00130) (			 Affects PC-field, which now has no spare.
                                               (00131) (		      3. Corrected PD-field (LOADDTM)
                                               (00132) (88-05-30  jo	91    Defined INVPMSB
                                               (00133) (88-05-31  jo	93    Defined SKIP
                                               (00134) (88-05-31  jo   94    COMMENTED AWAY SOME DEFINITIONS search for  "(Z"
                                               (00135) (88-06-01  jo   96    Corrected "DOPLUS1" statement.
                                               (00136) (88-06-16  bs	99    Changed ALLRAS and MMU-strap definitions.
                                               (00137) (88-06-26  jo	06    Defined GNU/Psys load puls
                                               (00138) (88-06-26  jo	06    Defined TRACE FF.
                                               (00139) (88-06-27  jo	08    Defined Ybus priority to Dsource Selector
                                               (00140) (88-06-27  jo	12    Defined YEQNEG Condition.
                                               (00141) (88-06-28  bs	13    Changed ALLRAS and MMU-strap definitions
                                               (00142) (88-08-11  jo	22    Implemented MBM and MUL definitions.  Removed constant 07
                                               (00143) (88-08-12  jo	23     Additional definitions for barrelshift and mask.
                                               (00144) (88-08-26  jo   28    Additional def's for GNU-ctr, and changes in COND sel.
                                               (00145) (88-08-29  jo	30    Impl. definition for NREG used by Barrelshifter.
                                               (00146) (88-08-30  jo	34    Tried to put in some more DBLASS, to improve varnings.
                                               (00147) (88-09-07  jo	36    Added CTREQ0 to conditions, T12 and T19 to Dsel.
                                               (00148) (88-09-08  jo	37    Removed DATA0:=0 in DSIRQ.  TEST ONLY
                                               (00149) (88-09-09  jo	38    Added DATA0 AGAIN
                                               (00150) (88-09-26  jo	LSI   Changes in definition for INVPSMSB and LOAD NREG
                                               (00151) (88-10-05  jo	LSI   Added def for SEQC:=1A, it shuld be SKIP NEXT.
                                               (00152) (88-10-05  jo   LSI   Added def for SEQC:=1d,   "   "    REPPLUS1
                                               (00153) (88-10-19  jo	GPR   Renamed Wxx back to original names.
                                               (00154) (88-10-21  jo   GPR   Change def. for CONSTANT = " old DATA1 ".
                                               (00155) (88-10-21  jo	GPR   Change def. for ADPA to ADP, no changes has to be i TXT.
                                               (00156) (88-10-27  jo   GPR   Removed CPOL def in Auxiliary func's, and DBLASS
                                               (00157) (88-10-27  jo	GPR   Added a new FIELD called NOMASK, it is the same as BITMSK
                                               (00158) (88-10-27  jo	GPR   Added a new FIELD called DT0H, equal to DATA0 7..4
                                               (00159) (88-10-28  jo	GPR   Added a new FIELD called MSEL, equal to MAP.
                                               (00160) (88-10-28  jo	GPR   Removed MAPR:=0 for & PUSH CSTACK
                                               (00161) (88-11-09  jo	GPR   Added CPTR, DSOURCE CREG
                                               (00162) ( Now Definition part is called  GDEF_[Version].TXT
                                               (00163) (	   GDEF_[Version].TXT
                                               (00164) (88-12-08  jo	01    Added C-code registers definitions. ( GDEF_01.TXT)
                                               (00165) (88-12-14  jo   02    Added names for "wait for spreq", 'WAIT FOR SPREQ'
                                               (00166) (88-12-19  jo	03    Improved definitions of TESTBIT to allow space before nbr
                                               (00167) (88-12-28  jo	04    Added some comments for MBM block functions.
                                               (00168) (89-02-20  jo   04    Added comments for BUG's in GPU72008A, and MMU 72101A.
                                               (00169) (89-03-29  jo	05    Change polarity on GRAREADY condition.
                                               (00170) (89-04-17  jo	06    Added XOR8 function for CREG.
                                               (00171) (90-04-10  jo	--    More comment for GRAREADY condition ( to clearify)
                                               (00172) (90-07-18  cb	--    Changed definition for LDIO and included NEXT
                                               (00173) (90-11-01  jo	--    changed definition of NEXT, now NEXT active = 0 (low)
                                               (00174) (                       And removed mnemonic "LOAD DTIO".
                                               (00175) (91-03-15  jo	--    Added som comments regarding LOAD LATCH FROM Y
                                               (00176) (		      RENAMED multibyte shift MNEMONICS form MSKANDTOTL .. to
                                               (00177) (		      FIRSTSHIFT and NEXTSHIFT.
                                               (00178) (91-04-23  jo	      Changed name of this file to LDEF_01.TXT.
                                               (00179) (		      Changed definition for NEXT INPUT so it match to LPB.
                                               (00180) (			       (changed the active level from low to high)
                                               (00181) (91-05-17  jo	      Added more mnemonics to PLA condition (like FF_EMPTY..)
                                               (00182) (91-08-28  jo	      Comments regarding REPPLUS1 statement.
                                               (00183) (		      Change order in FLAGS table.
                                               (00184) (		      Set Default in MAPR field to F in stead of 0. to prevent
                                               (00185) (		      load of ACCUMULATOR in MBM logic.
                                               (00186) (91-09-12  jo	      New Comments regarding LATCH.
                                               (00187) (91-11-05  jo	      Set DEFAULT to 0 in stead of F for MAPRANGE field
                                               (00188) (91-11-06  jo	      More comments regarding YBUSPRIORITY encoding DSYPRIO
                                               (00189) (92-01-27  jo	      Change definition for YDECODE and UNC YDECODE
                                               (00190) (92-03-31  jo	      Added definitions for CREG1, CREG2, CREG3
                                               (00191) (		      because of the feature of using multiple CREG pointers
                                               (00192) (		      within the selected CREG-block.
                                               (00193) (92-11-16  cb	      Removed MAPRANGE:=0 from LLOAD CTR FROM Y,MEM,SP,IR
                                               (00194) (		      to enable loading of a value greater than 255. CTR bits
                                               (00195) (		      8-11 are loaded from MAPRANGE, which now must be
                                               (00196) (		      specified.
                                               (00197) (93-02-11  cb         Added 'TESTBIT LABEL'.
                                               (00198) (94-03-04  cb	      Added more comments about the multiplier functions
                                               (00199) (95-01-20  cb         Added 'STEP ADL' for the ADL stepping function in
                                               (00200) (		      the new MMR on the IME2.
                                               (00201) (95-07-03  cb         Added 'SET STEP' for the ADL stepping function in
                                               (00202) (		      the new MMR on the IME2.
                                               (00203) (97-08-17  cb	      Added more comments.
                                               (00204) (==========================================================================
                                               (00205) (CHANGES FOR THE NGPU START HERE
                                               (00206) (97-08-25  cb         Removed LONGRAS, makes condition 1A spare.
                                               (00207) (97-08-25  cb         Removed "DS MAPMEM" and "LOAD MAPMEM". Makes DS E spare.
                                               (00208) (97-08-25  cb         Removed all CREG,CPTR,CCTR and CTRSEL definitions.
                                               (00209) (                     Makes pulse CUIRQ(5) spare.
                                               (00210) (97-08-25  cb         Changed ALU function 5 from 1ANDNOT2 to MIN/MAX.
                                               (00211) (97-08-26  cb         Removed GRAREADY, PF, PM, WRITEERR and PC_ACCESS, making
                                               (00212) (                     conditions 1B,1E,1F spare. Also makes bits 7,2,1,0 in
                                               (00213) (                     "DS EXEPT" (7) spare.
                                               (00214) (97-08-30  cb         Reduced time field to 1 bit, making bit 60 a spare. Edited
                                               (00215) (                     the associated definitions and comments.
                                               (00216) (97-09-11  cb         Merged fields PD and PI. This created three new pulses
                                               (00217) (                     (PD=1,6,7).
                                               (00218) (97-09-11  cb         Added definitions for general port control. Used pulse
                                               (00219) (                     PD=1 and dsource DS=E.
                                               (00220) (97-09-11  cb         Added 'DSOURCE G' to be able to use the new, latch-free,
                                               (00221) (                     gmem read-modify-write.
                                               (00222) (97-09-17  cb         Completed changes to the microinstruction format: TIME
                                               (00223) (                     decreased to 1 bit, MEMCP decreased to 2 bits, AADDR and
                                               (00224) (                     BADDR increased to 5 bits each, PD and PI merged to new,
                                               (00225) (                     3-bit PD.
                                               (00226) (97-09-25  cb         Added definitions for double ADL stepping.
                                               (00227) (97-10-09  cb         Added 'LOAD DTM FROM BUS'.
                                               (00228) (97-10-10  cb         Added definitions for the 16-bit fast transfers.
                                               (00229) (97-10-22  cb         Added definitions for micro program loading.
                                               (00230) (97-10-22  cb         Switched places for AUX functions "PUSH CSTACK" and
                                               (00231) (                     "INCREMENT STCTR" and changed "INCREMENT STCTR & DECREMENT
                                               (00232) (                     CTR" to "PUSH CSTACK & DECREMENT CTR".
                                               (00233) (97-10-23  cb         Added DBLAUX, analogous to DBLASS, but for the AUX1 field,
                                               (00234) (		      causing a 3 in the NOTE field.
                                               (00235) (97-09-11  cb         Removed definitions fo general I/O port D and added defs
                                               (00236) (                     for general output ports D and E.
                                               (00237) (97-11-26  cb	      Added definitions for the 'BLOCK' auxillary functions
                                               (00238) (                     now available together with 'UNC DO' and 'UNC LDO'.
                                               (00239) (97-11-27  cb	      Changed 'DS Y/16' to 'DS YFLIPPED'.
                                               (00240) (97-11-28  cb	      Defined bit block rotation.
                                               (00241) (98-01-17  cb	      Added defs and comments for LOAD CCFF and SLEEP.
                                               (00242) (98-12-22  cb	      Moved out definitions for named registers (like
                                               (00243) (		      NEG W1) to AsmDefs and AddDefs. Completely removed
                                               (00244) (		      such defs for the C machine.
                                               (00245) (98-12-22  cb	      Moved in definitions for preselecting GAS from JDEF,
                                               (00246) (		      added some more defs for the same purpose.
                                               (00247) (98-12-29  cb	      Added SIMZERO definition.
                                               (00248) (
                                               (00249) (==========================================================================
                                               (00250) (CHANGES FOR GP2000 START HERE
                                               (00251) (01-08-08  sb         Removed SELST and PE fields (four bits), added GACS
                                               (00252) (		      and GACD fields (four bits). Removed GAS field (two
                                               (00253) (		      bits), added GASS and GASD fields (four bits).
                                               (00254) (01-09-15  cb         Moved MIFORM field next to DS field.
                                               (00255) (01-09-15  cb         MEMCP field expanded from two to three bits.
                                               (00256) (01-09-15  cb         Moved apart DATA1 and AD fields so that they don't
                                               (00257) (		      overlap. Added four bits.
                                               (00258) (01-09-15  cb         SHIN/PA field expanded from three to four bits.
                                               (00259) (01-09-15  cb         Microinstruction is now 80 bits wide.
                                               (00260) (01-09-15  cb         INVRMSB, DSOURCE GRX8, WRITE GRX8, LOAD LATCH FROM
                                               (00261) (		      GRX8 removed.
                                               (00262) (01-09-15  cb         Changes to SHIN/PA definitions: Removed LOAD CCFF,
                                               (00263) (		      added LOAD CRB. Made use of new bit (see above) to
                                               (00264) (		      move SELECT BLK, SET/RESET SPECIAL, LOAD NREG from
                                               (00265) (		      CUIRQ to regular PA pulses. Also gave LOAD LATCH
                                               (00266) (		      FROM Y its own PA pulse, freeing PC=F. Changed the
                                               (00267) (		      code assignments, moved default (no pulse) to code 0.
                                               (00268) (01-09-16  cb         Added new field MBMOP, overlapping low part of DATA1.
                                               (00269) (		      Used MBMOP to control the MBM instead of MAPRANGE,
                                               (00270) (		      which still overlaps high part of AD, but not low
                                               (00271) (		      part of DATA1. Renamed MAPRANGE to MAPR.
                                               (00272) (01-09-28  cb         Removed TIME definitions, removed old comments
                                               (00273) (		      regarding memory and timing.
                                               (00274) (01-09-28  cb         Removed AC and AZ conditions, added comments on YMSB
                                               (00275) (		      ODD/EVEN, YBITSET, YEQNEG, YDECODE and VECTOR jump
                                               (00276) (		      that they refer to the previous Y bus value.
                                               (00277) (01-09-28  cb         Added comments on DSOURCE Y, YSWAPPED, YFLIPPED,
                                               (00278) (		      YPRIO and CU that they refer to the previous Y bus
                                               (00279) (		      value.
                                               (00280) (01-09-28  cb         Added comments LATCH to indicate that it now works
                                               (00281) (		      as a register rather that as a latch.
                                               (00282) (01-10-04  cb	      Changed loadning of ADP/SADP from D to Y (comments
                                               (00283) (		      only).
                                               (00284) (01-10-04  cb	      Added definitions for GSOURCE and GDEST to assign
                                               (00285) (		      to the GAS fields separately.
                                               (00286) (01-10-04  cb	      Changed definitions of all Y bus functions that
                                               (00287) (		      now uses the previous value of the Y bus instead
                                               (00288) (		      of the current, changed Y to YREG in these
                                               (00289) (		      definitions.
                                               (00290) (01-10-08  cb	      Removed TIME field, narrowed MEMCP from three to two
                                               (00291) (		      bits, expanded ALUS from three to four bits, added
                                               (00292) (		      the GAPP field.
                                               (00293) (01-10-08  cb	      Added definitions for GMEM counter push/pop.
                                               (00294) (01-11-05  cb	      Added definitions for new general ports D-J.
                                               (00295) (02-11-13  cb	      Changed encoding of SEQC field. Changed DOPLUS1 to
                                               (00296) (		      LDOPLUS1. Added DSOURCE RTC and LOAD RTC.
                                               (00297) (06-05-08  cb	      Added DSOURCE DSIGN and condition DSXFC. Removed
                                               (00298) (                     condition DBITSET.
                                               (00299) (06-05-22  pa         Added DSOURCE CRBA-CRBF and LOAD CRBA-CRBF.
                                               (00300) (06-09-13  pa         Added '& POP SRCCTR' and '& POP DSTCTR'.
                                               (00301) (15-04-22  mn         Added PUSH SBCTR and POP SBCTR.
                                               (00302) (
                                               (00303) (==========================================================================
                                               (00304) (CHANGES FOR LLVM START HERE
                                               (00305) (17-06-27  pa         Added RSTACK and RSCTR.
                                               (00306) (17-07-15  pa         Added LSTACK and LSCTR.
                                               (00307) (17-09-18  pa         Assign RSTACK to MSTACK and LSTACK to SB
                                               (00308) (18-07-20  pa         Assign LSTACK and RSTACK as GMEM source & destination
                                               (00309) (18-10-24  pa         Assign LSTACK to PSTACK
                                               (00310) (
                                               (00311) (==========================================================================
                                               (00312) 'Hardware BUG description for GP1000
                                               (00313) (
                                               (00314) (
                                               (00315) (1. This is not really a bug, it's intentional, but hazardous:
                                               (00316) (   If an addition is made to ALU register 0E (PCH), the flag PCCY will always
                                               (00317) (   be added to the result. So if for exampel a constant is going to be added
                                               (00318) (   to PCH, make sure that PCCY is cleared prior to the addition.
                                               (00319) (
                                               (00320) (
                                               (00321) (
                                               (00322) (
                                               (00323) 'FIELDS SECTION
                                               (00324) (
                                               (00325) (	  FORMAT FOR LISTS (SP ORDERS+MESSAGES AND EXTERNAL LINKAGE)
                                               (00326) (	  ==========================================================
                                               (00327) (
                                               (00328) (-------(------(----------(----------------------------(----------------
                                               (00329) (LENGTH ( NAME ( DEFAULT  ( DESCRIPTION 	       (DEFAULT FUNCTION
                                               (00330) (-------(------(----------(----------------------------(----------------
                                               (00331) (
                                               (00332) +8; +8; +8; +8; +8; +8; +8; +8; +8;
                                               (00333) (
                                               (00334)     8	 CODE		  ;(CODE FOR SP REQUEST OR CU CALL
                                               (00335)    -C;
                                               (00336)     C	 XADR		  ;(ADDRESS VALUE IN EXTERNAL REFERENCE LIST
                                               (00337) (
                                               (00338) -8; -8; -8; -8; -8; -8; -8; -8; -8; -8;
                                               (00339) 'FIELDS SECTION
                                               (00340) (
                                               (00341) (	  MICROINSTRUCTION FORMAT
                                               (00342) (	  =======================
                                               (00343) (
                                               (00344) (-------(------(----------(----------------------------(----------------
                                               (00345) (LENGTH ( NAME ( DEFAULT  ( DESCRIPTION 	       (DEFAULT FUNCTION
                                               (00346) (-------(------(----------(----------------------------(----------------
                                               (00347) 
                                               (00348) ( Vector engine fields starts here and goes from bit 127 to bit 80
                                               (00349)     8   MCLM        0;      ( Bits 127-120: Holds the microcode loading mechanism.
                                               (00350)     4   DEST_BYTE   0;      ( Bits 119-116: This bits expands the Data To Memory
                                               (00351)     1   C5          0;      ( Bit 115: Expansion of the condition codes. We add conditions to know when certain engines are done or in progress.
                                               (00352)     1   FIFO_PUSH   0;      ( Bit 114
                                               (00353)     1   SEND_REQ    0;      ( Bit 113
                                               (00354)     4   SRC_BYTE    0;      ( Bits 112-109 When reading the DFM register onto the D-bus this selects the byte choosen.
                                               (00355)     1   DS4         0;      ( Bit 108:  This bit is for expanding Dbus source so we can source the D-Bus output.
                                               (00356)     1   ADDR_VE_RELOAD 0;   ( 107:   Reloads the vector engine params based on mode bits.
                                               (00357)     1   LOAD_MPGM   0;      ( 106:
                                               (00358)     5   REG_WRITE   0;      ( Bits 105-101: This 5 bits is used to write the selected register from Y_bus.
                                               (00359)     1   RCV_ST      0;      ( Bit  100: Bit for starting the Receive engine. This needs to be set before a read request is issued.
                                               (00360)     1   ADDR_RE_RELOAD  0;  ( Bit 99: Reloads the address registers or pushback registers.
                                               (00361)     1   MODE_A      0;      ( Bit 98: Used for direct Re engine and Ve engine.
                                               (00362)     1   MODE_B      0;      ( Bit 97:
                                               (00363)     1   RE_DFY_SRC  0;      ( bit 96: Tells the Re to read from DFY instead of DFM.
                                               (00364)     1   VE_ST       0;      ( Bit 95: Bit for starting the vector engine. Once the data is in SRAM and the address registers
                                               (00365)     1   ACCTOREG    0;      ( Bit 94: When ever the VE is done the data from the accumulators is latch to output-reg. Latching the
                                               (00366)                             ( data allows for clearing and restarting the VE with new addresses while processing the previous
                                               (00367)                             ( product
                                               (00368)     1   CLR_ACC     0;      ( Bit 93: This is needed to clear the accumulator's via software. When a new vector is starting it should
                                               (00369)                             ( zero. Having this explicit also add for back to back stacking of long vectors.
                                               (00370)     1   MODE_C      0;      ( Bit 92: Bit for extending the modes for the vector engines. This is used to allow for loading params
                                               (00371)                             ( into the ring mode in the vector engine. It is expected that MODE_A and MODE_B is zero and this allows
                                               (00372)                             ( for further combinations and extensions. Like more complex addressing.
                                               (00373)     1   MODE_D      0;      ( Bit 91: See above on bit 92..
                                               (00374)     1   A_SRC_HIGH  0;      ( Bit 90: Expanding the number of workregisters to 64.
                                               (00375)     1   B_SRC_HIGH  0;      ( Bit 89: See bit 90.
                                               (00376)     9   AVAILABLE   0;      ( Bits 88-80: This are available for future expansion. NOTE HEX..
                                               (00377) 
                                               (00378) ( Note that according to the fields description below: the low byte have the low bits.
                                               (00379) ( This legacy field description fill in the fields from byte 9 -> 0
                                               (00380) ( Thus the above should fill in the fields from byte 15 -> 10.
                                               (00381) 
                                               (00382) 
                                               (00383) ( This is the legacy fields that we dont touch at the moment. This start at bit 79 and going down to bit 0.
                                               (00384)     5    SEQC      11	  ;(SEQUENCER INSTRUCTION	(CONTINUE)
                                               (00385)     1    COND4		  ;
                                               (00386)     4    BITMSK		  ;
                                               (00387)    -4			  ;
                                               (00388)     4    NOMASK		  ;(USED AS DEFAULT MASK TO AVOID DOUBLE ASSIGNMENT
                                               (00389)    -5			  ;
                                               (00390)     5    COND      00     ;(CONDITION SELECTOR
                                               (00391)    -5			  ;
                                               (00392)     3	 AUX1	    0	  ;(AUX FCN FIELD 1	       (No Op
                                               (00393)     2	 AUX2	    0	  ;(AUX FCN FIELD 2	       (DATA0
                                               (00394)     1	 CPOL	    0	  ;(CONDITION POLARITY	       (if)
                                               (00395)     2	 MEMCP	    0  	  ;(MEMCLOCK SEQU ELEMENT TYPE (type C)
                                               (00396)     1	 MIFORM     1	  ;(MICROPROGRAM FORMAT SELECT (Not constant
                                               (00397)     8	 DATA1		  ;(IMMEDIATE DATA (TO D-BUS)
                                               (00398)    -8			  ;
                                               (00399)     4	 DS	    0	  ;(DBUS SOURCE
                                               (00400)     4	 MBMOP	    0	  ;(MBM operation	       (LANDD0)
                                               (00401)     4	 MAPR	    0	  ;(ADDR BITS 11,10,9,8 FOR VECTOR JUMPS
                                               (00402)    -4			  ;
                                               (00403)     C	 AD	  000	  ;(ADDRESS/DATA TO SEQUENCER,12 BIT
                                               (00404)    -4			  ;
                                               (00405)     4	 MAP		  ;(AUX FUNCTION SELECT
                                               (00406)    -4			  ;
                                               (00407)     4	 MSEL	          ;(ADDR SOURCE SELECT FOR VECTOR JUMPS AND ENDDECODE
                                               (00408)    -8			  ;
                                               (00409)     4	 DA0H		  ;(DATA0 7..4, TO AVOID DOUBLE ASSIGNMENT
                                               (00410)    -4			  ;
                                               (00411)     8	 DATA0		  ;(IMMEDIATE DATA (OLD DATA)
                                               (00412)     1    AFORM      0     ;(ALU A OPERAND FORMAT       (REG)
                                               (00413)     3    ALUS       0     ;( "  SOURCE CTRL            (D)
                                               (00414)     3    ALUF       0     ;( "  FUNCTION CTRL          (PLUS CARRYIN)
                                               (00415)     3    ALUD       0     ;( "  DESTINATION CTRL       (F TO Y, NO LOAD)
                                               (00416)     2	 CIN	    0	  ;(CARRY-IN SELECTOR	       (CARRYIN = 0)
                                               (00417)     4	 FF/PB	    0	  ;(CONDITION FLIPFLOPS /PGEN B(NO CHANGE)
                                               (00418)     5	 A	   1F	  ;(2901 A ADDRESS (ALSO USED FOR OTHER PURPOSES)
                                               (00419)     5    B         1F     ;(  "  B ADDRESS
                                               (00420)     4	 PC	    0	  ;(PULSE GENERATOR C	       (NO PULSE)
                                               (00421)     4	 SHIN/PA    0	  ;(SHIFT INPUT SELECTORS / PULSE GENERATOR A
                                               (00422)     2	 GASS	    0	  ;(GMEM source address select
                                               (00423)     2	 GASD	    0	  ;(GMEM destination address select
                                               (00424)     2    GACS       0     ;(GMEM source address control
                                               (00425)     2    GACD	    0     ;(GMEM destination address control
                                               (00426)     1    GAPP	    0     ;(GMEM address push/pop control
                                               (00427)     3	 PD	    0	  ;(PULSE GENERATOR D	       (NO PULSE)
                                               (00428) 
                                               (00429) 
                                               (00430) (
                                               (00431) (TOTAL LENGTH ABOVE IS 80 BITS.
                                               (00432) (THE FOLLOWING FIELD IS NOT INCLUDED IN THE MICROPROGRAM MEMORY:
                                               (00433)     3	 NOTE	    0	  ;(NOTE DIGIT TO BE PRINTED IN OUTPUT LISTINGS
                                               (00434)     1	 DDEST      0	  ;(Decode destination marker for mpgmscan tool
                                               (00435)     1	 NFDEC      0	  ;(Not full decode marker for mpgmscan tool
                                               (00436)     1	 NPCHG      0	  ;(No pointer change marker for mpgmscan tool
                                               (00437) (
                                               (00438) 'FIELDS SECTION
                                               (00439) (BYTE 9       8       7       6       5       4       3       2       1       0
                                               (00440) (!       !7      !  6    !    5  !      4!       !3      !  2    !    1  !
                                               (00441) (9876543210987654321098765432109876543210987654321098765432109876543210987654321
                                               (00442) (!       !       !       !       !       !       !       !       !       !     0
                                               (00443) (!    xxxxx xx xxxxxxxx  !       ! xxxx  !xxx  xxxx     xxxxx    xxxx  xx! xx xx
                                               (00444) (xxxxx   ! x  x  !     xxxxxxxxxxxx    xxx   xx  ! xxxxx !   xxxx!   xx  xx  x x
                                               (00445) (S    C  ! CM M D!     A !       ! A   A !A  C F ! A    B!   P   S   G G G G G P
                                               (00446) (E    O  ! OE I A!     D !       ! L   L !L  I F ! A    A!   C   H   A A A A A D
                                               (00447) (Q    N  ! NM F T!     D !       ! U   U !U  N / ! D    D!       I   S S C C P
                                               (00448) (C    D  ! DC O A!     R !       ! S   F !D    P ! D    D!       N   S D S D P
                                               (00449) (O    I  ! PP R 1!     E !       !       !     B ! R    R!       /	 !
                                               (00450) (N    T  ! O  M  !     S !       !       !       !       !       P	 !
                                               (00451) (T    I  ! L	 !     S !       !       !       !       !       A       !
                                               (00452) (R    O  !  	 !	 !	 !       !       !       !       !       !
                                               (00453) (O    N  !	 !       !	 !       !       !       !       !       !
                                               (00454) (L       !       !	 !       !       !       !       !       !       !
                                               (00455) (!    xxx!       ! xxxx  ! xxxxxxxx      !       !       !       !       !
                                               (00456) (!       xx    xxxx    xxxx    xxxx      !       !       !       !       !
                                               (00457) (!    A  A     D ! M   M ! D   M !       !       !       !       !       !
                                               (00458) (!    U  U     S ! B   A ! A   A !       !       !       !       !       !
                                               (00459) (!    X  X	 ! M   P ! T   P !       !       !       !       !       !
                                               (00460) (!    1  2	 ! O   R ! A     !       !       !       !       !       !
                                               (00461) (!       !       ! P     ! 0     !       !       !       !       !       !
                                               (00462) (!       !       !	 !	 !       !       !       !       !       !
                                               (00463) (!    x  !     CONSTANT  !     xxxx      !       !       !       !       !
                                               (00464) (!     xxxx      !       ! xxxx  !       !       !       !       !       !
                                               (00465) (!    C B!	 !	 ! D   M !       !       !       !       !       !
                                               (00466) (!    O I!	 !	 ! A   S !       !       !       !       !       !
                                               (00467) (!    N T! 	 !	 ! 0   E !       !       !       !       !       !
                                               (00468) (!    D M! 	 !	 ! H   L !       !       !       !       !       !
                                               (00469) (!    4 S! 	 !	 !       !       !       !       !       !       !
                                               (00470) (!      K! 	 !	 !   	 !       !       !       !       !       !
                                               (00471) (!       !       !	 !	 !       !       !       !       !       !
                                               (00472) (!     xxxx      !       !       !       !       !       !       !       !
                                               (00473) (!     N !       !       !       !       !       !       !       !       !
                                               (00474) (!     O !       !       !       !       !       !       !       !       !
                                               (00475) (!     M !       !       !       !       !       !       !       !       !
                                               (00476) (!     A !       !       !       !       !       !       !       !       !
                                               (00477) (!     S !       !       !       !       !       !       !       !       !
                                               (00478) (!     K !       !       !       !       !       !       !       !       !
                                               (00479) (!       !       !       !       !       !       !       !       !       !
                                               (00480) (DEFAULT:! 	 !	 !	 !       !       !       !       !       !
                                               (00481) (+-------+-------+-------+-------+-------+-------+-------+-------+-------+------
                                               (00482) (1000100000000100000000000000000000000000000000000011111111110000000000000000000
                                               (00483) (+-------+-------+-------+-------+-------+-------+-------+-------+-------+-----0
                                               (00484) (  8   8 ! 0   4 ! 0   0 ! 0   0 ! 0   0 ! 0   0 ! 3   F ! F   0 ! 0   0 ! 0   0
                                               (00485) (========!=======!=======!=======!=======!=======!=======!=======!=======!======
                                               (00486) 
                                               (00487) 'RULES SECTION
                                               (00488) *RULES*
                                               (00489) (DEFINTIONS
                                               (00490) LET CONDITION NOTEIS2 BE FIELD NOTE IS 2;
                                               (00491) LET CONDITION NOTEIS3 BE FIELD NOTE IS 3;
                                               (00492) 
                                               (00493) LET CONDITION NOTEISNOT4 BE FIELD NOTE IS NOT 4;
                                               (00494) 
                                               (00495) LET CONDITION ISRAMATOY BE FIELD ALUD IS 2;
                                               (00496) LET CONDITION ISBASSIGNED BE FIELD B IS ASSIGNED;
                                               (00497) 
                                               (00498) LET CONDITION ISSELBLOCK BE FIELD SHIN/PA IS IN RANGE C AND F;
                                               (00499) LET CONDITION ISSELBLOCKAUXSEQC BE FIELD SEQC IS ANY OF 16, 17;
                                               (00500) LET VALUE SELBLOCKAUXFLAG BE FIELD AUX1 MASKED WITH 1;
                                               (00501) LET CONDITION ISSELBLOCKAUX1 BE SELBLOCKAUXFLAG IS NOT 0;
                                               (00502) LET CONDITION ISSELBLOCKAUX BE ALL OF ISSELBLOCKAUXSEQC, ISSELBLOCKAUX1;
                                               (00503) 
                                               (00504) LET CONDITION SIMSELBLOCKS BE ALL OF ISSELBLOCK, ISSELBLOCKAUX;
                                               (00505) 
                                               (00506) LET VALUE SELBLOCK BE FIELD SHIN/PA ADDED TO -C;
                                               (00507) LET VALUE SELBLOCKAUX BE FIELD AUX1 SHIFTED BY 1 MASKED WITH 3;
                                               (00508) LET CONDITION EQUALSELBLOCKS BE SELBLOCK IS VALUE SELBLOCKAUX;
                                               (00509) 
                                               (00510) LET CONDITION ISCONDJUMP BE FIELD SEQC IS ANY OF
                                               (00511) 2, 3, 4, 5, 6, 7, 8, 9, A, C, D, E, F, 18, 19, 1A, 1B, 1D, 1F;
                                               (00512) LET CONDITION ISCONDASSIGNED BE FIELD COND IS ASSIGNED;
                                               (00513) 
                                               (00514) LET CONDITION ISOKTOSELBLOCK BE FIELD SEQC IS ANY OF
                                               (00515) 1, 15, 17, 1D, 1E, 1F;
                                               (00516) 
                                               (00517) LET CONDITION ISSHORTDIRECTJUMP BE FIELD SEQC IS ANY OF
                                               (00518) 4, 6, 8, 9, A, D, F, 10, 14, 16, 18;
                                               (00519) LET CONDITION ISLONGDIRECTJUMP BE FIELD SEQC IS ANY OF
                                               (00520) 5, 7, 15, 17,1D, 1F;
                                               (00521) 
                                               (00522) LET CONDITION ISVECTORJUMP BE FIELD SEQC IS 1;
                                               (00523) LET CONDITION ISCPOL0 BE FIELD CPOL IS 0;
                                               (00524) LET CONDITION ISCPOL1 BE FIELD CPOL IS 1;
                                               (00525) LET CONDITION ISSHORTVECTORJUMP BE ALL OF ISVECTORJUMP, ISCPOL0;
                                               (00526) LET CONDITION ISLONGVECTORJUMP BE ALL OF ISVECTORJUMP, ISCPOL1;
                                               (00527) 
                                               (00528) LET CONDITION ISSHORTJUMP BE ANY OF ISSHORTDIRECTJUMP, ISSHORTVECTORJUMP;
                                               (00529) LET CONDITION ISLONGJUMP BE ANY OF ISLONGDIRECTJUMP, ISLONGVECTORJUMP;
                                               (00530) 
                                               (00531) LET VALUE ADDRL BE * MASKED WITH FF;
                                               (00532) LET VALUE ADDRH BE * MASKED WITH FF00;
                                               (00533) LET VALUE ADDRB BE * SHIFTED BY C MASKED WITH F;
                                               (00534) LET VALUE NEXTADDRH BE ADDRH ADDED TO 100;
                                               (00535) LET CONDITION ISROWLAST BE ADDRL IS FF;
                                               (00536) LET CONDITION ISNOTROWLAST BE ADDRL IS NOT FF;
                                               (00537) 
                                               (00538) LET CONDITION ISSHORTJUMPONROWLAST BE ALL OF ISSHORTJUMP, ISROWLAST;
                                               (00539) LET CONDITION ISSHORTJUMPONNOTROWLAST BE ALL OF ISSHORTJUMP, ISNOTROWLAST;
                                               (00540) 
                                               (00541) LET VALUE DATA0H BE FIELD DATA0 MASKED WITH FF00;
                                               (00542) 
                                               (00543) LET CONDITION EQUALADDRH BE ADDRH IS VALUE DATA0H;
                                               (00544) LET CONDITION EQUALNEXTADDRH BE NEXTADDRH IS VALUE DATA0H;
                                               (00545) 
                                               (00546) LET VALUE ADB BE FIELD AD SHIFTED BY C MASKED WITH F;
                                               (00547) LET CONDITION NOTEQUALADDRB BE ADDRB IS NOT VALUE ADB;
                                               (00548) LET CONDITION LONGJUMPCHANGESBLOCK BE ALL OF ISLONGJUMP, NOTEQUALADDRB;
                                               (00549) 
                                               (00550) LET CONDITION ISANYSELBLOCK BE ANY OF ISSELBLOCK, ISSELBLOCKAUX;
                                               (00551) 
                                               (00552) LET CONDITION LONGJUMPSELBLOCK BE ALL OF ISLONGJUMP, ISANYSELBLOCK;
                                               (00553) 
                                               (00554) LET CONDITION EQUALSELBLOCKAD BE SELBLOCK IS VALUE ADB;
                                               (00555) LET CONDITION CORRECTSELBLOCK BE ALL OF ISSELBLOCK, EQUALSELBLOCKAD;
                                               (00556) 
                                               (00557) LET CONDITION EQUALSELBLOCKAUX BE SELBLOCKAUX IS VALUE ADB;
                                               (00558) LET CONDITION CORRECTSELBLOCKAUX BE ALL OF ISSELBLOCKAUX, EQUALSELBLOCKAUX;
                                               (00559) 
                                               (00560) LET CONDITION CORRECTANYSELBLOCK BE ANY OF CORRECTSELBLOCK, CORRECTSELBLOCKAUX;
                                               (00561) 
                                               (00562) LET CONDITION ISPLUS1JUMP BE FIELD SEQC IS ANY OF 1D, 1F;
                                               (00563) LET VALUE DATA0LB BE FIELD DATA0 MASKED WITH 1;
                                               (00564) LET CONDITION ISDATA0EVEN BE DATA0LB IS 0;
                                               (00565) 
                                               (00566) LET CONDITION ISSKIP BE FIELD SEQC IS 19;
                                               (00567) LET VALUE ADDRLB BE * MASKED WITH 1;
                                               (00568) LET CONDITION ISADDRODD BE ADDRLB IS NOT 0;
                                               (00569) 
                                               (00570) LET CONDITION SKIPTOCHECK BE ALL OF NOTEISNOT4, ISSKIP;
                                               (00571) 
                                               (00572) (IGNORES FOR DOUBLE ASSIGNMENTS
                                               (00573) ALWAYS IGNORE DOUBLE ASSIGNMENT FOR NOTE;
                                               (00574) IF NOTEIS2 THEN IGNORE DOUBLE ASSIGNMENT FOR SEQC;
                                               (00575) IF NOTEIS3 THEN IGNORE DOUBLE ASSIGNMENT FOR AUX1;
                                               (00576) 
                                               (00577) (IGNORES FOR OVERLAPPING ASSIGNMENTS
                                               (00578) ALWAYS IGNORE OVERLAPPING ASSIGNMENTS OF AD AND MSEL; (TODO
                                               (00579) ALWAYS IGNORE OVERLAPPING ASSIGNMENTS OF BITMSK AND NOMASK; (TODO
                                               (00580) ALWAYS IGNORE OVERLAPPING ASSIGNMENTS OF MSEL AND DATA0; (TODO -- TestIO
                                               (00581) 
                                               (00582) (CONSTRAINTS
                                               (00583) IF ISRAMATOY THEN MAKE SURE ISBASSIGNED FOR B IS NOT DEFINED FOR RAMATOY;
                                               (00584) IF SIMSELBLOCKS THEN MAKE SURE EQUALSELBLOCKS FOR CONFLICTING BLOCK SELECTION;
                                               (00585) IF ISCONDJUMP THEN MAKE SURE ISCONDASSIGNED FOR MISSING JUMP CONDITION;
                                               (00586) IF ISSELBLOCK THEN MAKE SURE ISOKTOSELBLOCK FOR
                                               (00587) BLOCK SELECTION ON SHORT OR UNCONDITIONAL JUMP;
                                               (00588) IF ISSHORTJUMPONROWLAST THEN MAKE SURE EQUALNEXTADDRH FOR
                                               (00589) SHORT JUMP OUT OF RANGE;
                                               (00590) IF ISSHORTJUMPONNOTROWLAST THEN MAKE SURE EQUALADDRH FOR
                                               (00591) SHORT JUMP OUT OF RANGE;
                                               (00592) IF LONGJUMPCHANGESBLOCK THEN MAKE SURE ISANYSELBLOCK FOR
                                               (00593) MISSING BLOCK SELECTION;
                                               (00594) IF LONGJUMPSELBLOCK THEN MAKE SURE CORRECTANYSELBLOCK FOR
                                               (00595) LONG JUMP TO WRONG BLOCK;
                                               (00596) IF ISPLUS1JUMP THEN MAKE SURE ISDATA0EVEN FOR PLUS1 JUMP TO ODD ADDRESS;
                                               (00597) IF SKIPTOCHECK THEN MAKE SURE ISADDRODD FOR SKIP ON AN EVEN ADDRESS;
                                               (00598) 
                                               (00599) 'GENERAL INFO
                                               (00600) *CODES*
                                               (00601) (
                                               (00602) (	  GENERAL INFORMATION
                                               (00603) (	  ===================
                                               (00604) (
                                               (00605) (---------------------------------------------------------------------
                                               (00606) (
                                               (00607) (EXPLANATION OF WORD-CONNECTING AND ABBREVIATING FUNCTION:
                                               (00608) (DURING PASS 1, DEFINITIONS OF THE TYPE  " NAME: 'STRING' "
                                               (00609) (ARE STORED IN THE CODE LIST, LIKE ALL MNEMONIC DEFINITIONS IN THE
                                               (00610) (CODES SECTION. WHEN DETECTING ONE OF THESE NAMES DURING PASS 2 OR 3,
                                               (00611) (IN THE PROGRAM SECTION, THE ASSEMBLER PROGRAM WILL INTERPRET IT
                                               (00612) (IN THE FOLLOWING MANNER:
                                               (00613) (THE NAME AND THE SPACE AFTER IT ARE REPLACED, IN THE INPUT BUFFER
                                               (00614) (AREA, BY THE STRING BETWEEN THE APOSTROPHES. AFTER THAT, THE
                                               (00615) (ASSEMBLER CONTINUES READING, SEARCHING FOR A NEW WORD, STARTING AT
                                               (00616) (THE LOCATION WHERE THE FIRST CHARACTER OF THE STRING WAS WRITTEN.
                                               (00617) (
                                               (00618) (-------------------------------------------------------------------------------
                                               (00619) (
                                               (00620) (THE FOLLOWING WORD WILL BE ACCEPTED BUT WILL NOT HAVE ANY EFFECT
                                               (00621) (ON THE ASSEMBLER OUTPUT:
                                               (00622) (
                                               (00623) WITH:       ''
                                               (00624) (
                                               (00625) (THE FOLLOWING MNEMONIC IS USED IN EXTERNAL REFERENCE LIST, IN ORDER TO
                                               (00626) (GET A PRINTOUT OF THE ADDRESS VALUE OF A LABEL IN THE MICROPROGRAM
                                               (00627) (MODULE BEEING COMPILED:
                                               (00628) (
                                               (00629) %:    '>>> XADR:=@'
                                               (00630) (
                                               (00631) (THE FOLLOWING MNEMONIC IS USED IN SP<->CPU MESSAGE LIST, IN ORDER TO
                                               (00632) (GET A PRINTOUT OF THE LAST 8 BITS OF THE VALUE OF A LABEL:
                                               (00633) (
                                               (00634) >:    '>>> CODE:=@'
                                               (00635) >>>:  SEQC:=00, COND:=00, CPOL:=0, MEMCP:=0, MIFORM:=0, DATA1:=0,
                                               (00636)       AD:=0, AFORM:=0, ALUS:=0, ALUF:=0, ALUD:=0, CIN:=0, FF/PB:=0,
                                               (00637)       A:=0, B:=0, PC:=0, SHIN/PA:=0, GASS:=0, GASD:=0, GACS:=0,
                                               (00638)       GACD:=0, GAPP:=0, PD:=0;
                                               (00639) 
                                               (00640) (
                                               (00641) (THE VALUE IS TO BE USED AS AN SP ORDER. WHEN RECEIVING THE ORDER
                                               (00642) (AND DOING "SPDECODE", A JUMP IN THE MICROPROGRAM WILL BE PERFORMED,
                                               (00643) (TO THE LOCATION OF THE LABEL.
                                               (00644) (
                                               (00645) (THE SAME MNEMONIC IS USED IN THE CPU->SP MESSAGE LIST. THE ADDRESS
                                               (00646) (OF THE MICROINSTRUCTION GENERATING A CALL TO SP IS USED AS A
                                               (00647) (MESSAGE TO SP IDENTIFYING THE CAUSE OF THE CALL.
                                               (00648) (
                                               (00649) 'NOTES
                                               (00650) (
                                               (00651) (	  NOTES
                                               (00652) (	  =====
                                               (00653) (
                                               (00654) (-------------------------------------------------------------------------------
                                               (00655) (
                                               (00656) (THE FOLLOWING WORDS WILL GENERATE A DIGIT IN THE "NOTE" FIELD.
                                               (00657) (THE DIGIT WILL APPEAR ALSO IN THE LISTING MADE BY ASSEMBLER PASS 3.
                                               (00658) (
                                               (00659) DS:	    NOTE1;   (DEFINE STORAGE)
                                               (00660) DBLASS:     NOTE2;   (DOUBLE ASSIGNMENT IN SEQCTRL WILL BE REGISTERED
                                               (00661) DBLAUX:     NOTE3;   (DOUBLE ASSIGNMENT IN AUX1 WILL BE REGISTERED
                                               (00662) ORG:	    NOTE4;   (DISABLES SOME MAKE SURE RULES...
                                               (00663) NOT:        'NOT'
                                               (00664) NOTUSED:    NOTE1;   (WORD NOT USED)
                                               (00665) MODELDEPDT: NOTE1;   (MODEL DEPENDENT)
                                               (00666) !!!!!:	    NOTE1;   (UNUSED HOLE, TEMPRARY MODIFICATION, A.S.O
                                               (00667) 
                                               (00668) (
                                               (00669) NOTE1: NOTE:=1;
                                               (00670) NOTE2: NOTE1 NOTE:=2;
                                               (00671) NOTE3: NOTE2 NOTE:=3;
                                               (00672) NOTE4: NOTE3 NOTE:=4;
                                               (00673) 
                                               (00674) DECODEDEST: DDEST:=1;
                                               (00675) NOTFULLDECODE: NFDEC:=1;
                                               (00676) NOPTRCHANGE: NPCHG:=1;
                                               (00677) (ECODEDEST: NOTE:=8;
                                               (00678) (
                                               (00679) 'SEQUENCER OPERATIONS
                                               (00680) (
                                               (00681) (  Table  1. Functions determined by the SEQC-field
                                               (00682) (----+---+------+--------+-----+---------------------------------------+-------+
                                               (00683) (SEQC!C- ! COND !  AD	 !Addi-!				       !Corresp!
                                               (00684) (    !POL!   X2 !  !DATA0!tion ! Description                           !old CP !
                                               (00685) (    !	 !AX1	!MR! !MAP!tab #!				       !SQCT!JT!
                                               (00686) (----+---+------+--+-+---+-----+---------------------------------------+----+--+
                                               (00687) (  0 ! 0 !- --	! - -  - !     ! RESET				       ! 0   - !
                                               (00688) (  0 ! 1 !1mask ! - d10..!     ! BREAK1 (->adr d + masked reqbits)     !  - -  !
                                               (00689) (  0 ! 1 !0mask ! - d1100!     ! BREAK2 (->adr d + maskd LZPCIRQ(3..0))! - -   !
                                               (00690) (  0 ! 1 !1mask ! - d1100!     ! BREAK3 (->adr d + maskd LZPCIRQ(7..4))!  - -  !
                                               (00691) (----+---+------+--------+-----+---------------------------------------+-------+
                                               (00692) ( 11 ! - !  --	! - -  - !    6! CONTINUE                    (default) ! E   - !
                                               (00693) ( 19 !t/f! cond ! - -  - ! 3   ! SKIP IF cond			       !  - -  !
                                               (00694) ( 14 ! - !  --	! -  d	 !  4  ! UNC GO TO d			       !(3    )!
                                               (00695) ( 1D !t/f! cond !  ad	 !     ! LGO TO ad, PLUS 1 IF cond	       !(6   1)!
                                               (00696) ( 15 ! - !  --	!  ad	 !  4  ! UNC LGO TO ad			       ! 2   1 !
                                               (00697) (  4 !t/f! cond ! -  d	 !     ! GO TO d IF cond 		       !(3    )!
                                               (00698) (  8 !t/f! cond ! -  d	 !     ! GO TO d IF cond, ELSE TO STORED       !(7   1)!
                                               (00699) (  5 !t/f! cond !  ad	 !     ! LGO TO ad IF cond		       ! 3   1 !
                                               (00700) (----+---+------+--------+-----+---------------------------------------+-------+
                                               (00701) ( 16 ! - !  --	! -  d	 !   5 ! UNC DO d			       !(1   1)!
                                               (00702) ( 1F !t/f! cond !  ad	 !     ! LDOPLUS1 ad, IF cond		       !  - -  !
                                               (00703) ( 17 ! - !  --	!  ad	 !   5 ! UNC LDO ad			       !(1   1)!
                                               (00704) (  6 !t/f! cond ! -  d	 !     ! DO d IF cond			       !(1   1)!
                                               (00705) (  A !t/f! cond ! -  d	 !     ! DO d IF cond, ELSE DO STORED	       !(5   1)!
                                               (00706) (  7 !t/f! cond !  ad	 !     ! LDO ad IF cond 		       ! 1   1 !
                                               (00707) (----+---+------+--------+-----+---------------------------------------+-------+
                                               (00708) ( 13 ! - !  --	! - -  - !    6! UNC RETURN			       !(A   -)!
                                               (00709) ( 1B !t/f! cond ! - -  - ! 3   ! UNC RETURN & SKIP 1 IF cond	       !  - -  !
                                               (00710) (  3 !t/f! cond ! - -  - ! 3   ! RETURN IF cond 		       ! A   - !
                                               (00711) (  9 !t/f! cond ! -  d	 !     ! POPJUMP d IF cond		       !(B   -)!
                                               (00712) (----+---+------+--------+-----+---------------------------------------+-------+
                                               (00713) (to be continued on next page.
                                               (00714) 'SEQUENCER OPERATIONS
                                               (00715) (
                                               (00716) (----+---+------+--------+-----+---------------------------------------+-------+
                                               (00717) ( 1E ! - !  --	!mr  01..!  4  ! UNC YDECODE	 		       !(3   0)!
                                               (00718) ( 1E ! - !  --	!mr  11mm!  4  ! UNC mDECODE (see tab 2) 	       !(3   3)!
                                               (00719) (  E !t/f! cond !mr  01..!     ! YDECODE IF cond		       ! 3   0 !
                                               (00720) (  E !t/f! cond !mr  11mm!     ! mDECODE IF cond (see tab 2)	       ! 3   3 !
                                               (00721) (  1 ! 0 !0mask !   d01..!     ! VJTO d PLUS LSHALF OF Y 	       !(2   2)!
                                               (00722) (  1 ! 0 !1mask !   d01..!     ! VJTO d PLUS MSHALF OF Y 	       !(2   2)!
                                               (00723) (  1 ! 0 !0mask !   d11mm!     ! VJTO d PLUS LSHALF OF m (see tab 2)   !(2   3)!
                                               (00724) (  1 ! 0 !1mask !   d11mm!     ! VJTO d PLUS MSHALF OF m (see tab 2)   !(2   3)!
                                               (00725) (  1 ! 1 !0mask !  ad01..!     ! LVJTO ad PLUS LSHALF OF Y	       ! 2   2 !
                                               (00726) (  1 ! 1 !1mask !  ad01..!     ! LVJTO ad PLUS MSHALF OF Y	       ! 2   2 !
                                               (00727) (  1 ! 1 !0mask !  ad11mm!     ! LVJTO ad PLUS LSHALF OF m (see tab 2) ! 2   3 !
                                               (00728) (  1 ! 1 !1mask !  ad11mm!     ! LVJTO ad PLUS MSHALF OF m (see tab 2) ! 2   3 !
                                               (00729) (----+---+------+--------+-----+---------------------------------------+-------+
                                               (00730) (  C !t/f! cond !  ad	 !     ! STORE ad IF cond, &PUSH CSTACK        ! 4   1 !
                                               (00731) ( 1C ! 0 !  --	! -  d	 !  4  ! STORE d		               !(C   1)!
                                               (00732) ( 1C ! 1 !  --	!  ad	 !  4  ! LSTORE ad			       ! C   1 !
                                               (00733) (  B ! 0 !  --	! -  01..!  4  ! LOAD CTR FROM YREG		       !(C   0)!
                                               (00734) (  B ! 0 !  --	! -  11mm!  4  ! LOAD CTR FROM m (see tab 2)	       !(C   3)!
                                               (00735) (  B ! 1 !  --	!mr  01..!  4  ! LLOAD CTR FROM YREG		       ! C   0 !
                                               (00736) (  B ! 1 !  --	!mr  11mm!  4  ! LLOAD CTR FROM m (see tab 2)	       ! C   3 !
                                               (00737) (----+---+------+--------+-----+---------------------------------------+-------+
                                               (00738) ( 12 ! - !  --	! - -  - !    6! REPEAT CSTACK UNTIL CTR=0 	       ! 8   - !
                                               (00739) ( 1A !t/f! cond ! - -  - ! 3   ! REP CSTACK UNTIL CTR=0 &SKIP IF cond  !  - -  !
                                               (00740) (  2 !t/f! cond ! - -  - ! 3   ! PROCEED IF cond, ELSE REPEAT CSTACK   ! D   - !
                                               (00741) ( 10 ! - !  --	!    d	 !  4  ! REPEAT FROM d UNTIL CTR=0 	       !(9   1)!
                                               (00742) ( 18 !t/f! cond !    d	 !     ! REPPLUS1 FROM d, IF cond, UNTIL CTR=0 !  - -  !
                                               (00743) (  D !t/f! cond !    d	 !     ! IF cond CONT, EIF C=0 GT d, EREP CSTK !(F   1)!
                                               (00744) (  F !t/f! cond !    d	 !     ! IF C=0 CONT, EGT d IF cond, EREP CSTK !  - -  !
                                               (00745) (----+---+------+--------+-----+---------------------------------------+-------+
                                               (00746) '
                                               (00747) (  Table 2. Select of "m" in                  Table 3. Additional function for
                                               (00748) (  operations 13..15, 18 (och 0)	      operations 2,10,11,1A,1B
                                               (00749) (----------+--------------+                (Note: Provided DS = "DSOURCE CU")
                                               (00750) ( MAP(1:0) !		  !		   +----------+-------------------+
                                               (00751) (----------+--------------+		   ! MAP(1:0) ! 		  !
                                               (00752) (    00    !  "LZPCIRQ"   !                +----------+-------------------+
                                               (00753) (    01    !     IR       !                !    00    ! DSOURCE "LZPCIRQ" !
                                               (00754) (    10    !	 DFM	  !		   !	01    ! DSOURCE  IR	  !
                                               (00755) (    11    !	 SPCMD	  !		   !	11    ! DSOURCE  SPCMD	  !
                                               (00756) (----------+--------------+		   +----------+-------------------+
                                               (00757) (
                                               (00758) ( NOTE!    LZPCIRQ is a combination of LINK, ZERO, PCCY, CARRY, TRACE, IRQ(2:0).
                                               (00759) (
                                               (00760) (
                                               (00761) (  Table 4. Additional functions to operations 3,5,13,17,18,1C.
                                               (00762) (---+-------+------+-----------------------------------------------------------+
                                               (00763) (C- ! COND  ! MAP  !							       !
                                               (00764) (POL! AUX1  !	   !							       !
                                               (00765) (---+-------+------+-----------------------------------------------------------+
                                               (00766) (   ! 000.. !	   !   No Op (default)					       !
                                               (00767) (   ! 001.. !	   !   POP CSTACK					       !
                                               (00768) (   ! 010.. !	   !   DECREMENT CTR					       !
                                               (00769) (   ! 011.. !	   !   POP AND DECREMENT CTR				       !
                                               (00770) (   ! 100.. !	   !   INCREMENT STCTR					       !
                                               (00771) (   ! 101.. !	   !   PUSH CSTACK (egen adr+1 -> cstack)		       !
                                               (00772) (   ! 110.. !	   !   WHEN SPREQ					       !
                                               (00773) (   ! 111.. !	   !   PUSH CSTACK & DECREMENT CTR			       !
                                               (00774) (---+-------+------+-----------------------------------------------------------+
                                               (00775) (
                                               (00776) (  Table 5. Additional functions to operations 9,B.
                                               (00777) (---+-------+------+-----------------------------------------------------------+
                                               (00778) (C- ! COND  ! MAP  !							       !
                                               (00779) (POL! AUX1  !	   !							       !
                                               (00780) (---+-------+------+-----------------------------------------------------------+
                                               (00781) (   ! 000.. !	   !   No Op (default)					       !
                                               (00782) (   ! 001.. !	   !   BLOCK 0						       !
                                               (00783) (   ! 010.. !	   !   DECREMENT CTR					       !
                                               (00784) (   ! 011.. !	   !   BLOCK 1				       		       !
                                               (00785) (   ! 100.. !	   !   No Op					       	       !
                                               (00786) (   ! 101.. !	   !   BLOCK 2						       !
                                               (00787) (   ! 110.. !	   !   WHEN SPREQ					       !
                                               (00788) (   ! 111.. !	   !   BLOCK 3						       !
                                               (00789) (---+-------+------+-----------------------------------------------------------+
                                               (00790) 'SEQUENCER OPERATIONS
                                               (00791) (
                                               (00792) (  Table 6. Aditional functions to operations 1, F, och 19
                                               (00793) (---+-------+------+-----------------------------------------------------------+
                                               (00794) (C- ! COND  ! MAP  !							       !
                                               (00795) (POL! AUX1  !	   !							       !
                                               (00796) (   !	 X2 !	   !							       !
                                               (00797) (---+-------+------+-----------------------------------------------------------+
                                               (00798) ( 0 ! 000.. !	   !   No Op (default)					       !
                                               (00799) ( 0 ! 001.. !	   !   POP CSTACK (See note)                                   !
                                               (00800) ( 0 ! 010.. !	   !   DECREMENT CTR					       !
                                               (00801) ( 0 ! 011.. !	   !   POP AND DECREMENT CTR (See note)			       !
                                               (00802) ( 0 ! 100.. !	   !   INCREMENT STCTR (See note)			       !
                                               (00803) ( 0 ! 101.. !	   !   PUSH CSTACK (egen adr+1 -> cstack)(See note)	       !
                                               (00804) ( 0 ! 110.. !	   !   WHEN SPREQ					       !
                                               (00805) ( 0 ! 111.. !	   !   PUSH CSTACK & DECREMENT CTR (See note)		       !
                                               (00806) ( 0 ! ....1 ! 00.. !   DSOURCE CSTACK					       !
                                               (00807) ( 0 ! ....1 ! 01.. !   DSOURCE CTRL					       !
                                               (00808) ( 0 ! ....1 ! 10.. !   DSOURCE CSTACKH (obs: i msb l{ggs signalen STCTREQ0)    !
                                               (00809) ( 0 ! ....1 ! 11.. !   DSOURCE CTRH					       !
                                               (00810) ( 0 ! ...00 ! .... !   DSOURCE DATA0	    				       !
                                               (00811) ( 0 ! ...10 ! 1100 !   DSOURCE LZPCIRQ					       !
                                               (00812) ( 0 ! ...10 ! 1101 !   DSOURCE IR					       !
                                               (00813) ( 0 ! ...10 ! 1111 !   DSOURCE SPCMD					       !
                                               (00814) ( 1 ! 0mmmm ! 01.. !   DSOURCE d PLUS LSHALF OF Y, WITH BITMASK mmmm	       !
                                               (00815) ( 1 ! 1mmmm ! 01.. !   DSOURCE d PLUS MSHALF OF Y, WITH BITMASK mmmm	       !
                                               (00816) ( 1 ! 1mmmm ! 10.. !   DSOURCE d PLUS IRA, WITH BITMASK mmmm		       !
                                               (00817) ( 1 ! 0mmmm ! 1100 !   DSOURCE d PLUS LSHALF OF LZPCIRQ, WITH BITMASK mmmm     !
                                               (00818) ( 1 ! 1mmmm ! 1100 !   DSOURCE d PLUS MSHALF OF LZPCIRQ, WITH BITMASK mmmm     !
                                               (00819) ( 1 ! 0mmmm ! 1101 !   DSOURCE d PLUS LSHALF OF IR, WITH BITMASK mmmm	       !
                                               (00820) ( 1 ! 1mmmm ! 1101 !   DSOURCE d PLUS MSHALF OF IR, WITH BITMASK mmmm	       !
                                               (00821) ( 1 ! 0mmmm ! 1110 !   DSOURCE d PLUS LSHALF OF MEM, WITH BITMASK mmmm	       !
                                               (00822) ( 1 ! 1mmmm ! 1110 !   DSOURCE d PLUS MSHALF OF MEM, WITH BITMASK mmmm	       !
                                               (00823) ( 1 ! 0mmmm ! 1111 !   DSOURCE d PLUS LSHALF OF SPCMD, WITH BITMASK mmmm       !
                                               (00824) ( 1 ! 1mmmm ! 1111 !   DSOURCE d PLUS MSHALF OF SPCMD, WITH BITMASK mmmm       !
                                               (00825) (---+-------+------------------------------------------------------------------+
                                               (00826) (Note: When op=F or (op=19 and CTR=0), no PUSH, POP, or INCREMENT STCTR will
                                               (00827) (be performed.
                                               (00828) (
                                               (00829) 'GO TO
                                               (00830) (
                                               (00831) (	  GO TO
                                               (00832) (	  =====
                                               (00833) (
                                               (00834) (-------------------------------------------------------------------------------
                                               (00835) (Skip
                                               (00836) (Example:
                                               (00837) ("SKIP IF CARRY"                   (Must be located on a ODD address
                                               (00838) (
                                               (00839) (Simple jumps
                                               (00840) (
                                               (00841) (a) short (8 least significant address bits given)
                                               (00842) (Examples:
                                               (00843) ("UNC GO TO LABEL1"
                                               (00844) ("GO TO LABEL2 IF NOT ZERO"
                                               (00845) (
                                               (00846) (b) long (12 least significant address bits given)
                                               (00847) (Examples:
                                               (00848) (
                                               (00849) ("UNCL GO TO LABEL1"
                                               (00850) ("LGO TO LABEL2 IF NOT ZERO"
                                               (00851) (
                                               (00852) (NOTE: "SELECT BLK2" (FOR EXAMPLE) HAS TO BE ADDED WHEN JUMPING BETWEEN
                                               (00853) (MICROPROGRAM BLOCKS (4096 WORDS). NOTE, HOWEVER, THAT FIELD SHIN/PA
                                               (00854) (IS OCCUPIED BY THIS BLOCK SELECTION.
                                               (00855) ("SELECT BLK.." CAN BE USED WITH ALL KINDS OF JUMP, ALSO SUBROUTINE CALLS.
                                               (00856) (
                                               (00857) SKIP:	  SEQC:=19;
                                               (00858) UNC:      'U'
                                               (00859) UGO:      'UGO'
                                               (00860) UGOTO:    'UGT DATA0:=@'
                                               (00861) UGT:	  SEQC:=14;
                                               (00862) 
                                               (00863) GO:       'GO'
                                               (00864) GOTO:     'GT DATA0:=@'
                                               (00865) GT:	  SEQC:=4;
                                               (00866) 
                                               (00867) UNCL:     'UL'                (kan skriva antingen UNC L GO..
                                               (00868) UL:       'UL'                (eller UNCL GO..
                                               (00869) ULGO:     'ULGO'
                                               (00870) ULGOTO:   'ULGT AD:=@'
                                               (00871) ULGT:	  SEQC:=15;
                                               (00872) 
                                               (00873) LGO:      'LGO'
                                               (00874) LGOTO:    'LGT AD:=@'
                                               (00875) LGT:	  SEQC:=5;
                                               (00876) (---------
                                               (00877) ("ELSE TO STORED" USED TOGETHER WITH A "GO TO" STATEMENT
                                               (00878) ("PLUS 1" USED TOGETHER WITH A "LGO TO" STATEMENT
                                               (00879) (NOTE: THESE TWO ARE MUTUALLY EXCLUSIVE.
                                               (00880) ("ELSE GO TO STORED" CAN ALSO BE USED WITH A 256-WAY DECODE JUMP.
                                               (00881) (
                                               (00882) (Examples:
                                               (00883) ("GO TO LAB3 IF CARRY, ELSE TO STORED" (STORED refers to contents of CTR/REG)
                                               (00884) ("LGO TO LABEL4, PLUS 1 IF CARRY"  (LABEL4 must be even)
                                               (00885) (
                                               (00886) ELSE:     'ELSE'
                                               (00887) ELSETO:   'ELTO'
                                               (00888) ELTOSTORED:SEQC:=8 DBLASS;	(DOUBLE ASSIGNMENT WILL BE REGISTERED)
                                               (00889) (PLUS IS DEFINED ELSEWHERE)
                                               (00890) PLUS1:	  SEQC:=1D DBLASS;	(DOUBLE ASSIGNMENT WILL BE REGISTERED)
                                               (00891) 'AUXFN
                                               (00892) (
                                               (00893) (	  AUXILIARY FUNCTIONS SPECIFIED BY COND FIELD
                                               (00894) (	  ===========================================
                                               (00895) (
                                               (00896) (-------------------------------------------------------------------------------
                                               (00897) (
                                               (00898) (COMBINED WITH SEQC = 11, 14, 15, 16, 17, 13, 1E, 1C, 0B, 12, 10.
                                               (00899) (EXAMPLE 1:
                                               (00900) ("GO TO LABEL1 WHEN SPREQ"
                                               (00901) (THE TIMING HARDWARE WILL STOP UNTIL SPREQ IS VALID
                                               (00902) (
                                               (00903) (EXAMPLE 2:
                                               (00904) ("UNC LDO LABEL1, BLOCK 1"
                                               (00905) (PERFORMS A LONG JUMP TO LABEL1 IN BLOCK 1
                                               (00906) (
                                               (00907) WHEN:      'WHEN'
                                               (00908) WHENSPREQ: AUX1:=6 ;
                                               (00909) (
                                               (00910) POPCSTACK:  AUX1:=1 ;                   (POP:      'POP' (defined elsewhere)
                                               (00911) (
                                               (00912) DECTR:      AUX1:=2 ;                   (DECREMENT:'DE' (defined elsewhere)
                                               (00913) (
                                               (00914) POPAND:    'P'
                                               (00915) PDECREMENT:'PD'
                                               (00916) PDCTR:	    AUX1:=3 ;
                                               (00917) (
                                               (00918) PUSH:     'PUSH'
                                               (00919) PUSHCSTACK: AUX1:=5 ;
                                               (00920) (
                                               (00921) INSTCTR:    AUX1:=4 ;                   (INCREMENT:'IN' (defined elsewhere)
                                               (00922) 
                                               (00923) &DECREMENT:'&DE'                        (&:        '&' (defined elsewhere)
                                               (00924) &DECTR:     AUX1:=7 DBLAUX;
                                               (00925) 
                                               (00926) BLOCK:     'BLK'
                                               (00927) BLOCK0:     AUX1:=1;
                                               (00928) BLOCK1:     AUX1:=3;
                                               (00929) BLOCK2:     AUX1:=5;
                                               (00930) BLOCK3:     AUX1:=7;
                                               (00931) BLK0:       AUX1:=1;
                                               (00932) BLK1:       AUX1:=3;
                                               (00933) BLK2:       AUX1:=5;
                                               (00934) BLK3:       AUX1:=7;
                                               (00935) (
                                               (00936) 'VECTOR JUMPS
                                               (00937) (
                                               (00938) (	  UNCONDITIONAL 2- TO 16-WAY JUMPS
                                               (00939) (	  ================================
                                               (00940) (
                                               (00941) (-------------------------------------------------------------------------------
                                               (00942) (UNCONDITIONAL 2- TO 16-WAY DECODE JUMPS, WITH SHIFTING AND MASKING
                                               (00943) (OF TESTED BYTES
                                               (00944) (
                                               (00945) (EXAMPLE STATEMENT:
                                               (00946) ("VECTOR JUMP TO LABEL1 PLUS LSHALF OF IR, WITH BITMASK 1001"
                                               (00947) (
                                               (00948) (THE WORD "LONG" CAN BE ADDED IN THE BEGINNING, TO 12 BIT ADDRESS INSTEAD OF 8.
                                               (00949) ("LSHALF" CAN BE REPLACED BY "MSHALF".
                                               (00950) ("IR" CAN BE REPLACED BY "Y", "MEM", "SP", "LZPCIRQ".
                                               (00951) (IF "Y" IS SELECTED, THE Y BUS VALUE IN THE PREVIOUS CYCLE WILL BE TESTED.
                                               (00952) ("1001" CAN BE REPLACED BY ANY COMBINATION OF 4 BITS.
                                               (00953) ("LABEL1" CAN BE REPLACED BY ANY NAME GIVEN TO THE BASE ADDRESS FOR
                                               (00954) (THE VECTOR JUMP, I.E. THE DESTINATION ADDRESS FOR THE CASE WHEN THE
                                               (00955) (TESTED BITS ARE ALL ZERO.
                                               (00956) (IN THE EXAMPLE ABOVE, A JUMP WILL BE PERFORMED TO LABEL1 WITH AN OFFSET
                                               (00957) (OF 0, +1, +8, OR +9, DEPENDING ON THE VALUES OF THE TESTED BITS.
                                               (00958) (THE BASE ADDRESS, HERE NAMED LABEL1, SHOULD BE A MULTIPLE OF HEX 10.
                                               (00959) (
                                               (00960) VECTOR:    'VECTOR'
                                               (00961) VECTORJUMP:'VJ'
                                               (00962) VJTO:      'S01 CPOL:=0 DATA0:=@'
                                               (00963) S01:	   SEQC:=1 NOMASK:=F;
                                               (00964) LONG:      'L'
                                               (00965) LVECTOR:   'LV'
                                               (00966) LVJUMP:    'LVJ'
                                               (00967) LVJTO:     'S01 CPOL:=1 AD:=@'
                                               (00968) PLUS:      'PLUS'
                                               (00969) PLUSLSHALF:COND4:=0;
                                               (00970) PLUSMSHALF:COND4:=1;
                                               (00971) OF:        'OF'
                                               (00972) OFYREG:	   MSEL:=4;
                                               (00973) OFIR:	   MSEL:=D;
                                               (00974) OFMEM:	   MSEL:=E;
                                               (00975) OFSP:	   MSEL:=F;
                                               (00976) OFLZPCIRQ: MSEL:=C;
                                               (00977) BITMASK:   'BM'
                                               (00978) BM0001:    BITMSK:=1 ;
                                               (00979) BM0010:    BITMSK:=2 ;
                                               (00980) BM0011:    BITMSK:=3 ;
                                               (00981) BM0100:    BITMSK:=4 ;
                                               (00982) BM0101:    BITMSK:=5 ;
                                               (00983) BM0110:    BITMSK:=6 ;
                                               (00984) BM0111:    BITMSK:=7 ;
                                               (00985) BM1000:    BITMSK:=8 ;
                                               (00986) BM1001:    BITMSK:=9 ;
                                               (00987) BM1010:    BITMSK:=A ;
                                               (00988) BM1011:    BITMSK:=B ;
                                               (00989) BM1100:    BITMSK:=C ;
                                               (00990) BM1101:    BITMSK:=D ;
                                               (00991) BM1110:    BITMSK:=E ;
                                               (00992) BM1111:    BITMSK:=F ; (NOTE: THIS IS THE DEFAULT VALUE NO LONGER, NOW NOMASK)
                                               (00993) (
                                               (00994) (---------
                                               (00995) ("ENDDECODE", "STOPDECODE", ETC ARE SPECIAL CASES OF THE TYPE
                                               (00996) (DESCRIBED ABOVE.
                                               (00997) (
                                               (00998) ("ENDDECODE" IS EQUIVALENT TO:
                                               (00999) (   "LONG VECTOR JUMP TO ENDDECBASE PLUS LSHALF OF LZPCIRQ, WITH BITMASK 1111"
                                               (01000) (
                                               (01001) ENDDECODE:     SEQC:=1 CPOL:=1 AD:=@ENDDECBASE COND4:=0 MSEL:=C BITMSK:=F NFDEC:=1;
                                               (01002) ENDDECODEM:    SEQC:=1 CPOL:=1 AD:=@ENDDECMBASE COND4:=0 MSEL:=C BITMSK:=F NFDEC:=1;
                                               (01003) J.ENDDECODE:   SEQC:=1 CPOL:=1 AD:=@J.ENDDECBASE COND4:=0 MSEL:=C BITMSK:=F NFDEC:=1;
                                               (01004) J.ENDDECODEM:  SEQC:=1 CPOL:=1 AD:=@J.ENDDECMBASE COND4:=0 MSEL:=C BITMSK:=F NFDEC:=1;
                                               (01005) (ENDDECODEP:    SEQC:=1 CPOL:=1 AD:=30 COND4:=0 MSEL:=C BITMSK:=F;
                                               (01006) (CENDDEC:       SEQC:=1 CPOL:=1 AD:=00 COND4:=0 MSEL:=C BITMSK:=F;
                                               (01007) (CENDDECM:      SEQC:=1 CPOL:=1 AD:=10 COND4:=0 MSEL:=C BITMSK:=F;
                                               (01008) 'VECTOR JUMPS
                                               (01009) (
                                               (01010) (	  CONDITIONAL 256-WAY JUMPS
                                               (01011) (	  =========================
                                               (01012) (-------------------------------------------------------------------------------
                                               (01013) (
                                               (01014) (CONDITIONAL 256-WAY DECODE JUMPS (NO SHIFT OR MASK)
                                               (01015) (NOTE: CAN BE MADE UNCONDITIONAL BY ADDING "UNC" IN BEGINNING OF STATEMENT.
                                               (01016) (NOTE: MAPR CAN BE SPECIFIED (ADDRESS BITS 11..8). DEFAULT IS
                                               (01017) (MAPR=4 FOR SPDECODE, =2 FOR MEMDECODE.
                                               (01018) (
                                               (01019) (EXAMPLE 1 (EXECUTING A "JUMP TO CONTROL STORE" INSTRUCTION):
                                               (01020) ("UNC MEMDECODE WITH MAPR:=1"
                                               (01021) (A JUMP WILL BE MADE TO ADDRESS 1XX, WHERE XX IS THE
                                               (01022) (BYTE READ  FROM MEMORY.
                                               (01023) (
                                               (01024) (EXAMPLE 2 (CONDITIONALLY DECODING SP ORDER):
                                               (01025) ("SPDECODE WITH MAPR:=2 IF CARRY, ELSE GO TO STORED"
                                               (01026) (IF CARRY TRUE, JUMP TO 2XX, WHERE XX IS SP ORDER CODE.
                                               (01027) (IF CARRY FALSE, JUMP TO ADDRESS PREVIOUSLY STORED IN
                                               (01028) (COUNTER/REGISTER IN SEQUENCER.
                                               (01029) (
                                               (01030) (EXAMPLE 3 (CONDITIONALLY YDECODE ):
                                               (01031) ("YREGDECODE TABSIZE IF CARRY; "where TABSIZE(=E) is the value for MAPR"
                                               (01032) (IF CARRY TRUE, JUMP TO EXX, WHERE XX IS THE YBUS VALUE IN THE PREVIOUS
                                               (01033) (CYCLE. IF CARRY FALSE, Continue to next address.
                                               (01034) (
                                               (01035) YREGDECODE:   'SEQC:=E MAP:=4 MAPR:='  (SB98
                                               (01036) SPDECODE:  'SEQC:=E MAP:=F MAPR:='  (SB98
                                               (01037) MEMDECODE: 'SEQC:=E MAP:=E MAPR:='  (SB98
                                               (01038) IRDECODE:  'SEQC:=E MAP:=D MAPR:='  (SB98
                                               (01039) UYREGDECODE:  'SEQC:=1E MAP:=4 MAPR:='  (SB98
                                               (01040) USPDECODE: 'SEQC:=1E MAP:=F MAPR:='  (SB98
                                               (01041) UMEMDECODE:'SEQC:=1E MAP:=E MAPR:='  (SB98
                                               (01042) UIRDECODE: 'SEQC:=1E MAP:=D MAPR:='  (SB98
                                               (01043) 'CSTACK
                                               (01044) (
                                               (01045) (	  PUSH CSTACK AND LOAD COUNTER/REGISTER IN SEQUENCER
                                               (01046) (	  ==================================================
                                               (01047) (
                                               (01048) (-------------------------------------------------------------------------------
                                               (01049) (
                                               (01050) (Load counter/register without pushing cstack:
                                               (01051) (
                                               (01052) (Example 1:
                                               (01053) ("STORE LOOP COUNT 10 PLUS LSHALF OF Y WITH BITMASK 0111"
                                               (01054) ("STORE LOOP COUNT 10 UNCOND, & PUSH CSTACK"
                                               (01055) ("STORE LOOP COUNT 10"
                                               (01056) (
                                               (01057) (Example 2:
                                               (01058) ("LOAD REG WITH LABEL LYNX1"         (old " STORE LABEL "
                                               (01059) ("LLOAD REG WITH LABEL LYNX1"        (old " STORE LABEL "
                                               (01060) (
                                               (01061) ("LOAD CTR WITH LABEL LYNX1"         (old " STORE LABEL "
                                               (01062) ("LLOAD CTR WITH LABEL LYNX1"        (old " STORE LABEL "
                                               (01063) (
                                               (01064) ("LOAD REG WITH CONSTANT 12"
                                               (01065) ("LLOAD REG WITH CONSTANT 345"
                                               (01066) (
                                               (01067) ("LOAD CTR WITH CONSTANT 12"
                                               (01068) ("LLOAD CTR WITH CONSTANT 345"
                                               (01069) (
                                               (01070) (
                                               (01071) (Example 3:
                                               (01072) ("LOAD CTR FROM YREG"
                                               (01073) ("LLOAD CTR FROM YREG, MAPR:=2"
                                               (01074) (Restriction: "IF.." cannot be used.
                                               (01075) (
                                               (01076) ("2" can be replaced by any unsigned hex number less than 10,
                                               (01077) ("345" can be replaced by any unsigned hex number less than 1000,
                                               (01078) ("12" can be replaced by any unsigned hex number less than 100,
                                               (01079) (but when a shifted/masked data source is added like in this example,
                                               (01080) (the number must be a multiple of hex 10.
                                               (01081) ("LSHALF" can be replaced by "MSHALF".
                                               (01082) ("Y" can be replaced by "IR", "MEM", "SP", or "LZPCIRQ",
                                               (01083) ("0111" can be replaced by any combination of four bits.
                                               (01084) ("LABEL2" can be any name biven to an address value, which will
                                               (01085) (here be loaded into the counter/register. "PLUS LS/MSHALF OF .." can
                                               (01086) (be used here too, if it is a multiple of hex 10.
                                               (01087) (Since the microprogram memory has been increased, and the blockselect is
                                               (01088) (is moved up to address bit 12 and 13, and the counter/register is only 12 bit
                                               (01089) (wide SELECT BLOCK has no affect on the loaded value any more.
                                               (01090) (
                                               (01091) (---------
                                               (01092) (PUSH CSTACK AND CONDITIONALLY LOAD COUNTER/REGISTER:
                                               (01093) (
                                               (01094) (To examples 1, 2, and 3 above can be added "& PUSH CSTACK", in which
                                               (01095) (case the address to the next microinstruction will be pushed onto
                                               (01096) (the cstack. Note that when doing this, a condition can be specified
                                               (01097) (for loading the counter/register, and (because of this) shifting
                                               (01098) (and masking must not be specified.
                                               (01099) (Restriction 1 is still valid.
                                               (01100) (
                                               (01101) (Example:
                                               (01102) ("STORE LOOP COUNT 1A IF CARRY, & PUSH CSTACK"
                                               (01103) (
                                               (01104) (Label can be used instead of constant, (see example 2 above)
                                               (01105) ("1A" can be replaced by any unsigned hex number, less than 800.
                                               (01106) (Note: STORE LOOP COUNT/LABEL is unconditional (i.e. "IF.." cannot
                                               (01107) (be used) if "& PUSH CSTACK" is left out.
                                               (01108) (
                                               (01109) STORE:      'STORE'
                                               (01110) STORELOOP:  'STL'
                                               (01111) STLCOUNT:   'SEQC:=1C AD:='
                                               (01112) LDLCTRA:    SEQC:=1C;
                                               (01113) (** STORELABEL: 'SEQC:=1C CPOL:=0 DATA0:=@'
                                               (01114) LOADREG:    'LREG'
                                               (01115) LREGWITH:   'LW'
                                               (01116) LWCONSTANT: 'LDLCTRA CPOL:=0 DATA0:='
                                               (01117) LWLABEL:    'LDLCTRA CPOL:=0 DATA0:=@'
                                               (01118) LLOAD:      'LLD'
                                               (01119) LLDREG:     'LLREG'
                                               (01120) LLREGWITH:  'WW'
                                               (01121) WWCONSTANT: 'SEQC:=1C CPOL:=1 AD:='
                                               (01122) WWLABEL:    'SEQC:=1C CPOL:=1 AD:=@'
                                               (01123) LOADCTR:    'LDCT'
                                               (01124) LLDCTR:     'LLDCT'
                                               (01125) LDCTWITH:   'CW'
                                               (01126) CWCONSTANT: 'LDLCTRA CPOL:=0 DATA0:='
                                               (01127) CWLABEL:    'LDLCTRA CPOL:=0 DATA0:=@'
                                               (01128) LLDCTWITH:  'CH'
                                               (01129) CHCONSTANT: 'SEQC:=1C CPOL:=1 AD:='
                                               (01130) CHLABEL:    'SEQC:=1C CPOL:=1 AD:=@'
                                               (01131) LDCTFROM:   'LDCTF' (LOAD CTR FROM YREG/SP/MEM/IR
                                               (01132) LLDCTFROM:  'LLDCTF' (LLOAD CTR FROM YREG/SP/MEM/IR
                                               (01133) LDCTFYREG:  LDLCTRI CPOL:=0 MAP:=4;
                                               (01134) LLDCTFYREG: LDLCTRI CPOL:=1 MAP:=4;  (bit 8-11 loaded from MAPR
                                               (01135) LDCTFSP:    LDLCTRI CPOL:=0 MAP:=F;
                                               (01136) LLDCTFSP:   LDLCTRI CPOL:=1 MAP:=F;  (bit 8-11 loaded from MAPR
                                               (01137) LDCTFMEM:   LDLCTRI CPOL:=0 MAP:=E;
                                               (01138) LLDCTFMEM:  LDLCTRI CPOL:=1 MAP:=E;  (bit 8-11 loaded from MAPR
                                               (01139) LDCTFIR:    LDLCTRI CPOL:=0 MAP:=D;
                                               (01140) LLDCTFIR:   LDLCTRI CPOL:=1 MAP:=D;  (bit 8-11 loaded from MAPR
                                               (01141) LDLCTRI:    SEQC:=B;
                                               (01142) &:        '&'
                                               (01143) &PUSH:    '&PUS'
                                               (01144) &PUSCSTACK:SEQC:=C DBLASS;(DBLE ASSIGNMENT WILL BE REG'D BY PASS 3)
                                               (01145) (
                                               (01146) 'SUBROUTINES
                                               (01147) (
                                               (01148) (	  SUBROUTINE CALL AND RETURN
                                               (01149) (	  ==========================
                                               (01150) (
                                               (01151) (-------------------------------------------------------------------------------
                                               (01152) (SUBROUTINE CALLS CAN BE NESTED IN 9 LEVELS.
                                               (01153) 
                                               (01154) UDO:      'SEQC:=16 DATA0:=@'
                                               (01155) 
                                               (01156) DO:       'SEQC:=6 DATA0:=@'
                                               (01157) 
                                               (01158) ULDO:     'SEQC:=17 AD:=@'
                                               (01159) 
                                               (01160) LDO:      'SEQC:=7 AD:=@'
                                               (01161) (---------
                                               (01162) ("ELSE DO STORED" AND "PLUS 1"
                                               (01163) (NOTE: THESE TWO ARE MUTUALLY EXCLUSIVE.
                                               (01164) (LDOPLUS1 LABEL, IF CARRY; (jmp to LABEL+1 if carry, else to LABEL)
                                               (01165) (
                                               (01166) ELSEDO:     'ELDO'
                                               (01167) ELDOSTORED: SEQC:=A DBLASS;	       (DOUBLE ASSIGNMENT WILL BE REGISTERED)
                                               (01168) LDOPLUS1:   'LDPL1 AD:=@'
                                               (01169) LDPL1:	    SEQC:=1F;
                                               (01170) 
                                               (01171) RETURN:   SEQC:=3;
                                               (01172) URETURN:  SEQC:=13;
                                               (01173) &SKIP:    '&SKIP'
                                               (01174) &SKIP1:   SEQC:=1B DBLASS;	       (DOUBLE ASSIGNMENT WILL BE REGISTERED)
                                               (01175) &SKIPNEXT: SEQC:=1A DBLASS;    (LSI    (DOUBLE ASSIGNMENT WILL BE REGISTERED)
                                               (01176) 
                                               (01177) BREAK0:   SEQC:=0 CPOL:=1 COND4:=0 MAP:=8;	    (-> ADR   + MASKED REQBITS
                                               (01178) BREAK1:  'SEQC:=0 CPOL:=1 COND4:=1 MAP:=8 DATA0:=@' (-> ADR D + MASKED REQBITS
                                               (01179) (
                                               (01180) 'END OF LOOP
                                               (01181) (
                                               (01182) (	  TEST AT END OF LOOP
                                               (01183) (	  ===================
                                               (01184) (-------------------------------------------------------------------------------
                                               (01185) (ALT. 1:
                                               (01186) ("REPEAT FROM LABEL1 UNTIL CTR=0"  NOTE: CONDITION CANNOT BE USED.
                                               (01187) (
                                               (01188) ("REPPLUS1 FROM LABEL1, IF cond, UNTIL CTR=0" NOTE: This is a 2 * 2way jump i.e
                                               (01189) (						    also conditional PLUS1 when
                                               (01190) (Read it as this:				    CTR=0, (CONTINUE or CONT.+1)
                                               (01191) ("REPEAT FROM LABEL1 PLUS1 IF cond, UNTIL CTR=0 and SKIP1 IF cond"
                                               (01192) (
                                               (01193) (ALT. 2:
                                               (01194) ("PROCEED IF CARRY,          (AND POP)
                                               (01195) ( ELSE REPEAT CSTACK"
                                               (01196) (ALT. 3:
                                               (01197) ("REPEAT CSTACK UNTIL CTR=0" (AND POP)        NOTE: CONDITION CANNOT BE USED
                                               (01198) (
                                               (01199) (ALT. 4A:
                                               (01200) ("IF CARRY CONTINUE          (No POP or CTR decr.)
                                               (01201) ( ELSE IF CTR=0 GO TO LABEL1 (AND POP),
                                               (01202) ( ELSE REPEAT CSTACK"        (Decr. CTR
                                               (01203) (
                                               (01204) (ALT. 4B:
                                               (01205) ( DONT CONTINUE
                                               (01206) ( ELSE IF CTR=0 GO TO LABEL1 (AND POP),
                                               (01207) ( ELSE REPEAT CSTACK"        (Decr. CTR
                                               (01208) (
                                               (01209) (ALT. 5, ONLY FOR ONE-WORD "LOOPS":
                                               (01210) ("REPEAT UNTIL CARRY"
                                               (01211) ("REPEAT WHILE CARRY"
                                               (01212) ("REPEAT UNTIL CARRY, THEN GO TO STORED")
                                               (01213) (
                                               (01214) (ALT. 6: (SEQCTRL=F; New threeWayJump)
                                               (01215) (
                                               (01216) ( IF CTR=0 CONTINUE    (And POP)    (END
                                               (01217) ( ELSE GO TO LABEL IF cond,	    (cond
                                               (01218) ( ELSE REPEAT CSTACK;		    (Decr. CTR
                                               (01219) (
                                               (01220) (THE COUNTER IN THE SEQUENCER IS DECREMENTED BY 1 IN ALT. 1, 3, 4 and 6
                                               (01221) (ALT. 3  AND, IF THE CONDITION IS FALSE, ALSO ALT. 4 and 6 WILL JUMP
                                               (01222) (BACK TO THE ADDRESS STORED ON THE CSTACK, IF THE COUNTER IS NOT ZERO.
                                               (01223) (Alt.4 Has condition as highest priority, but ALT.6 has CTR=0 as highest.
                                               (01224) (ALT. 1 IS SIMILAR, EXCEPT THAT THE ADDRESS IS GIVEN IN THE
                                               (01225) (MICROINSTRUCTION.
                                               (01226) (ALT. 2 JUMPS ACCORDING TO THE CSTACK UNTIL THE SPECIFIED CONDITION
                                               (01227) (IS TRUE, REGARDLESS OF THE COUNTER.
                                               (01228) ("CARRY" CAN BE REPLACED BY OTHER CONDITIONS, BUT "CTR=0"
                                               (01229) (CANNOT BE REPLACED.
                                               (01230) (THE COMMENTS "(AND POP)" CAN BE LEFT OUT.
                                               (01231) 'END OF LOOP
                                               (01232) REPEAT:   'REP'
                                               (01233) REPFROM:  'SQCT1C DATA0:=@'
                                               (01234) SQCT1C:   SEQC:=10;
                                               (01235) (UNTIL IS DEFINED ELSEWHERE AS 'FN')
                                               (01236) UNTIL:     'FN'
                                               (01237) FNCTR=0:   ''
                                               (01238) REPPLUS1: 'RPP'                   (LSI
                                               (01239) RPPFROM:  'SQCT1D DATA0:=@'       (LSI
                                               (01240) SQCT1D:   SEQC:=18;		  (LSI
                                               (01241) PROCEED:   SEQC:=2;
                                               (01242) ELSEREPEAT:'ELRE'
                                               (01243) ELRECSTACK:''
                                               (01244) REPCSTACK: SEQC:=12;
                                               (01245) IFCTR=0:   'I0'
                                               (01246) I0CONTINUE:''
                                               (01247) ELSEIF:    'ELIF'
                                               (01248) ELIFCTR=0: 'EI0'
                                               (01249) EI0GO:     'EI0GO'
                                               (01250) EI0GOTO:   'SEQC:=D DATA0:=@'
                                               (01251) ELSEGO:   'ELSEGO'
                                               (01252) ELSEGOTO:  'SEQC:=F DATA0:=@'
                                               (01253) REPUNTIL:  'GT DATA0:=* FN'
                                               (01254) REPWHILE:  'GT DATA0:=* IF'
                                               (01255) WAIT:      'WT'
                                               (01256) WTFOR:     'WTF'
                                               (01257) WTFSPREQ:  'UGT DATA0:=* AUX1:=6'
                                               (01258) THEN:      'ELSE'
                                               (01259) DONT:     'DT'
                                               (01260) DTCONTINUE: CONDFALSE;
                                               (01261) CONTINUE:  ''
                                               (01262) 
                                               (01263) 'ALT. EXIT
                                               (01264) (
                                               (01265) (	  ALTERNATIVE EXIT FROM LOOP OR SUBROUTINE
                                               (01266) (	  ========================================
                                               (01267) (
                                               (01268) (-------------------------------------------------------------------------------
                                               (01269) (
                                               (01270) (EXAMPLE:
                                               (01271) ("POPJUMP LABEL1 IF CARRY"
                                               (01272) (
                                               (01273) (IF THE SPECIFIED CONDITION IS TRUE, THE JUMP WILL BE PERFORMED AND
                                               (01274) (THE CSTACK WILL BE POPPED.
                                               (01275) (USEFUL TOGETHER WITH LOOP ALTERNATIVES 2, 3, AND 4 ABOVE, AND
                                               (01276) (ALSO TO EXIT A SUBROUTINE IN SUCH CASES WHERE A NORMAL RETURN
                                               (01277) (IS NOT WANTED.
                                               (01278) (
                                               (01279) POPJUMP: 'SEQC:=9 DATA0:=@'
                                               (01280) (
                                               (01281) (
                                               (01282) 'CONDITION
                                               (01283) (
                                               (01284) (	  CONDITION CONTROL
                                               (01285) (	  =================
                                               (01286) (
                                               (01287) (-------------------------------------------------------------------------------
                                               (01288) (NOTE:
                                               (01289) (1)  WRITE "IF ZERO", "IF NOT ZERO" ETC.
                                               (01290) (2)  "UNCOND" IS DEFAULT (CAN BE LEFT OUT)
                                               (01291) (3)  SOME OF THE SEQUENCER FUNCTIONS ARE UNCONDITIONAL. THUS,
                                               (01292) (    "IF .." OR "IF NOT .." SHOULD NOT BE USED WITH:
                                               (01293) (      "PUSH CSTACK" (BUT CAN BE USED WITH "..& PUSH CSTACK")
                                               (01294) (      "REPEAT FROM .."
                                               (01295) (      "REPEAT CSTACK"
                                               (01296) (      "STORE LOOP COUNT..", "STORE LABEL..", AND "LOAD CTR FROM..",
                                               (01297) (         IF NOT USING "..& PUSH CSTACK"
                                               (01298) (
                                               (01299) (-------------------------------------------------------------------------------
                                               (01300) (
                                               (01301) IF:        'IF'
                                               (01302) IFNOT:     'FN'
                                               (01303) IFZERO:    COND:=00 CPOL:=0;	      (ZERO FLIPFLOP
                                               (01304) FNZERO:    COND:=00 CPOL:=1;
                                               (01305) IFCARRY:   COND:=01 CPOL:=0;	      (CARRY FLIPFLOP
                                               (01306) FNCARRY:   COND:=01 CPOL:=1;
                                               (01307) IFFH:	   COND:=02 CPOL:=0;	      (FAST HALFCARRY (FROM BIT 3)
                                               (01308) FNFH:	   COND:=02 CPOL:=1;
                                               (01309) IFNEG:	   COND:=03 CPOL:=0;	      (NEG FLIPFLOP, sign bit
                                               (01310) FNNEG:	   COND:=03 CPOL:=1;
                                               (01311) IFFZ:	   COND:=04 CPOL:=0;	      (FZ
                                               (01312) FNFZ:	   COND:=04 CPOL:=1;
                                               (01313) IFFC:	   COND:=05 CPOL:=0;	      (FC
                                               (01314) FNFC:	   COND:=05 CPOL:=1;
                                               (01315) IFFN:	   COND:=06 CPOL:=0;	      (FN
                                               (01316) FNFN:	   COND:=06 CPOL:=1;
                                               (01317) IFFV:	   COND:=07 CPOL:=0;	      (FV
                                               (01318) FNFV:	   COND:=07 CPOL:=1;
                                               (01319) IFOVERFLOW:COND:=08 CPOL:=0;	      (OVERFLOW FLIPFLOP
                                               (01320) FNOVERFLOW:COND:=08 CPOL:=1;
                                               (01321) IFLESS:	   COND:=09 CPOL:=0;	      (NEG ^ OVERFLOW
                                               (01322) FNLESS:	   COND:=09 CPOL:=1;
                                               (01323) IFPCCY:    COND:=0A CPOL:=0;	      (PROGRAM COUNTER CARRY
                                               (01324) FNPCCY:    COND:=0A CPOL:=1;
                                               (01325) IFLINK:    COND:=0B CPOL:=0;	      (LINK FLIPFLOP
                                               (01326) FNLINK:    COND:=0B CPOL:=1;
                                               (01327) IFYREGODD: COND:=0C CPOL:=0;	      (ODD PARITY (Previous Y!)
                                               (01328) IFYREGEVEN: COND:=0C CPOL:=1;	      (EVEN PARITY (Previous Y!)
                                               (01329) IFFL:	   COND:=0D CPOL:=0;	      (FN ^ FV
                                               (01330) FNFL:	   COND:=0D CPOL:=1;
                                               (01331) IFQLSB:    COND:=0E CPOL:=0;	      (Q-0 FROM SHIFT ,UTAN MELLAN LAGR
                                               (01332) FNQLSB:    COND:=0E CPOL:=1;
                                               (01333) CONDFALSE: COND:=0F CPOL:=0;          (USED BY DON'T CONTINUE
                                               (01334) UNCOND:    COND:=0F CPOL:=1;	      (UNCONDITIONALLY
                                               (01335) (
                                               (01336) ' CONDITION SELECT cont.
                                               (01337) (
                                               (01338) IFDSXFC:   COND:=10 CPOL:=0;	      (FC ^ (D bit 7 in previous cycle)
                                               (01339) FNDSXFC:   COND:=10 CPOL:=1;
                                               (01340) IFYREGBITSET: COND:=11 CPOL:=0;	      (Bit test on Y-bus (Previous Y!)
                                               (01341) FNYREGBITSET: COND:=11 CPOL:=1;
                                               (01342) IFPSCAFU:  COND:=12 CPOL:=0;	      (Pstack almost full (PSCTR = 00000xxx)
                                               (01343) FNPSCAFU:  COND:=12 CPOL:=1;
                                               (01344) IFPSCFULL: COND:=13 CPOL:=0;	      (Pstack Full (PSCTR = 00000000)
                                               (01345) FNPSCFULL: COND:=13 CPOL:=1;
                                               (01346) IFPSCAEM:  COND:=14 CPOL:=0;	      (Pstack Almost Empty (PSCTR = 11111xxx)
                                               (01347) FNPSCAEM:  COND:=14 CPOL:=1;
                                               (01348) IFPSCEM:   COND:=15 CPOL:=0;	      (Pstack Empty (PSCTR = 11111111)
                                               (01349) FNPSCEM:   COND:=15 CPOL:=1;
                                               (01350) IFCTREQ0:  COND:=16 CPOL:=0;	      (IF COUNTER IN SEQUENCER = 0
                                               (01351) FNCTREQ0:  COND:=16 CPOL:=1;
                                               (01352) IFGREATER: COND:=17 CPOL:=0;	      (!(NEG ^ OVERFLOW) & !ZERO
                                               (01353) FNGREATER: COND:=17 CPOL:=1;
                                               (01354) IFSPREQ:   COND:=18 CPOL:=1;	      (SP REQUEST: ORDER OR DATA TO CU
                                               (01355) FNSPREQ:   COND:=18 CPOL:=0;
                                               (01356) IFSPACK:   COND:=19 CPOL:=1;	      (SP ACKNOWLEDGE OF CALL FROM CU
                                               (01357) FNSPACK:   COND:=19 CPOL:=0;
                                               (01358) IFFG:	   COND:=1A CPOL:=0;	      (!(FN ^ FV) & !FZ
                                               (01359) FNFG:	   COND:=1A CPOL:=1;
                                               (01360) IFABOVE:   COND:=1B CPOL:=0;	      (CARRY & !ZERO
                                               (01361) FNABOVE:   COND:=1B CPOL:=1;
                                               (01362) IFSPECIAL: COND:=1C CPOL:=0;	      (SPECIAL CONDITION (FLIPFLOP)
                                               (01363) FNSPECIAL: COND:=1C CPOL:=1;
                                               (01364) IFYREGEQNEG:  COND:=1D CPOL:=0;	      (Ybus = NEG FlipFlop (Previous Y!)
                                               (01365) FNYREGEQNEG:  COND:=1D CPOL:=1;
                                               (01366) IFFA:	   COND:=1E CPOL:=0;          (FC & !FZ
                                               (01367) FNFA:	   COND:=1E CPOL:=1;
                                               (01368) IFADLCY:   COND:=1F CPOL:=0;          (ADL wrap indicator
                                               (01369) FNADLCY:   COND:=1F CPOL:=1;
                                               (01370) (
                                               (01371) 'GMEM SOURCE AND DESTINATION DEFINITIONS
                                               (01372) (
                                               (01373) (
                                               (01374) (	  GMEM SOURCE & DESTINATION
                                               (01375) (	  =========================
                                               (01376) (
                                               (01377) (
                                               (01378) (-------------------------------------------------------------------------------
                                               (01379) (Use these definitions to assign to the GAS fields separately
                                               (01380) (when the usual definitions (like DSOURCE MSTACK, WRITE SB) are
                                               (01381) (unsuitable.
                                               (01382) (
                                               (01383) GSOURCE:  'GS'
                                               (01384) GDEST:    'GD'
                                               (01385) (
                                               (01386) GSGR:        GASS:=0; (GENERAL REGISTER USING B,R AS POINTER
                                               (01387) GSSB:        GASS:=1; (STRING BUFFER, USING SBCTR AS POINTER
                                               (01388) GSMSTACK:    GASS:=2; (MSTACK, USING MSCTR AS POINTER
                                               (01389) GSPSTACK:    GASS:=3; (PSTACK, USING PSCTR AS POINTER
                                               (01390) (GSLSTACK:   GASS:=1; (LSTACK, assigned to STRING BUFFER COUNTER!!!
                                               (01391) GSLSTACK:    GASS:=3; (LSTACK, assigned to PSTACK COUNTER!!!
                                               (01392) GSRSTACK:    GASS:=2; (RSTACK, assigned to MSTACK COUNTER!!!
                                               (01393) (
                                               (01394) GDGR:        GASD:=0; (GENERAL REGISTER USING B,R AS POINTER
                                               (01395) GDSB:        GASD:=1; (STRING BUFFER, USING SBCTR AS POINTER
                                               (01396) GDMSTACK:    GASD:=2; (MSTACK, USING MSCTR AS POINTER
                                               (01397) GDPSTACK:    GASD:=3; (PSTACK, USING PSCTR AS POINTER
                                               (01398) (GDLSTACK:   GASD:=1; (LSTACK, assigned to STRING BUFFER COUNTER!!!
                                               (01399) GDLSTACK:    GASD:=3; (LSTACK, assigned to PSTACK COUNTER!!!
                                               (01400) GDRSTACK:    GASD:=2; (RSTACK, assigned to MSTACK COUNTER!!!
                                               (01401) (
                                               (01402) (
                                               (01403) 'D-BUS SOURCE DEFINITIONS
                                               (01404) (
                                               (01405) (
                                               (01406) (	  D-BUS SOURCE
                                               (01407) (	  ============
                                               (01408) (
                                               (01409) (
                                               (01410) (-------------------------------------------------------------------------------
                                               (01411) (
                                               (01412) DSOURCE:  'DS'
                                               (01413) (
                                               (01414) DSCONSTANT:  'MIFORM:=0 DATA1:='   (IMMEDIATE DATA COMBINED OF DS AND MBMOP.
                                               (01415) 				   (CAN JUMP SIMULTANEOUSLY WITHIN 4096 ADDR.
                                               (01416) DSLABEL:     'MIFORM:=0 DATA1:=@'  (Note! only short labels shuld be defined.
                                               (01417) (-------------------------------------------------------------------------------
                                               (01418) (
                                               (01419) (Y-BUS SOURCES, ALL USE THE PREVIOUS Y BUS VALUE
                                               (01420) (
                                               (01421) DSYREG:	     DS:=4;
                                               (01422) DSYREGSWAPPED:  DS:=3;		   (Y WITH BITS 7..4 AND 3..0 INTERCHANGED
                                               (01423) (				    Y: 76543210,  D: 32107654
                                               (01424) DSYREGFLIPPED:  DS:=B;		   (Y WITH BITS IN REVERSE ORDER
                                               (01425) (				    Y: 76543210,  D: 01234567
                                               (01426) (-------------------------------------------------------------------------------
                                               (01427) (
                                               (01428) (SOURCES FROM OUTSIDE CHIP
                                               (01429) (
                                               (01430) DSMEM:       DS:=8;		   (DATA FROM PRIMARY MEMORY
                                               (01431) DSINDATA:    DS:=9;		   (DATA FROM I/O UNITS
                                               (01432) DSSP:        DS:=D;		   (DATA FROM PC VIA SERIAL PORT
                                               (01433) (-------------------------------------------------------------------------------
                                               (01434) (
                                               (01435) (SOURCES FROM ENGINES AND DFM
                                               (01436) DSMAC_SING:	 DS4:=1, DS:=0;		( 0x10
                                               (01437) DSMAC_ALL:	 DS4:=1, DS:=1;		( 0x11
                                               (01438) DSID_NUM:    DS4:=1, DS:=2;     ( 0x12
                                               (01439) 
                                               (01440) (
                                               (01441) (SOURCES FROM GENERAL PORTS
                                               (01442) (NOTE: CAN NOT SIMULTANEOUSLY SPECIFY AN "A" OPERAND
                                               (01443) (
                                               (01444) DSCPORT:     'DSCPORT'
                                               (01445) DSDPORT:     'DSDPORT'
                                               (01446) DSPORT:      DS:=E;		   (Data from general port, source specified with AADDR
                                               (01447) DSCPORTA:    DSPORT A:=00;	   (Data from configuration reg of general port A
                                               (01448) DSCPORTB:    DSPORT A:=01;	   (Data from configuration reg of general port B
                                               (01449) DSCPORTC:    DSPORT A:=02;	   (Data from configuration reg of general port C
                                               (01450) DSCPORTD:    DSPORT A:=03;	   (Data from configuration reg of general port D
                                               (01451) DSCPORTE:    DSPORT A:=04;	   (Data from configuration reg of general port E
                                               (01452) DSCPORTF:    DSPORT A:=05;	   (Data from configuration reg of general port F
                                               (01453) DSCPORTG:    DSPORT A:=06;	   (Data from configuration reg of general port G
                                               (01454) DSCPORTH:    DSPORT A:=07;	   (Data from configuration reg of general port H
                                               (01455) DSCPORTI:    DSPORT A:=08;	   (Data from configuration reg of general port I
                                               (01456) DSCPORTJ:    DSPORT A:=09;	   (Data from configuration reg of general port J
                                               (01457) 
                                               (01458) DSDPORTA:    DSPORT A:=10;	   (Data from input of general port A
                                               (01459) DSDPORTB:    DSPORT A:=11;	   (Data from input of general port B
                                               (01460) DSDPORTC:    DSPORT A:=12;	   (Data from input of general port C
                                               (01461) DSDPORTD:    DSPORT A:=13;	   (Data from input of general port D
                                               (01462) DSDPORTE:    DSPORT A:=14;	   (Data from input of general port E
                                               (01463) DSDPORTF:    DSPORT A:=15;	   (Data from input of general port F
                                               (01464) DSDPORTG:    DSPORT A:=16;	   (Data from input of general port G
                                               (01465) DSDPORTH:    DSPORT A:=17;	   (Data from input of general port H
                                               (01466) DSDPORTI:    DSPORT A:=18;	   (Data from input of general port I
                                               (01467) DSDPORTJ:    DSPORT A:=19;	   (Data from input of general port J
                                               (01468) 
                                               (01469) DSCPORTK:    DSPORT A:=0A;	   (Data from configuration reg of general port K
                                               (01470) DSCPORTL:    DSPORT A:=0B;	   (Data from configuration reg of general port L
                                               (01471) DSCPORTM:    DSPORT A:=0C;	   (Data from configuration reg of general port M
                                               (01472) DSCPORTN:    DSPORT A:=0D;	   (Data from configuration reg of general port N
                                               (01473) DSCPORTO:    DSPORT A:=0E;	   (Data from configuration reg of general port O
                                               (01474) DSCPORTP:    DSPORT A:=0F;	   (Data from configuration reg of general port P
                                               (01475) DSDPORTK:    DSPORT A:=1A;	   (Data from input of general port K
                                               (01476) DSDPORTL:    DSPORT A:=1B;	   (Data from input of general port L
                                               (01477) DSDPORTM:    DSPORT A:=1C;	   (Data from input of general port M
                                               (01478) DSDPORTN:    DSPORT A:=1D;	   (Data from input of general port N
                                               (01479) DSDPORTO:    DSPORT A:=1E;	   (Data from input of general port O
                                               (01480) DSDPORTP:    DSPORT A:=1F;	   (Data from input of general port P
                                               (01481) (-------------------------------------------------------------------------------
                                               (01482) 'GMEM POINTERS AND SOURCES
                                               (01483) (		GMEM
                                               (01484) (	       +-----+
                                               (01485) (  B,R	 --->  !     !
                                               (01486) (	       !-----!
                                               (01487) (  SBCTR --->  !     !
                                               (01488) (	       !-----!
                                               (01489) (  MSCTR --->  !     !
                                               (01490) (	       !-----!
                                               (01491) (  PSCTR --->  !     !
                                               (01492) (	       +-----+
                                               (01493) (
                                               (01494) (
                                               (01495) (GMEM COUNTERS
                                               (01496) (
                                               (01497) DSGCTR:      DS:=6;		(GASS has to be specified separately
                                               (01498) DSBR:        DS:=6 GASS:=0;	(BLOCK AND REGISTER COUNTERS
                                               (01499) DSSBCTR:     DS:=6 GASS:=1;	(STRING BUFFER COUNTER
                                               (01500) DSMSCTR:     DS:=6 GASS:=2;	(MSTACK COUNTER
                                               (01501) DSPSCTR:     DS:=6 GASS:=3;	(PSTACK COUNTER
                                               (01502) (DSLSCTR:    DS:=6 GASS:=1;	(LSTACK COUNTER, assigned to STRING BUFFER COUNTER!!!
                                               (01503) DSLSCTR:     DS:=6 GASS:=3;	(LSTACK COUNTER, assigned to PSTACK COUNTER!!!
                                               (01504) DSRSCTR:     DS:=6 GASS:=2;	(RSTACK COUNTER, assigned to MSTACK COUNTER!!!
                                               (01505) (-------------------------------------------------------------------------------
                                               (01506) (
                                               (01507) (
                                               (01508) (
                                               (01509) (GMEM
                                               (01510) (
                                               (01511) DSG:        DS:=C;         (GMEM (from Y), GASS specified separately
                                               (01512) DSGR:       DS:=C GASS:=0; (GENERAL REGISTER USING B,R AS POINTER
                                               (01513) DSSB:       DS:=C GASS:=1; (STRING BUFFER, USING SBCTR AS POINTER
                                               (01514) DSMSTACK:   DS:=C GASS:=2; (MSTACK, USING MSCTR AS POINTER
                                               (01515) DSPSTACK:   DS:=C GASS:=3; (PSTACK, USING PSCTR AS POINTER
                                               (01516) (DSLSTACK:  DS:=C GASS:=1; (LSTACK, USING RSCTR AS POINTER, assigned to STRING BUFFER!!!
                                               (01517) DSLSTACK:   DS:=C GASS:=3; (LSTACK, USING LSCTR AS POINTER, assigned to PSTACK
                                               (01518) DSRSTACK:   DS:=C GASS:=2; (RSTACK, USING LSCTR AS POINTER, assigned to MSTACK
                                               (01519) 
                                               (01520) (-------------------------------------------------------------------------------
                                               (01521) 'D-BUS SOURCE DEFINITIONS CONT.
                                               (01522) (OTHER DBUS SOURCES
                                               (01523) (                                  (Bit's:      7 6 5 4  3 2 1 0
                                               (01524) DSALLFLAGS:  DS:=1;		   (Flag:	X F V N  L Z P C
                                               (01525) (						  V
                                               (01526) DSMBM:	     DS:=5;		   (Data from Multiplier ,Barrel shifter
                                               (01527) DSCU:	     DS:=A;		   (Data from SEQUENCER L2910
                                               (01528) DSCRB0:      DS:=7 A:=0;
                                               (01529) DSCRB1:      DS:=7 A:=1;
                                               (01530) DSCRB2:      DS:=7 A:=2;
                                               (01531) DSCRB3:      DS:=7 A:=3;
                                               (01532) DSCRB4:      DS:=7 A:=4;
                                               (01533) DSCRB5:      DS:=7 A:=5;
                                               (01534) DSCRB6:      DS:=7 A:=6;
                                               (01535) DSCRB7:      DS:=7 A:=7;
                                               (01536) DSCRB8:      DS:=7 A:=8;
                                               (01537) DSCRB9:      DS:=7 A:=9;
                                               (01538) DSCRBA:      DS:=7 A:=A;
                                               (01539) DSCRBB:      DS:=7 A:=B;
                                               (01540) DSCRBC:      DS:=7 A:=C;
                                               (01541) DSCRBD:      DS:=7 A:=D;
                                               (01542) DSCRBE:      DS:=7 A:=E;
                                               (01543) DSCRBF:      DS:=7 A:=F;
                                               (01544) DSRTC:       DS:=7 A:=F;
                                               (01545) DSLATCH:     DS:=2;		   (LATCH LOADED FROM D-BUS, Y-BUS or GMEM
                                               (01546) DSDSIGN:     DS:=0;		   (All bits equal to D bus bit 7 in last cycle
                                               (01547) (-------------------------------------------------------------------------------
                                               (01548) (RETURNS PRIORITY ENCODING OF PREVIOUS Y BUS VALUE
                                               (01549) DSYREGPRIO:     DS:=F;    (Encode Ybus priority, D-bit:7..3=0, 2..0 = prio Not.
                                               (01550) 				( ..... Y-bus .........   D-bus  YEQNEG   NEG_FF
                                               (01551) 				( -hex----------bin----   -----  ------   ------
                                               (01552) 				( 00          0000 0000    07	  True	    0
                                               (01553) 				( 01          0000 0001    07	  False	    "
                                               (01554)                                 ( 02-03       0000 001X    06       "       "
                                               (01555)                                 ( 04-07       0000 01XX    05       "       "
                                               (01556)                                 ( 08-0F       0000 1XXX    04       "       "
                                               (01557)                                 ( 10-1F       0001 XXXX    03       "       "
                                               (01558)                                 ( 20-3F       001X XXXX    02       "       "
                                               (01559)                                 ( 40-7F       01XX XXXX    01       "       "
                                               (01560)                                 ( 80-FF       1XXX XXXX    00       "       "
                                               (01561) 				(-----------------------------------------------
                                               (01562) 				( FF          1111 1111    07	   True     1
                                               (01563) 				( FE          1111 1110    07	   False    "
                                               (01564)                                 ( FD-FC       1111 110X    06       "       "
                                               (01565)                                 ( FB-F8       1111 10XX    05       "       "
                                               (01566)                                 ( F7-F0       1111 0XXX    04       "       "
                                               (01567)                                 ( EF-E0       1110 XXXX    03       "       "
                                               (01568)                                 ( DF-C0       110X XXXX    02       "       "
                                               (01569)                                 ( BF-80       10XX XXXX    01       "       "
                                               (01570)                                 ( 7F-00       0XXX XXXX    00       "       "
                                               (01571) (-------------------------------------------------------------------------------
                                               (01572) 'D-BUS SOURCE DEFINITIONS CONT.
                                               (01573) (
                                               (01574) (Additional functions for SEQ. operations: 1, F, and 19.
                                               (01575) (
                                               (01576) (DEFAULT:    DS:=8;		   (Data From MEM
                                               (01577) (
                                               (01578) DSCSTACKL:   DSCU CPOL:=0 AUX2:=1 MAP:=0 ;(8 lsb of Stack in SEQUENCER
                                               (01579) DSCSTACKH:   DSCU CPOL:=0 AUX2:=1 MAP:=8 ;(6 msb of Stack + StackCTRZeroNOT:b7
                                               (01580) DSCTRL:      DSCU CPOL:=0 AUX2:=1 MAP:=4 ;(8 lsb of counter in SEQUENCER
                                               (01581) DSCTRH:      DSCU CPOL:=0 AUX2:=1 MAP:=C ;(4 msb of counter in SEQUENCER
                                               (01582) DSDATA0:    'DSCU CPOL:=0 AUX2:=0 DATA0:='  (DATA0, AD 0..7, old IMMDATA
                                               (01583) DSLZPCIRQ:   DSCU CPOL:=0 AUX2:=2 MAP:=C ;(FLG:LINK,ZERO,PCCY,CARRY,TRACE,IRQ(2:0)
                                               (01584) DSIR:	     DSCU CPOL:=0 AUX2:=2 MAP:=D ;(Instuction Register
                                               (01585) DSSPCMD:     DSCU CPOL:=0 AUX2:=2 MAP:=F ;(SP data to CU (WDCU)
                                               (01586) DSD:	     DSCU CPOL:=1;		  (
                                               (01587) (
                                               (01588) DSOP:	     DSD COND4:=1 DA0H:=0, MAP:=D BITMSK:=F;  (IR BIT 7654
                                               (01589) DSARG:	     DSD COND4:=0 DA0H:=0, MAP:=D BITMSK:=F;  (IR BIT 3210
                                               (01590) DSFLAGS:     DSD COND4:=1 DA0H:=0, MAP:=C BITMSK:=5;  (b2= ZERO, b0= CARRY
                                               (01591) DSIRQ:	     DSD COND4:=0 DA0H:=0, MAP:=C BITMSK:=7;  (CU IRPTREQ CODE
                                               (01592) DSIRA2:	     DSD COND4:=1 DA0H:=0, MAP:=8 BITMSK:=4;  (IRA2, returns PSCTR carry in bit 2.
                                               (01593) 						      (Carry will be affected by INCREMENT,
                                               (01594) 						      (DECREMENT, LOAD, PUSH and POP. It
                                               (01595) 						      (will be set when incrementing to 00,
                                               (01596) 						      (or when decremented to anything other
                                               (01597) 						      (than 00. Otherwise it will be cleared.
                                               (01598) DSISAMODE:   DSD COND4:=0 DA0H:=0, MAP:=C BITMSK:=8;  (Instruction decoding mode
                                               (01599) (						      (returns trace flag in bit 3!
                                               (01600) (
                                               (01601) (
                                               (01602) (
                                               (01603) (  Definition of Interrupt Priority Encoder in GPU:
                                               (01604) (
                                               (01605) (			INTERRUPT:  ENDDECODE:	  DSOURCE IRQ:
                                               (01606) (			----------  ----------	  ------------
                                               (01607) (   Highest Priority :	SPREQ	       1/9	       1
                                               (01608) (   ----------------	FWI	       2/A	       2
                                               (01609) (			CLKREQ	       3/B	       3
                                               (01610) (			DMA1 (HDA)     4/C	       4
                                               (01611) (			DMA0 spare     5/D	       5
                                               (01612) (   Lowest Priority :	PCCY	       6/E	       6
                                               (01613) (   ---------------
                                               (01614) (
                                               (01615) 'MULTIPLIER FUNCTIONS
                                               (01616) (
                                               (01617) (All the multiplier, shift and mask functions are DISABLED when doing
                                               (01618) (DSOURCE CONSTANT...XXXXXXXX
                                               (01619) (
                                               (01620) (
                                               (01621) (	  MASK FUNCTIONS
                                               (01622) (	  ==============
                                               (01623) (
                                               (01624) (None of these functions load ACK
                                               (01625) (
                                               (01626) LANDD0:     MBMOP:=0 ; (  LATCH "AND" DATA0
                                               (01627) ROTL1ANDD0: MBMOP:=1 ; (  (ROT (LATCH) 1 POS LEFT) "AND" DATA0 (* 2)
                                               (01628) ROTL2ANDD0: MBMOP:=2 ; (  (ROT (LATCH) 2 POS LEFT) "AND" DATA0 (* 4)
                                               (01629) ROTL3ANDD0: MBMOP:=3 ; (  (ROT (LATCH) 3 POS LEFT) "AND" DATA0 (* 8)
                                               (01630) ROTL4ANDD0: MBMOP:=4 ; (  (ROT (LATCH) 4 POS LEFT) "AND" DATA0 (* 16)
                                               (01631) ROTL5ANDD0: MBMOP:=5 ; (  (ROT (LATCH) 5 POS LEFT) "AND" DATA0 (* 32)
                                               (01632) ROTL6ANDD0: MBMOP:=6 ; (  (ROT (LATCH) 6 POS LEFT) "AND" DATA0 (* 64)
                                               (01633) ROTL7ANDD0: MBMOP:=7 ; (  (ROT (LATCH) 7 POS LEFT) "AND" DATA0 (* 128)
                                               (01634) YREGORD0:   MBMOP:=8 ; (  YREG "OR" DATA0 (PREVIOUS Y BUS VALUE)
                                               (01635) ROTLATCH:   MBMOP:=9 ; (  ROT LATCH	  (rot controlled by NREG
                                               (01636) MASKANDYREG: MBMOP:=A ; (  MASK "AND" YREG (mask controlled by NREG
                                               (01637) (			  (PREVIOUS Y BUS VALUE)
                                               (01638) (
                                               (01639) (
                                               (01640) (
                                               (01641) (	  SHIFT FUNCTIONS
                                               (01642) (	  ===============
                                               (01643) (
                                               (01644) (Both these functions load ARL (ACK(7:0))
                                               (01645) (Rotation count and mask are controlled by NREG
                                               (01646) (
                                               (01647) FIRSTSHIFT: MBMOP:=B ; (  MBM out: MASK "AND" ROT(LATCH)
                                               (01648) (                         (  To ARL : MASKn "AND" ROT(LATCH)
                                               (01649) (
                                               (01650) NEXTSHIFT:  MBMOP:=C ; (  MBM out: (MASK "AND" ROT(LATCH)) "OR" ARL
                                               (01651) (                         (  To ARL : MASKn "AND" ROT(LATCH)
                                               (01652) (
                                               (01653) ( "FIRSTSHIFT" (MBMOP=B) is used as first step in a multibyte shift
                                               (01654) ( "NEXTSHIFT"  (MBMOP=C) is used in following steps.
                                               (01655) (
                                               (01656) (
                                               (01657) (
                                               (01658) (	  MULTIPLICATION FUNCTIONS
                                               (01659) (	  ========================
                                               (01660) (
                                               (01661) (All these functions load ACK
                                               (01662) (
                                               (01663) MUL1:	    MBMOP:=E ; (  MBM out: Zero
                                               (01664) (			  (  To ACK : MUL(LATCH*Y)
                                               (01665) (
                                               (01666) MUL2:	    MBMOP:=D ; (  MBM out: ARL
                                               (01667) (			  (  To ACK : ACK/256 + MUL(LATCH*Y)
                                               (01668) (
                                               (01669) MUL3:	    MBMOP:=F ; (  MBM out: Zero
                                               (01670) (			  (  To ACK : ACK + MUL(LATCH*Y)
                                               (01671) (
                                               (01672) UNSIGNED:   MAPR:=0;	(Both factors unsigned
                                               (01673) LSIGNED:    MAPR:=4;    (LATCH signed
                                               (01674) YSIGNED:    MAPR:=8;    (Y signed
                                               (01675) SIGNED:	    MAPR:=C;    (Both factors signed
                                               (01676) (
                                               (01677) 'Multiplication example
                                               (01678) (
                                               (01679) (Ex: Mult. of two 4-byte numbers, a3a2a1a0 * b3b2b1b0 = c7c6c5c4c3c2c1c0.
                                               (01680) (
                                               (01681) (	ALU op. 	MBM op.   Prod. out	ACK
                                               (01682) (	------- 	-------   ---------	---
                                               (01683) (	a0 -> LATCH	-			-
                                               (01684) (	b0 -> Y 	MUL1			a0b0
                                               (01685) (	b1 -> Y 	MUL2	  c0		a0b1
                                               (01686) (       a1 -> LATCH     -                        "
                                               (01687) (	b0 -> Y 	MUL3			a0b1 + a1b0
                                               (01688) (	b1 -> Y 	MUL2	  c1		a1b1
                                               (01689) (       a0 -> LATCH     -                        "
                                               (01690) (	b2 -> Y 	MUL3			a1b1 + a0b2
                                               (01691) (       a2 -> LATCH     -                        "
                                               (01692) (	b0 -> Y 	MUL3			a1b1 + a0b2 + a2b0
                                               (01693) (	b1 -> Y 	MUL2	  c2		a2b1
                                               (01694) (       a0 -> LATCH     -                        "
                                               (01695) (	b3 -> Y 	MUL3			a2b1 + a0b3
                                               (01696) (       a1 -> LATCH     -                        "
                                               (01697) (	b2 -> Y 	MUL3			a2b1 + a0b3 + a1b2
                                               (01698) (       a3 -> LATCH     -                        "
                                               (01699) (	b0 -> Y 	MUL3			a2b1 + a0b3 + a1b2 + a3b0
                                               (01700) (	b1 -> Y 	MUL2	  c3		a3b1
                                               (01701) (       a1 -> LATCH     -                        "
                                               (01702) (	b3 -> Y 	MUL3			a3b1 + a1b3
                                               (01703) (       a2 -> LATCH     -                        "
                                               (01704) (	b2 -> Y 	MUL3			a3b1 + a1b3 + a2b2
                                               (01705) (	b3 -> Y 	MUL2	  c4		a2b3
                                               (01706) (       a3 -> LATCH     -                        "
                                               (01707) (	b2 -> Y 	MUL3			a2b3 + a3b2
                                               (01708) (	b3 -> Y 	MUL2	  c5		a3b3
                                               (01709) (	0  -> Y 	MUL2	  c6
                                               (01710) (			MUL2	  c7
                                               (01711) (
                                               (01712) (
                                               (01713) 'Multiplication example
                                               (01714) (
                                               (01715) (This is the order in which the above multiplication is carried out:
                                               (01716) (
                                               (01717) (		      a3  a2  a1  a0
                                               (01718) (     * 	      b3  b2  b1  b0
                                               (01719) (     ------------------------------
                                               (01720) (				a0b0
                                               (01721) (			    a0b1
                                               (01722) (			    a1b0
                                               (01723) (			a1b1
                                               (01724) (			a0b2
                                               (01725) (			a2b0
                                               (01726) (		    a2b1
                                               (01727) (		    a0b3
                                               (01728) (		    a1b2
                                               (01729) (		    a3b0
                                               (01730) (		a3b1
                                               (01731) (		a1b3
                                               (01732) (		a2b2
                                               (01733) (	    a2b3
                                               (01734) (	    a3b2
                                               (01735) (     + a3b3
                                               (01736) (     ------------------------------
                                               (01737) (     c7  c6  c5  c4  c3  c2  c1  c0
                                               (01738) (
                                               (01739) (
                                               (01740) 'Truth Table for MASK
                                               (01741) (
                                               (01742) (
                                               (01743) (  NREG:    MASK 7..0:			 FUNCTION
                                               (01744) (  -----    ----------			---------
                                               (01745) (  0000     11111111	 No shift	   * 1
                                               (01746) (  0001     11111110	 Left shift	   * 2
                                               (01747) (  0010     11111100          "            * 4
                                               (01748) (  0011     11111000          "            * 8
                                               (01749) (  0100     11110000          "            * 16
                                               (01750) (  0101     11100000          "            * 32
                                               (01751) (  0110     11000000          "            * 64
                                               (01752) (  0111     10000000          "            * 128
                                               (01753) (  1000     00000000	 Right shift	   / 256
                                               (01754) (  1001     00000001          "            / 128
                                               (01755) (  1010     00000011          "            / 64
                                               (01756) (  1011     00000111          "            / 32
                                               (01757) (  1100     00001111          "            / 16
                                               (01758) (  1101     00011111          "            / 8
                                               (01759) (  1110     00111111          "            / 4
                                               (01760) (  1111     01111111          "            / 2
                                               (01761) (
                                               (01762) (
                                               (01763) ( NOTE!!!   NREG is LOADED from Y-bus.........
                                               (01764) (
                                               (01765) (
                                               (01766) 'D and Y bus bit test
                                               (01767) ( D and Y bus bit test		   define by condition select if Y or D.
                                               (01768) ( ====================
                                               (01769) (
                                               (01770) TESTBIT:    'TESTBIT'
                                               (01771) TESTBIT0:   MBMOP:=0 ;	   (Bit 0 in both Y and D busses are selected
                                               (01772) TESTBIT1:   MBMOP:=1 ;          (Bit 1            ""
                                               (01773) TESTBIT2:   MBMOP:=2 ;          (Bit 2            ""
                                               (01774) TESTBIT3:   MBMOP:=3 ;          (Bit 3            ""
                                               (01775) TESTBIT4:   MBMOP:=4 ;          (Bit 4            ""
                                               (01776) TESTBIT5:   MBMOP:=5 ;          (Bit 5            ""
                                               (01777) TESTBIT6:   MBMOP:=6 ;          (Bit 6            ""
                                               (01778) TESTBIT7:   MBMOP:=7 ;          (Bit 7            ""
                                               (01779) TESTBITLABEL: 'MBMOP:=@'	   (!!! Label must be in the range 0-7 !!!
                                               (01780) (
                                               (01781) 'ALU-FUNCTIONS
                                               (01782) (
                                               (01783) (
                                               (01784) (	   ALU FUNCTION CONTROL
                                               (01785) (	  =====================
                                               (01786) (
                                               (01787) (-------------------------------------------------------------------------------
                                               (01788) (
                                               (01789) (  ALU FUNCTION WITHOUT SOURCE OPERANDS:  ZERO, MINUS1
                                               (01790) (
                                               (01791) ZERO:	  ALUF:=4 ALUS:=5 CIN:=0;	    (Y = 00, CARRYOUT = 0
                                               (01792) (SIMZERO:  A:=0, B:=0, BA, ALUF:=6, CIN:=0;  (Y = 00, CARRYOUT = 0, FOR SIMULATION
                                               (01793) MINUS1:   A:=0, B:=0, BA, ALUF:=1, CIN:=0;  (Y = FF, CARRYOUT = 0
                                               (01794)                                             (NOTE: SEE ALSO "FF TO .."
                                               (01795) (
                                               (01796) (---------
                                               (01797) ( ALU FUNCTIONS WITH ONE OPERAND: PASS, TEST, INVERT, NEG, INCR, DECR,
                                               (01798) (								 ADDCARRY
                                               (01799) (
                                               (01800) ( N O T E !!
                                               (01801) ( FUNCTIONS MARKED '(**' ARE COMMENTED OUT TO SAVE SPACE AT ASSEMBLY
                                               (01802) ( TIME, IF NEEDED THROW AWAY COMMENT DELIMITER AND HOPEFULLY IF
                                               (01803) ( THERE IS SPACE, YOU MAY USE IT.
                                               (01804) (
                                               (01805) (
                                               (01806) YTEST:	  'YTEST'		  (Write 'YTEST & PASS' or 'Y&PASS'!
                                               (01807) YTEST&:	  'Y&'
                                               (01808) Y&PASS:	  ALUF:=3;		  (Pass operand unchanged, Z,N,P flags taken
                                               (01809) (                                 (from the Y bus, C,V zero, H undefined. This
                                               (01810) (				  (is true for both fast flags and loaded flags.
                                               (01811) (
                                               (01812) PASS:	  ALUF:=6;	  	  (Pass operand unchanged, Z,N,P flags taken
                                               (01813) (                                 (from passed value, C,V,H flags undefined. This
                                               (01814) (				  (is true for both fast flags and loaded flags.
                                               (01815) (
                                               (01816) TEST:	  ALUF:=0, CIN:=0;	  (Pass operand unchanged, Z,N,P flags taken
                                               (01817) (                                 (from passed value, C,V,H flags zero. This
                                               (01818) (				  (is true for both fast flags and loaded flags.
                                               (01819) (
                                               (01820) INVERT:   ALUF:=7;                (ONE'S COMPLEMENT
                                               (01821) INCR:	  ALUF:=0  CIN:=1;	    (ADD ONE
                                               (01822) ADDREGCARRY:  ALUF:=0,	CIN:=3;  (ADD REGISTERED CARRY IN
                                               (01823) ADDFCARRY: ALUF:=0, CIN:=3;			 (ADD FAST CARRY IN
                                               (01824) 
                                               (01825) NEG:      'NEG'                   (TWO'S COMPLEMENT
                                               (01826) NEGQ:	  ALUF:=2 CIN:=1 ALUS:=5; (-Q
                                               (01827) NEGB:	  ALUF:=2 CIN:=1 ALUS:=4; (-B
                                               (01828) NEGA:	  ALUF:=2 CIN:=1 ALUS:=3; (-A
                                               (01829) NEGD:	  ALUF:=1 CIN:=1 ALUS:=0; (-D
                                               (01830) (
                                               (01831) NEGBORROW:'NEGBW'                 (NEG WITH CIN SPECIFIED SEPARATELY
                                               (01832) (
                                               (01833) NEGBWA: ALUF:=2 ALUS:=3;	  (-A-1+CARRYIN
                                               (01834) NEGBWB: ALUF:=2 ALUS:=4;	  (-B-1+CARRYIN
                                               (01835) NEGBWD: ALUF:=1 ALUS:=0;	  (-D-1+CARRYIN
                                               (01836) (
                                               (01837) DECR:     'DECR'                  (SUBTRACT ONE
                                               (01838) DECRQ:	  ALUF:=1 CIN:=0 ALUS:=5; (Q-1
                                               (01839) DECRB:	  ALUF:=1 CIN:=0 ALUS:=4; (B-1
                                               (01840) DECRA:	  ALUF:=1 CIN:=0 ALUS:=3; (A-1
                                               (01841) DECRD:	  ALUF:=2 CIN:=0 ALUS:=0; (D-1
                                               (01842) 
                                               (01843) (
                                               (01844) (-------------------------------------------------------------------------------
                                               (01845) (LOGIC ALU FUNCTIONS WITH TWO OPERANDS:  AND, 1ANDNOT2, OR, XOR, XNOR
                                               (01846) (
                                               (01847) AND:	ALUF:=4;
                                               (01848) OR:	  ALUF:=3;
                                               (01849) XOR:	ALUF:=6;	(EXCLUSIVE OR
                                               (01850) XNOR: ALUF:=7;      (    "      " , INVERTED
                                               (01851) (
                                               (01852) 1ANDNOT2: '1N2'		(1st operand and not 2nd operand
                                               (01853) 1N2QA:	  ALUF:=5 QA;	(Q and not A
                                               (01854) 1N2BA:	  ALUF:=5 BA;	(B and not A
                                               (01855) 1N2AD:	  ALUF:=5 AD;	(A and not D
                                               (01856) 1N2QD:	  ALUF:=5 QD;	(Q and not D
                                               (01857) (
                                               (01858) (-------------------------------------------------------------------------------
                                               (01859) (ARITHMETIC ALU FUNCTIONS WITH TWO OPERANDS:
                                               (01860) (
                                               (01861) ADD:	  ALUF:=0  CIN:=0;	    (ADD WITH CIN = 0
                                               (01862) SUB:      'SUB'                     (SUB WITH CIN = 1
                                               (01863) SUBBORROW:'SUBBW'                   (SUB WITH CIN SPECIFIED SEPARATELY
                                               (01864) SUBQA:	  1MINUS2 QA;		      (Q-A
                                               (01865) SUBAQ:	  2MINUS1 QA;		      (A-Q
                                               (01866) SUBBA:	  1MINUS2 BA;		      (B-A
                                               (01867) SUBAB:	  2MINUS1 BA;		      (A-B
                                               (01868) SUBAD:	  1MINUS2 AD;		      (A-D
                                               (01869) SUBDA:	  2MINUS1 AD;		      (D-A
                                               (01870) SUBQD:	  1MINUS2 QD;		      (Q-D
                                               (01871) SUBDQ:	  2MINUS1 QD;		      (D-Q
                                               (01872) 1MINUS2:  ALUF:=1 CIN:=1;	    (USED ABOVE
                                               (01873) 2MINUS1:  ALUF:=2 CIN:=1;           (  "   "
                                               (01874) (
                                               (01875) SUBBWQA:    ALUF:=1 QA; 		(Q-A-1+CARRYIN
                                               (01876) SUBBWAQ:    ALUF:=2 QA; 		(A-Q-1+CARRYIN
                                               (01877) SUBBWBA:    ALUF:=1 BA; 		(B-A-1+CARRYIN
                                               (01878) SUBBWAB:    ALUF:=2 BA; 		(A-B-1+CARRYIN
                                               (01879) SUBBWAD:    ALUF:=1 AD; 		(A-D-1+CARRYIN
                                               (01880) SUBBWDA:    ALUF:=2 AD; 		(D-A-1+CARRYIN
                                               (01881) SUBBWQD:    ALUF:=1 QD; 		(Q-D-1+CARRYIN
                                               (01882) SUBBWDQ:    ALUF:=2 QD; 		(D-Q-1+CARRYIN
                                               (01883) SUBBWQ:     ALUF:=1 Q;			(Q-1+CARRYIN
                                               (01884) SUBBWB:     ALUF:=1 B;			(B-1+CARRYIN
                                               (01885) SUBBWA:     ALUF:=1 A;			(A-1+CARRYIN
                                               (01886) SUBBWD:     ALUF:=2 D;			(D-1+CARRYIN
                                               (01887) 
                                               (01888) 'ALU-OPERANDS
                                               (01889) (
                                               (01890) (	  ALU SOURCE OPERAND CONTROL
                                               (01891) (	  ==========================
                                               (01892) (
                                               (01893) (-------------------------------------------------------------------------------
                                               (01894) (OPERANDS FOR THE SINGLE OPERAND FUNCTIONS:
                                               (01895) (
                                               (01896) Q:	  ALUS:=5;
                                               (01897) B:	  ALUS:=4;
                                               (01898) A:	  ALUS:=3;
                                               (01899) D:	  ALUS:=0;
                                               (01900) (
                                               (01901) (OPERANDS FOR THE TWO-OPERAND FUNCTIONS:
                                               (01902) (
                                               (01903) QA:	  ALUS := 7;
                                               (01904) AQ:	  ALUS := 7;
                                               (01905) BA:	  ALUS := 6;
                                               (01906) AB:	  ALUS := 6;
                                               (01907) AD:	  ALUS := 2;
                                               (01908) DA:	  ALUS := 2;
                                               (01909) QD:	  ALUS := 1;
                                               (01910) DQ:	  ALUS := 1;
                                               (01911) (
                                               (01912) (A AND B SOURCES
                                               (01913) (
                                               (01914) ASOURCE:   'A:=@'
                                               (01915) BSOURCE:   'B:=@'
                                               (01916) 'CARRY
                                               (01917) (
                                               (01918) (	  CARRY INPUT SELECTOR
                                               (01919) (	  ====================
                                               (01920) (
                                               (01921) (-------------------------------------------------------------------------------
                                               (01922) (NOTE: CARRY-IN IS ALREADY SPECIFIED IN THE DEFINITIONS OF THE
                                               (01923) (NORMAL ADD AND SUB FUNCTIONS ABOVE
                                               (01924) (
                                               (01925) CARRYIN:    'CARRYIN'
                                               (01926) CARRYIN=:   'CYIN='
                                               (01927) CYIN=0:     CIN:=0;	   (CARRYIN = 0
                                               (01928) CYIN=1:     CIN:=1;	   (CARRYIN = 1
                                               (01929) CYIN=C:     CIN:=2;	   (CARRYIN = C
                                               (01930) CYIN=FC:    CIN:=3;	   (CARRYIN = FC
                                               (01931) CYIN=PCCY:  CIN:=0;	   (CARRYIN = PCCY NOTE! CAN ONLY BE USED TOGETHER
                                               (01932) (                          (               WITH: "ADDCARRY" and "BADDR=E(PCH)"
                                               (01933) 'DESTINATION
                                               (01934) (
                                               (01935) (	  ALU INTERNAL DESTINATION CONTROL
                                               (01936) (	  ================================
                                               (01937) (
                                               (01938) (-------------------------------------------------------------------------------
                                               (01939) (
                                               (01940) BDEST:    'B:=@'     (NOTE: NOT NEEDED WHEN BSOURCE SPECIFIED)
                                               (01941) TO:       RAM BDEST;
                                               (01942) RESULT:   'RESULT'
                                               (01943) RESULTTO: RAM BDEST;
                                               (01944) (			      TO Y    TO RAM(B)   TO Q
                                               (01945) QREG:	   ALUD := 1;	      (	F	   -	    F
                                               (01946) RAM:	   ALUD := 3;	      (	F	   F	    -
                                               (01947) RAMATOY:   ALUD := 2;	    (  RAM(A)	   F	    -
                                               (01948) RAMRIGHT:  ALUD := 5;	    (	F	  F/2	    -
                                               (01949) RAMQRIGHT: ALUD := 4;	    (	F	  F/2	    Q/2
                                               (01950) RAMLEFT:   ALUD := 7;	    (	F	  2F	    -
                                               (01951) RAMQLEFT:  ALUD := 6;	    (	F	  2F	    2Q
                                               (01952) 'SHIFTS
                                               (01953) (
                                               (01954) (	  SHIFT INPUT SELECTORS
                                               (01955) (	  =====================
                                               (01956) (
                                               (01957) (-------------------------------------------------------------------------------
                                               (01958) (EXAMPLES: "RAMLEFT WITH SERIAL INPUT = 0"
                                               (01959) (          "RAMQRIGHT, ARITHMETIC"
                                               (01960) (-------------------------------------------------------------------------------
                                               (01961) ( MNEMONIC	       FUNCTION WHEN RIGHTSHIFT    FUNCTION WHEN LEFTSHIFT
                                               (01962) ( --------	       ------------------------    -----------------------
                                               (01963) (			   ,---,       ,---,	     ,---,	 ,---,
                                               (01964) ( SERIAL INPUT = 0	0->! R !    0->! Q !	     ! R !<-0	 ! Q !<-0
                                               (01965) (                          '---'       '---'         '---'       '---'
                                               (01966) (			   ,---,       ,---,	     ,---,	 ,---,
                                               (01967) ( SERIAL INPUT = LINK	L->! R !------>! Q !	   .-! R !<-L	 ! Q !<-.
                                               (01968) (                          '---'       '---'       ! '---'       '---'  !
                                               (01969) (                                                  '--------------------'
                                               (01970) (			   ,---,       ,---,	     ,---,	 ,---,
                                               (01971) ( SERIAL INPUT = C	C->! R !------>! Q !	   .-! R !<-C	 ! Q !<-.
                                               (01972) (                          '---'       '---'       ! '---'       '---'  !
                                               (01973) (                                                  '--------------------'
                                               (01974) (			   ,---,       ,---,	     ,---,	 ,---,
                                               (01975) ( ROTDOUBLE		.->! R !------>! Q !-.	   .-! R !<------! Q !<-.
                                               (01976) (                       !  '---'       '---' !     ! '---'       '---'  !
                                               (01977) (                       '--------------------'     '--------------------'
                                               (01978) (			   ,---,       ,---,	     ,---,	 ,---,
                                               (01979) ( ROTATE		.->! R !-.  .->! Q !-.	   .-! R !<-.  .-! Q !<-.
                                               (01980) (                       !  '---' !  !  '---' !     ! '---'  !  ! '---'  !
                                               (01981) (                       '--------'  '--------'     '--------'  '--------'
                                               (01982) ( ARITHMETIC		   ,---,       ,---,	     .---.	 .---.
                                               (01983) (  OR			.->! R !------>! Q !	     ! R !<------! Q !<-0
                                               (01984) ( ARIDOUBLE             '--'---'       '---'         '---'       '---'
                                               (01985) (			   ,---,       ,---,	     ,---,	 ,---,
                                               (01986) ( SERIAL INPUT = 1	1->! R !    1->! Q !	     ! R !<-1	 ! Q !<-1
                                               (01987) (                          '---'       '---'         '---'       '---'
                                               (01988) (			   ,---,       ,---,	     ,---,	 ,---,	____
                                               (01989) (SHIFTMUL or SHIFDIV   AC->! R !------>! Q !	     ! R !<------! Q !<-LINK
                                               (01990) ( (left)     (right)       '---'       '---'         '---'       '---'
                                               (01991) (
                                               (01992) 'SHIFTS
                                               (01993) (
                                               (01994) SERIAL:    'SER'
                                               (01995) SERINPUT:  'SINPUT'
                                               (01996) SINPUT=:   'SINP='
                                               (01997) SINP=0:    SHIN/PA:=0;
                                               (01998) SINP=LINK: SHIN/PA:=1;
                                               (01999) SINP=C:    SHIN/PA:=2;
                                               (02000) ROTDOUBLE: SHIN/PA:=3;
                                               (02001) ROTATE:    SHIN/PA:=4;
                                               (02002) ARITHMETIC:SHIN/PA:=5;
                                               (02003) ARIDOUBLE: SHIN/PA:=5;
                                               (02004) SINP=1:    SHIN/PA:=6;
                                               (02005) SHIFTMUL:  SHIN/PA:=7;
                                               (02006) SHIFTDIV:  SHIN/PA:=7;
                                               (02007) 'OPERATIONS
                                               (02008) (
                                               (02009) (	  SIMPLE OPERATIONS ON INTERNAL REGISTERS
                                               (02010) (	  =======================================
                                               (02011) (
                                               (02012) (-------------------------------------------------------------------------------
                                               (02013) (THE FOLLOWING DEFINITIONS COMBINE ALU FUNCTION, OPERAND, AND
                                               (02014) (DESTINATION SPECIFICATIONS, IN ORDER TO CREATE MORE EASILY READABLE
                                               (02015) (SOURCE STATEMENTS WHEN LOADING, INCREMENTING, OR CLEARING
                                               (02016) (INTERNAL REGISTERS.
                                               (02017) (
                                               (02018) ( N O T E !!
                                               (02019) ( OPERATIONS MARKED '(**' ARE COMMENTED OUT TO SAVE SPACE AT ASSEMBLY
                                               (02020) ( TIME, IF NEEDED THROUGH AWAY COMMENT DELIMITER AND HOPEFULLY IF
                                               (02021) ( THERE IS SPACE, YOU MAY USE IT.
                                               (02022) (-------------------------------------------------------------------------------
                                               (02023) (
                                               (02024) LOAD:     'LOAD'
                                               (02025) INCREMENT:'IN'
                                               (02026) DECREMENT:'DE'
                                               (02027) CLEAR:    'CLR'
                                               (02028) (
                                               (02029) LOADQ:	  QREG;
                                               (02030) INQ:	  INCR Q QREG;
                                               (02031) DEQ:	  DECRQ QREG;
                                               (02032) (
                                               (02033) (-------------------------------------------------------------------------------
                                               (02034) (
                                               (02035) FF:       'FF'
                                               (02036) FFTO:     'FFTO'
                                               (02037) 'CONDITIONS
                                               (02038) (
                                               (02039) (	  CONDITION FLIPFLOPS
                                               (02040) (	  ===================
                                               (02041) (-------------------------------------------------------+-----------------------
                                               (02042) (    (FF/PB)						!       Flags:
                                               (02043) (-------------------------------------------------------------------------------
                                               (02044) (FF/PB	Mnemonic	Description			! V ! N ! L ! Z ! P ! C
                                               (02045) (-------------------------------------------------------+---+---+---+---+---+---
                                               (02046) (			D-bus bits when loaded from D	! 5 ! 4 ! 3 ! 2 ! 1 ! 0
                                               (02047) (-------------------------------------------------------+---+---+---+---+---+---
                                               (02048) (1	LCZNVFD		LOAD CZNV FROM D		! L ! L ! = ! L ! = ! L
                                               (02049) (2	LOADPCCY	LOAD PCCY			! = ! = ! = ! = ! L ! =
                                               (02050) (3	RESPCCY		RESET PCCY			! = ! = ! = ! = ! 0 ! =
                                               (02051) (4	LLFD		LOAD LINK FROM D		! = ! = ! L ! = ! = ! =
                                               (02052) (5	LLFSHIFT	LOAD LINK FROM SHIFT		! = ! = ! L^! = ! = ! =
                                               (02053) (6	SETC		SET C				! = ! = ! = ! = ! = ! 1
                                               (02054) (7	LCFSHIFT	LOAD C FROM SHIFT		! = ! = ! = ! = ! = ! L^
                                               (02055) (8	LCZARI		LOAD CZ ARI			! = ! = ! = ! L ! = ! L
                                               (02056) (9	LCNVARI		LOAD CNV ARI			! L ! L ! = ! = ! = ! L
                                               (02057) (A	LCZNVARI	LOAD CZNV ARI			! L ! L ! = ! L ! = ! L
                                               (02058) (B	LCZNVARI16	LOAD CZNV ARI16			! L ! L ! = ! L*! = ! L
                                               (02059) (C	LZNLOG		LOAD ZN LOG			! = ! L ! = ! L ! = ! =
                                               (02060) (D	LZNVLOG		LOAD ZNV LOG			! 0 ! L ! = ! L ! = ! =
                                               (02061) (E	LCZNVLOG	LOAD CZNV LOG			! 0 ! L ! = ! L ! = ! 0
                                               (02062) (F	LZNLOG16	LOAD ZN LOG16			! = ! L ! = ! L*! = ! =
                                               (02063) (-------------------------------------------------------------------------------
                                               (02064) (    L     : LINK
                                               (02065) (    N	   : NEG ( sign )
                                               (02066) (    V	   : Overflow ( bit 7 xor 6 )
                                               (02067) (    Z	   : ZERO
                                               (02068) (    C	   : CARRY
                                               (02069) (    P	   : PCCY
                                               (02070) (    L	   : Flag Loaded
                                               (02071) (    L*    : Flag Loaded (Set if true and true before
                                               (02072) (    L^    : Flag loaded (If ALUD=2,3,6 or 7, loaded from ALU out msb, else lsb
                                               (02073) (    =	   : Not Affected
                                               (02074) (    1	   : Set to True
                                               (02075) (    0	   : Set to False
                                               (02076) 'CONDITION FLAGS cont.
                                               (02077) (-------------------------------------------------------------------------------
                                               (02078) (
                                               (02079) LOADPCCY:   FF/PB:=2;	 (LOAD PCCY  (PROGR CTR CARRY FF)
                                               (02080) RESPCCY:    FF/PB:=3;	 (RESET PCCY
                                               (02081) LOADC:      'LC'
                                               (02082) LOADCZ:     'LCZ'
                                               (02083) LOADCNV:    'LCNV'
                                               (02084) LOADCZNV:   'LCZNV'
                                               (02085) LOADZN:     'LZN'
                                               (02086) LOADZNV:    'LZNV'
                                               (02087) LOADLINK:   'LLINK'
                                               (02088) LCFROM:     'LCF'
                                               (02089) LCZNVFROM:  'LCZNVF'
                                               (02090) LLINKFROM:  'LLF'
                                               (02091) LZNVLOG:    FF/PB:=D;	 (LOAD ZNV LOG
                                               (02092) LCZNVFD:    FF/PB:=1;	 (LOAD CZNV FROM D
                                               (02093) LCZNVARI:   FF/PB:=A;	 (LOAD CZNV ARI	   Z:= FZ	 C:=FC
                                               (02094) LCZNVARI16: FF/PB:=B;	 (LOAD CZNV ARI16  Z:= Z AND FZ, C:=FC
                                               (02095) LCZNVLOG:   FF/PB:=E;	 (LOAD CZNV LOG	   Z:= FZ,	 C:=0
                                               (02096) LZNLOG16:   FF/PB:=F;	 (LOAD ZN LOG16    Z:= Z AND FZ
                                               (02097) LCFSHIFT:   FF/PB:=7;	 (LOAD C FROM SHIFT
                                               (02098) LCNVARI:    FF/PB:=9;	 (LOAD CNV ARI
                                               (02099) SETC:	    FF/PB:=6;	 (SET C
                                               (02100) LLFSHIFT:   FF/PB:=5;	 (LOAD LINK FROM SHIFT
                                               (02101) LLFD:	    FF/PB:=4;	 (LOAD LINK FROM D
                                               (02102) LCZARI:     FF/PB:=8;	 (LOAD CZ ARI
                                               (02103) LZNLOG:     FF/PB:=C;	 (LOAD ZN LOG
                                               (02104) (
                                               (02105) (DEFAULT    FF/PB:=0;	 (NO CHANGE
                                               (02106) (
                                               (02107) 'PULSES
                                               (02108) (
                                               (02109) (	  PULSES
                                               (02110) (	  ======
                                               (02111) (
                                               (02112) (-------------------------------------------------------------------------------
                                               (02113) (FIVE INDEPENDENT GROUPS OF ACTIONS - MOSTLY PULSES, GENERATED AT END
                                               (02114) (OF MICROINSTRUCTION CYCLE. ONE ACTION FROM EACH GROUP MAY BE SELECTED.
                                               (02115) (
                                               (02116) (COMMON ABBREVIATIONS:
                                               (02117) SET:        'SET'
                                               (02118) RESET:      'RES'
                                               (02119) WRITE:      'WRIT'
                                               (02120) (NOTE THAT THE SOURCE WORDS "LOAD ", "INCREMENT ", AND "DECREMENT "
                                               (02121) (ARE ABBREVIATED TO "LOAD", "IN", AND "DE", RESPECTIVELY,
                                               (02122) (BY EARLIER DEFINITIONS
                                               (02123) (
                                               (02124) 'PULSES FIRST GROUP
                                               (02125) (-------------------------------------------------------------------------------
                                               (02126) (FIRST GROUP:	  SHIN/PA
                                               (02127) (
                                               (02128) (RESTRICTION ON FIRST GROUP: WHEN USING ALU DESTINATIONS RAMRIGHT,
                                               (02129) (RAMQRIGHT, RAMLEFT, OR RAMQLEFT, THE PULSES IN THE FIRST GROUP
                                               (02130) ((SHIN/PA) CANNOT BE GENERATED.
                                               (02131) (
                                               (02132) LOADNREG:   SHIN/PA:=1;  (Load NREG from Y-bus bit: 3..0
                                               (02133) RESSPECIAL: SHIN/PA:=2;  (RESET FF SPECIAL
                                               (02134) SETSPECIAL: SHIN/PA:=3;  (SET FF SPECIAL
                                               (02135) (
                                               (02136) LOADIR:     SHIN/PA:=8;  (LOAD INSTRUCTION REGISTER	  (FROM D)
                                               (02137) CUIRQ:	    SHIN/PA:=9;   (USED BELOW
                                               (02138) CALL:       'CALL'
                                               (02139) CALLSP:     SHIN/PA:=A;  (SET CALL TO SP
                                               (02140) ACKSPREQ:   SHIN/PA:=B;  (ACKNOWLEDGE SP REQUEST, at T2 in current uI.
                                               (02141) (ex:			 ACK SPREQ			(Ack of old SPREQ at T2
                                               (02142) (			 DSOURCE SP, PASS D TO W1	(Next SPREQ to w1
                                               (02143) (				   UNC GO TO WHEN SPREQ;( On this new SPREQ
                                               (02144) (
                                               (02145) SELECT:     'SELECT'
                                               (02146) SELECTBLK0: SHIN/PA:=C;  (SELECT MICROPGM BLOCK 0  (First  4k word
                                               (02147) SELECTBLK1: SHIN/PA:=D;  (SELECT MICROPGM BLOCK 1  (Second 4k word
                                               (02148) SELECTBLK2: SHIN/PA:=E;  (SELECT MICROPGM BLOCK 2  (Third  4k word
                                               (02149) SELECTBLK3: SHIN/PA:=F;  (SELECT MICROPGM BLOCK 3  (Fourth 4k word
                                               (02150) (
                                               (02151) (LOADB:	    SHIN/PA:=4;  (LOAD BLOCK REGISTER		  (FROM D)
                                               (02152) LOADLATCH:  'LL'
                                               (02153) LOADLAREG:  'LL'
                                               (02154) LLFROM:     'LLFR'
                                               (02155) LLFRG:	    SHIN/PA:=5; 		  (LOAD LATCH FROM G
                                               (02156) LLFRGR:     SHIN/PA:=5 GASS:=0;		  (LOAD LATCH FROM G(R)
                                               (02157) LLFRSB:     SHIN/PA:=5 GASS:=1;		  (LOAD LATCH FROM STRING BUFFER
                                               (02158) LLFRMSTACK: SHIN/PA:=5 GASS:=2;		  (LOAD LATCH FROM MSTACK
                                               (02159) LLFRPSTACK: SHIN/PA:=5 GASS:=3;		  (LOAD LATCH FROM PSTACK
                                               (02160) LLFRD:	    SHIN/PA:=6; 		  (LOAD LATCH FROM D
                                               (02161) LLFRY:	    SHIN/PA:=7;		  	  (Load Latch from Y
                                               (02162) (LLFRLSTACK: SHIN/PA:=5 GASS:=1;		  (LOAD LATCH FROM LSTACK, assigned to STRING BUFFER!!!
                                               (02163) LLFRLSTACK: SHIN/PA:=5 GASS:=3; 	  (LOAD LATCH FROM LSTACK, assigned to PSTACK!!!
                                               (02164) LLFRRSTACK: SHIN/PA:=5 GASS:=2;		  (LOAD LATCH FROM RSTACK, assigned to MSTACK!!!
                                               (02165) (
                                               (02166) (-------------------------------------------------------------------------------
                                               (02167) (
                                               (02168) (FURTHER RESTRICTIONS ON FOLLOWING SUBGROUP:
                                               (02169) (CANNOT SIMULTANEOUSLY SPECIFY AN "A" OPERAND
                                               (02170) (SHOULD NOT SIMULTANEOUSLY DO "ENDDECODE" OR "STOPDECODE"
                                               (02171) (
                                               (02172) ACK:        'ACK'
                                               (02173) RESFWI:     CUIRQ A:=0;  (RESET FIRMWARE INTERRUPT
                                               (02174) SETFWI:     CUIRQ A:=1;  (SET FIRMWARE INTERRUPT
                                               (02175) RESTRACE:   CUIRQ A:=2;  (Reset TRACE FF detected at ENDDECODE
                                               (02176) SETTRACE:   CUIRQ A:=3;  (Set TRACE FF detected at ENDDECODE
                                               (02177) ACKCLKREQ:  CUIRQ A:=4;  (ACKNOWLEDGE 1200 HZ CLOCK REQUEST
                                               (02178) SLEEP:      CUIRQ A:=5;  (Enter stop mode (power-down). See CCFF for wake-up.
                                               (02179) RESINVPS:   CUIRQ A:=6;  (Cancel inverting of bit 7
                                               (02180) SETINVPS:   CUIRQ A:=7;  (Inv. addr bit 7 to PSTACK, only to MEM.
                                               (02181) LOADCRB0:   CUIRQ A:=10;  (Load configuration register 0 from D
                                               (02182) LOADCRB1:   CUIRQ A:=11;  (Load configuration register 1 from D
                                               (02183) LOADCRB2:   CUIRQ A:=12;  (Load configuration register 2 from D
                                               (02184) LOADCRB3:   CUIRQ A:=13;  (Load configuration register 3 from D
                                               (02185) LOADCRB4:   CUIRQ A:=14;  (Load configuration register 4 from D
                                               (02186) LOADCRB5:   CUIRQ A:=15;  (Load configuration register 5 from D
                                               (02187) LOADCRB6:   CUIRQ A:=16;  (Load configuration register 6 from D
                                               (02188) LOADCRB7:   CUIRQ A:=17;  (Load configuration register 7 from D
                                               (02189) LOADCRB8:   CUIRQ A:=18;  (Load configuration register 8 from D
                                               (02190) LOADCRB9:   CUIRQ A:=19;  (Load configuration register 9 from D
                                               (02191) LOADCRBA:   CUIRQ A:=1A;  (Load configuration register 9 from D
                                               (02192) LOADCRBB:   CUIRQ A:=1B;  (Load configuration register 9 from D
                                               (02193) LOADCRBC:   CUIRQ A:=1C;  (Load configuration register 9 from D
                                               (02194) LOADCRBD:   CUIRQ A:=1D;  (Load configuration register 9 from D
                                               (02195) LOADCRBE:   CUIRQ A:=1E;  (Load configuration register 9 from D
                                               (02196) LOADCRBF:   CUIRQ A:=1F;  (Load configuration register 9 from D
                                               (02197) LOADRTC:    CUIRQ A:=1F;  (Load RTC control register
                                               (02198) (
                                               (02199) (CRB bit assignments
                                               (02200) (
                                               (02201) 'PULSES SECOND GROUP
                                               (02202) (-------------------------------------------------------------------------------
                                               (02203) (SECOND GROUP:	  FF/PB
                                               (02204) (
                                               (02205) (NOTE: CONDITION FLIPFLOP CTRL, DESCRIBED EARLIER, IS INCLUDED IN
                                               (02206) (THIS GROUP
                                               (02207) (
                                               (02208) 'PULSES THIRD GROUP
                                               (02209) (-------------------------------------------------------------------------------
                                               (02210) (THIRD GROUP:	  PC
                                               (02211) (
                                               (02212) LOADADP:    'LOADADP'
                                               (02213) LOADADPA:   PC:=C;	  (LOAD ADDR REG PAGE AUX. PART (FROM Y)
                                               (02214) LOADADPI:   PC:=D;	  (LOAD ADDR REG PAGE INST. PART (FROM Y)
                                               (02215) LOADADPD:   PC:=E;	  (LOAD ADDR REG PAGE DATA. PART (FROM Y)
                                               (02216) LOADADPP:   PC:=F;	  (LOAD ADDR REG PAGE PCODE. PART (FROM Y)
                                               (02217) (
                                               (02218) LOADADH:    'LOADADH'
                                               (02219) LOADADHA:   PC:=8;	  (LOAD ADDR REG HIGH PART (FROM Y),AND SELECT ADPA
                                               (02220) LOADADHI:   PC:=9;	  (LOAD ADDR REG HIGH PART (FROM Y),AND SELECT ADPI
                                               (02221) LOADADHD:   PC:=A;	  (LOAD ADDR REG HIGH PART (FROM Y),AND SELECT ADPD
                                               (02222) LOADADHP:   PC:=B;	  (LOAD ADDR REG HIGH PART (FROM Y),AND SELECT ADPP
                                               (02223) (
                                               (02224) LOADADL:    'LADL'
                                               (02225) LADLFROM:   'LADLFROM'
                                               (02226) LADLFROMY:  PC:=4;	  (LOAD ADDRESS REGISTER LOW PART FROM Y
                                               (02227) LADLFROMD:  PC:=5;	  (LOAD ADDRESS REGISTER LOW PART FROM D
                                               (02228) (
                                               (02229) DEADL:      PC:=6;	  (Step ADL -1 (or +1, if MA1 is set)
                                               (02230) INADL:      PC:=7;	  (Step ADL +1 (or -1, if MA1 is set)
                                               (02231) (
                                               (02232) STEP:       'STEP'
                                               (02233) STEPADL:    PC:=7;	  (Step ADL (+1 or -1, controlled by DIRC
                                               (02234) (
                                               (02235) WRITG:      PC:=3;	    	(WRITE IN GMEM (FROM Y), GASD spec'd separately
                                               (02236) WRITGR:     PC:=3 GASD:=0;	(WRITE IN GENERAL REGISTER R (FROM Y)
                                               (02237) WRITSB:     PC:=3 GASD:=1;	(WRITE IN STRING BUFFER (FROM Y)
                                               (02238) WRITMSTACK: PC:=3 GASD:=2;	(WRITE IN MSTACK (FROM Y)
                                               (02239) WRITPSTACK: PC:=3 GASD:=3;	(WRITE IN PSTACK (FROM Y)
                                               (02240) (WRITLSTACK: PC:=3 GASD:=1;	(WRITE IN LSTACK (FROM Y), assigned to STRING BUFFER!!!
                                               (02241) WRITLSTACK: PC:=3 GASD:=3;	(WRITE IN LSTACK (FROM Y), assigned to PSTACK!!!
                                               (02242) WRITRSTACK: PC:=3 GASD:=2;	(WRITE IN RSTACK (FROM Y), assigned to MSTACK!!!
                                               (02243) (
                                               (02244) ( - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                               (02245) (Direct bus control register (DIRC)
                                               (02246) (
                                               (02247) LOADDIRC:   PC:=2;     (LOAD DIRC FROM D BUS
                                               (02248) (
                                               (02249) ( The DIRC register contains eight flip-flops:
                                               (02250) (
                                               (02251) (   7   6   5   4   3   2   1   0    <--   D-bus data bit
                                               (02252) ( +---+---+---+---+---+---+---+---+
                                               (02253) ( !MA2!MA1!MSL!GSL!ISL!LMP!U_D!ALR!
                                               (02254) ( +---+---+---+---+---+---+---+---+
                                               (02255) (   !   !   !   !   !   !   !   !
                                               (02256) (   !   !   !   !   !   !   !   +-- 0 --> ALLRAS inactive. Normal mode
                                               (02257) (   !   !   !   !   !   !   !       1 --> ALLRAS active. Refresh mode, all CKE active.
                                               (02258) (   !   !   !   !   !   !   !
                                               (02259) (   !   !   !   !   !   !   +-- 0 --> USE_DIRECT inactive, direct bus disabled.
                                               (02260) (   !   !   !   !   !   !       1 --> USE_DIRECT active,   direct bus enabled.
                                               (02261) (   !   !   !   !   !   !
                                               (02262) (   !   !   !   !   !   +-- 0 --> Normal mode.
                                               (02263) (   !   !   !   !   !       1 --> Load MPGM mode.
                                               (02264) (   !   !   !   !   !
                                               (02265) (   !   !   !   !   +-- 0 --> If U_D, IOMEM deselected, else IOMEM single step.
                                               (02266) (   !   !   !   !       1 --> If U_D, IOMEM selected, else IOMEM double step.
                                               (02267) (   !   !   !   !
                                               (02268) (   !   !   !   +-- 0 --> If U_D, GMEM deselected, else GMEM single step.
                                               (02269) (   !   !   !       1 --> If U_D, GMEM selected, else GMEM double step.
                                               (02270) (   !   !   !
                                               (02271) (   !   !   +-- 0 --> If U_D, DRAM deselected, else ADL single step.
                                               (02272) (   !   !       1 --> If U_D, DRAM selected, else ADL double step.
                                               (02273) (   !   !
                                               (02274) (   !   +-- 0 --> ADL steps up. (On "STEP/INCREMENT ADL", down on "DECREMENT ADL")
                                               (02275) (   !       1 --> ADL steps down. (On "STEP/INCREMENT ADL", up on "DECREMENT ADL")
                                               (02276) (   !
                                               (02277) (   +-- 0 --> ADL steps on the "STEP/INCREMENT/DECREMENT ADL" pulses.
                                               (02278) (       1 --> ADL steps on the "STEP/INCREMENT/DECREMENT ADL" pulses and on GMEM write.
                                               (02279) (
                                               (02280) (
                                               (02281) (MA2,MA1,MSL controls the stepping mode of ADL.
                                               (02282) (Ex: SET STEP +1:  ADL increments on every 'STEP ADL'
                                               (02283) (    SET STEP -1:  ADL decrements on every 'STEP ADL'
                                               (02284) (    SET STEP GW+1: ADL increments on every 'STEP ADL' and on any GMEM write.
                                               (02285) (    SET STEP GW-1: ADL decrements on every 'STEP ADL' and on any GMEM write.
                                               (02286) (    SET STEP +2:  ADL increments twice on every 'STEP ADL'
                                               (02287) (    SET STEP -2:  ADL decrements twice on every 'STEP ADL'
                                               (02288) (    SET STEP GW+2: ADL increments twice on every 'STEP ADL' and on any GMEM write.
                                               (02289) (    SET STEP GW-2: ADL decrements twice on every 'STEP ADL' and on any GMEM write.
                                               (02290) (
                                               (02291) 
                                               (02292) SETSTEP:   'SST'
                                               (02293) SST+1:	   PC:=2 MIFORM:=0 DATA1:=00;
                                               (02294) SST-1:	   PC:=2 MIFORM:=0 DATA1:=40;
                                               (02295) SSTGW+1:   PC:=2 MIFORM:=0 DATA1:=80;
                                               (02296) SSTGW-1:   PC:=2 MIFORM:=0 DATA1:=C0;
                                               (02297) SST+2:	   PC:=2 MIFORM:=0 DATA1:=20;
                                               (02298) SST-2:	   PC:=2 MIFORM:=0 DATA1:=60;
                                               (02299) SSTGW+2:   PC:=2 MIFORM:=0 DATA1:=A0;
                                               (02300) SSTGW-2:   PC:=2 MIFORM:=0 DATA1:=E0;
                                               (02301) (
                                               (02302) (
                                               (02303) (U_D,MSL,GSL,ISL control the fast transfers on the direct bus between
                                               (02304) (memory, GMEM, IOMEM and MPGM RAM.
                                               (02305) (Ex: SET FAST TRANSFER FROM MUP TO GMEM:	Transfer from mem (inc) to GMEM
                                               (02306) (    SET FAST TRANSFER FROM MDOWN TO GMEM:	Transfer from mem (dec) to GMEM
                                               (02307) (    SET FAST TRANSFER FROM GMEM TO MUP:	Transfer from GMEM to mem (inc)
                                               (02308) (    SET FAST TRANSFER FROM GMEM TO MDOWN:	Transfer from GMEM to mem (dec)
                                               (02309) (    SET FAST TRANSFER FROM MUP TO IOMEM:	Transfer from mem (inc) to IOMEM
                                               (02310) (    SET FAST TRANSFER FROM MDOWN TO IOMEM:	Transfer from mem (dec) to IOMEM
                                               (02311) (    SET FAST TRANSFER FROM IOMEM TO MUP:	Transfer from IOMEM to mem (inc)
                                               (02312) (    SET FAST TRANSFER FROM IOMEM TO MDOWN:	Transfer from IOMEM to mem (dec)
                                               (02313) (    SET FAST TRANSFER FROM GMEM TO IOMEM:	Transfer from GMEM to IOMEM
                                               (02314) (    SET FAST TRANSFER FROM IOMEM TO GMEM:	Transfer from IOMEM to GMEM
                                               (02315) (    SET FAST TRANSFER FROM MUP TO MPMEM:	Transfer from mem (inc) to MPMEM
                                               (02316) (    SET FAST TRANSFER FROM MDOWN TO MPMEM:	Transfer from mem (dec) to MPMEM
                                               (02317) (    SET FAST TRANSFER FROM GMEM TO MPMEM:	Transfer from GMEM to MPMEM
                                               (02318) (
                                               (02319) 
                                               (02320) SETFAST:   'F'
                                               (02321) FTRANSFER: 'FTRAN'
                                               (02322) FTRANFROM: 'FT'
                                               (02323) FTMUP:     'FTMU'
                                               (02324) FTMDOWN:   'FTMD'
                                               (02325) FTGMEM:    'FTG'
                                               (02326) FTIOMEM:   'FTI'
                                               (02327) FTMUTO:    'FTMU2'
                                               (02328) FTMDTO:    'FTMD2'
                                               (02329) FTGTO:     'FTG2'
                                               (02330) FTITO:     'FTI2'
                                               (02331) FTMU2GMEM: FTMU2G;
                                               (02332) FTMU2IOMEM: FTMU2I;
                                               (02333) FTMU2MPMEM: FTMU2M;
                                               (02334) FTMD2GMEM: FTMD2G;
                                               (02335) FTMD2IOMEM: FTMD2I;
                                               (02336) FTMD2MPMEM: FTMD2M;
                                               (02337) FTG2MUP:   FTG2MU;
                                               (02338) FTG2MDOWN: FTG2MD;
                                               (02339) FTG2IOMEM: FTG2I;
                                               (02340) FTG2MPMEM: FTG2M;
                                               (02341) FTI2MUP:   FTI2MU;
                                               (02342) FTI2MDOWN: FTI2MD;
                                               (02343) FTI2GMEM:  FTI2G;
                                               (02344) FTMU2G:    PC:=2 MIFORM:=0 DATA1:=B2;
                                               (02345) FTMU2I:    PC:=2 MIFORM:=0 DATA1:=2A;
                                               (02346) FTMU2M:    PC:=2 MIFORM:=0 DATA1:=26;
                                               (02347) FTMD2G:    PC:=2 MIFORM:=0 DATA1:=F2;
                                               (02348) FTMD2I:    PC:=2 MIFORM:=0 DATA1:=6A;
                                               (02349) FTMD2M:    PC:=2 MIFORM:=0 DATA1:=66;
                                               (02350) FTG2MU:    PC:=2 MIFORM:=0 DATA1:=12;
                                               (02351) FTG2MD:    PC:=2 MIFORM:=0 DATA1:=52;
                                               (02352) FTG2I:     PC:=2 MIFORM:=0 DATA1:=12;
                                               (02353) FTG2M:     PC:=2 MIFORM:=0 DATA1:=16;
                                               (02354) FTI2MU:    PC:=2 MIFORM:=0 DATA1:=0A;
                                               (02355) FTI2MD:    PC:=2 MIFORM:=0 DATA1:=4A;
                                               (02356) FTI2G:     PC:=2 MIFORM:=0 DATA1:=0A;
                                               (02357) (
                                               (02358) ( - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                               (02359) (DEFAULT	    PC:=0;
                                               (02360) (
                                               (02361) 'PULSES FOURTH GROUP
                                               (02362) (-------------------------------------------------------------------------------
                                               (02363) (FOURTH GROUP	  PD
                                               (02364) (
                                               (02365) LOADOUTPUT: LDOUTPUT;
                                               (02366) LOADDTM:    'LDTM'
                                               (02367) LDTMFROM:   'LDTMFR'
                                               (02368) NEXT: 'NEXT'
                                               (02369) SYNCHRONIZE: SYNC;
                                               (02370) LDTMFRD:    PD:=2;	 (LOAD DATA-TO-MEM REGISTER FROM D
                                               (02371) LDTMFRY:    PD:=3;	 (LOAD DATA-TO-MEM REGISTER FROM Y
                                               (02372) LDTMFRBUS:  PD:=2;	 (LOAD DATA-TO-MEM REGISTER FROM 16-BIT BUS
                                               (02373) LOADIOADDR: PD:=4;	 (LOAD I/O ADDRESS REGISTER
                                               (02374) LDOUTPUT:   PD:=5;	 (LOAD DATA TO OUTPUT
                                               (02375) NEXTINPUT:  PD:=6;       (GET DATA FROM INPUT
                                               (02376) SYNC:       PD:=7;       (SYCHRONIZE TO I/O CLOCK
                                               (02377) (
                                               (02378) (NOTE! "NEXT INPUT" AND "SYNCHRONIZE" WILL ALSO DO "LOAD DTM FROM D"!
                                               (02379) (
                                               (02380) (
                                               (02381) (ONLY WHEN THE LMP BIT IS SET IN MMU CONTROL REGISTER 1:
                                               (02382) (
                                               (02383) LOADMPGM: LOADMP;
                                               (02384) LOADMP:   LDMP;
                                               (02385) LDMP:     PD:=2;	 (LOAD MPGM DATA FROM 16-BIT BUS TO MPLL.
                                               (02386) (
                                               (02387) (NOTE! DATA WILL BE TRANSFERRED TO MPGM RAM ON THE LAST PULSE OF A WORD
                                               (02388) (
                                               (02389) (
                                               (02390) (RESTRICTIONS ON FOLLOWING SUBGROUP:
                                               (02391) (CANNOT SIMULTANEOUSLY SPECIFY AN "A" OPERAND
                                               (02392) (
                                               (02393) LOADPORT:    LDPORT;
                                               (02394) LOADCPORT:   'LDCPORT'
                                               (02395) LOADDPORT:   'LDDPORT'
                                               (02396) LDPORT:     PD:=1;       (Load port register, reg is specified with AADDR
                                               (02397) LDCPORTA:   LDPORT A:=00; (Load configuration register of general port A
                                               (02398) LDCPORTB:   LDPORT A:=01; (Load configuration register of general port B
                                               (02399) LDCPORTC:   LDPORT A:=02; (Load configuration register of general port C
                                               (02400) LDCPORTD:   LDPORT A:=03; (Load configuration register of general port D
                                               (02401) LDCPORTE:   LDPORT A:=04; (Load configuration register of general port E
                                               (02402) LDCPORTF:   LDPORT A:=05; (Load configuration register of general port F
                                               (02403) LDCPORTG:   LDPORT A:=06; (Load configuration register of general port G
                                               (02404) LDCPORTH:   LDPORT A:=07; (Load configuration register of general port H
                                               (02405) LDCPORTI:   LDPORT A:=08; (Load configuration register of general port I
                                               (02406) LDCPORTJ:   LDPORT A:=09; (Load configuration register of general port J
                                               (02407) 
                                               (02408) LDDPORTA:   LDPORT A:=10; (Load data register of general port A
                                               (02409) LDDPORTB:   LDPORT A:=11; (Load data register of general port B
                                               (02410) LDDPORTC:   LDPORT A:=12; (Load data register of general port C
                                               (02411) LDDPORTD:   LDPORT A:=13; (Load data register of general port D
                                               (02412) LDDPORTE:   LDPORT A:=14; (Load data register of general port E
                                               (02413) LDDPORTF:   LDPORT A:=15; (Load data register of general port F
                                               (02414) LDDPORTG:   LDPORT A:=16; (Load data register of general port G
                                               (02415) LDDPORTH:   LDPORT A:=17; (Load data register of general port H
                                               (02416) LDDPORTI:   LDPORT A:=18; (Load data register of general port I
                                               (02417) LDDPORTJ:   LDPORT A:=19; (Load data register of general port J
                                               (02418) (
                                               (02419) LDCPORTK:   LDPORT A:=0A; (Load configuration register of general port K
                                               (02420) LDCPORTL:   LDPORT A:=0B; (Load configuration register of general port L
                                               (02421) LDCPORTM:   LDPORT A:=0C; (Load configuration register of general port M
                                               (02422) LDCPORTN:   LDPORT A:=0D; (Load configuration register of general port N
                                               (02423) LDCPORTO:   LDPORT A:=0E; (Load configuration register of general port O
                                               (02424) LDCPORTP:   LDPORT A:=0F; (Load configuration register of general port P
                                               (02425) LDDPORTK:   LDPORT A:=1A; (Load data register of general port K
                                               (02426) LDDPORTL:   LDPORT A:=1B; (Load data register of general port L
                                               (02427) LDDPORTM:   LDPORT A:=1C; (Load data register of general port M
                                               (02428) LDDPORTN:   LDPORT A:=1D; (Load data register of general port N
                                               (02429) LDDPORTO:   LDPORT A:=1E; (Load data register of general port O
                                               (02430) LDDPORTP:   LDPORT A:=1F; (Load data register of general port P
                                               (02431) (
                                               (02432) (DEFAULT    PD:=0;
                                               (02433) (-------------------------------------------------------------------------------
                                               (02434) (
                                               (02435) 'GMEM COUNTER CONTROL
                                               (02436) (-------------------------------------------------------------------------------
                                               (02437) (EXAMPLES:
                                               (02438) (
                                               (02439) (	INCREMENT SBCTR;
                                               (02440) (	---------------------------------
                                               (02441) (	INCREMENT MSCTR, DECREMENT PSCTR;
                                               (02442) (	---------------------------------
                                               (02443) (       PUSH PSCTR;
                                               (02444) (	---------------------------------
                                               (02445) (	GSOURCE MSTACK, GDEST PSTACK
                                               (02446) (	POP DSTCTR & DECREMENT SRCCTR;
                                               (02447) (	---------------------------------
                                               (02448) (	DSOURCE SB, PASS D, WRITE PSCTR
                                               (02449) (	PUSH SRCCTR & LOAD DSTCTR;
                                               (02450) (	---------------------------------
                                               (02451) (
                                               (02452) (-------------------------------------------------------------------------------
                                               (02453) (SOURCE COUNTER CONTROL
                                               (02454) (
                                               (02455) INSRCCTR:    GACS:=1;   (Increment source counter
                                               (02456) DESRCCTR:    GACS:=2;   (Decrement source counter
                                               (02457) LOADSRCCTR:  GACS:=3;   (Load source counter
                                               (02458) PUSHSRCCTR:  GAPP:=1 GACS:=0; (Push and load source counter
                                               (02459) POPSRCCTR:   GAPP:=1 GACS:=1; (Pop source counter
                                               (02460) (
                                               (02461) (-------------------------------------------------------------------------------
                                               (02462) (DESTINATION COUNTER CONTROL
                                               (02463) (
                                               (02464) INDSTCTR:    GACD:=1;   (Increment destination counter
                                               (02465) DEDSTCTR:    GACD:=2;   (Decrement destination counter
                                               (02466) LOADDSTCTR:  GACD:=3;   (Load dest counter
                                               (02467) PUSHDSTCTR:  GAPP:=1 GACS:=2; (Push and load destination counter
                                               (02468) POPDSTCTR:   GAPP:=1 GACS:=3; (Pop destination counter
                                               (02469) (
                                               (02470) (-------------------------------------------------------------------------------
                                               (02471) (
                                               (02472) (
                                               (02473) &INCREMENT: '&IN'	(&: '&' (defined elsewhere)
                                               (02474) &LOAD:      '&LD'	(&: '&' (defined elsewhere)
                                               (02475) &POP:       '&PP'
                                               (02476) (
                                               (02477) &INSRCCTR:  GACD:=1;
                                               (02478) &INDSTCTR:  GACD:=1;
                                               (02479) &DESRCCTR:  GACD:=2;	(&DECREMENT: '&DE' (defined elsewhere)
                                               (02480) &DEDSTCTR:  GACD:=2;	(&DECREMENT: '&DE' (defined elsewhere)
                                               (02481) &LDSRCCTR:  GACD:=3;
                                               (02482) &LDDSTCTR:  GACD:=3;
                                               (02483) &PPSRCCTR:  GACD:=3;
                                               (02484) &PPDSTCTR:  GACD:=3;
                                               (02485) (
                                               (02486) (-------------------------------------------------------------------------------
                                               (02487) (R COUNTER CONTROL
                                               (02488) (
                                               (02489) LOADR:	    LOADSRCCTR GASS:=0;   (LOAD R COUNTER	    (FROM D)
                                               (02490) INR:	    INSRCCTR GASS:=0;	   (INCREMENT R COUNTER
                                               (02491) DER:	    DESRCCTR GASS:=0;	   (DECREMENT R COUNTER
                                               (02492) LOADBR:	    LOADSRCCTR GASS:=0;   (LOAD BR COUNTER	    (FROM D)
                                               (02493) INBR:	    INSRCCTR GASS:=0;	   (INCREMENT BR COUNTER
                                               (02494) DEBR:	    DESRCCTR GASS:=0;	   (DECREMENT BR COUNTER
                                               (02495) (
                                               (02496) (-------------------------------------------------------------------------------
                                               (02497) (STRING BUFFER COUNTER CONTROL
                                               (02498) (
                                               (02499) LOADSBCTR:  LOADSRCCTR GASS:=1;	   (LOAD STRING BUFFER CTR  (FROM Y)
                                               (02500) INSBCTR:    INSRCCTR GASS:=1;	   (INCREMENT STRING BUFFER COUNTER
                                               (02501) DESBCTR:    DESRCCTR GASS:=1;	   (DECREMENT STRING BUFFER COUNTER
                                               (02502) PUSHSBCTR:  PUSHSRCCTR GASS:=1;	   (Push and load SBCTR
                                               (02503) POPSBCTR:   POPSRCCTR GASS:=1;	   (Pop SBCTR
                                               (02504) (
                                               (02505) (-------------------------------------------------------------------------------
                                               (02506) (MSTACK COUNTER CONTROL
                                               (02507) (
                                               (02508) LOADMSCTR:  LOADSRCCTR GASS:=2;	   (LOAD MSTACK COUNTER     (FROM Y)
                                               (02509) INMSCTR:    INSRCCTR GASS:=2;	   (INCREMENT MSTACK COUNTER
                                               (02510) DEMSCTR:    DESRCCTR GASS:=2;	   (DECREMENT MSTACK COUNTER
                                               (02511) (
                                               (02512) (-------------------------------------------------------------------------------
                                               (02513) (PSTACK COUNTER CONTROL
                                               (02514) (
                                               (02515) LOADPSCTR:  LOADSRCCTR GASS:=3;	   (LOAD PSTACK COUNTER     (FROM Y)
                                               (02516) INPSCTR:    INSRCCTR GASS:=3;	   (INCREMENT PSTACK COUNTER
                                               (02517) DEPSCTR:    DESRCCTR GASS:=3;	   (DECREMENT PSTACK COUNTER
                                               (02518) PUSHPSCTR:  PUSHSRCCTR GASS:=3;	   (Push and load PSCTR
                                               (02519) POPPSCTR:   POPSRCCTR GASS:=3;	   (Pop PSCTR
                                               (02520) (
                                               (02521) (-------------------------------------------------------------------------------
                                               (02522) ((LSTACK COUNTER CONTROL, assigned to STRING BUFFER COUNTER!!!
                                               (02523) ((
                                               (02524) (LOADLSCTR:  LOADSRCCTR GASS:=1;   (LOAD LSTACK COUNTER     (FROM Y)
                                               (02525) (INLSCTR:    INSRCCTR GASS:=1;	   (INCREMENT LSTACK COUNTER
                                               (02526) (DELSCTR:    DESRCCTR GASS:=1;	   (DECREMENT LSTACK COUNTER
                                               (02527) (PUSHLSCTR:  PUSHSRCCTR GASS:=1;   (Push and load LSCTR
                                               (02528) (POPLSCTR:   POPSRCCTR GASS:=1;	   (Pop LSCTR
                                               (02529) ((
                                               (02530) (-------------------------------------------------------------------------------
                                               (02531) (LSTACK COUNTER CONTROL, assigned to PSTACK COUNTER!!!
                                               (02532) 
                                               (02533) LOADLSCTR:  LOADSRCCTR GASS:=3;   (LOAD LSTACK COUNTER     (FROM Y)
                                               (02534) INLSCTR:    INSRCCTR GASS:=3;	  (INCREMENT LSTACK COUNTER
                                               (02535) DELSCTR:    DESRCCTR GASS:=3;	  (DECREMENT LSTACK COUNTER
                                               (02536) PUSHLSCTR:  PUSHSRCCTR GASS:=3;   (Push and load LSCTR
                                               (02537) POPLSCTR:   POPSRCCTR GASS:=3;	  (Pop LSCTR
                                               (02538) (
                                               (02539) (-------------------------------------------------------------------------------
                                               (02540) (RSTACK COUNTER CONTROL, assigned to MSTACK COUNTER!!!
                                               (02541) LOADRSCTR:  LOADSRCCTR GASS:=2;	   (LOAD RSTACK COUNTER     (FROM Y)
                                               (02542) INRSCTR:    INSRCCTR GASS:=2;	   (INCREMENT RSTACK COUNTER
                                               (02543) DERSCTR:    DESRCCTR GASS:=2;	   (DECREMENT RSTACK COUNTER
                                               (02544) PUSHRSCTR:  PUSHSRCCTR GASS:=2;	   (Push and load RSCTR
                                               (02545) POPRSCTR:   POPSRCCTR GASS:=2;	   (Pop RSCTR
                                               (02546) 
                                               (02547) (
                                               (02548) (SETINVPS:   CUIRQ A:=7;  	   (See PA field definitions
                                               (02549) (RESINVPS:   CUIRQ A:=6;  	   (See PA field definitions
                                               (02550) (
                                               (02551) POP: 'POP'
                                               (02552) PUSHPSTACK: WRITPSTACK, DEDSTCTR;
                                               (02553) POPPSTACK: DSPSTACK, INSRCCTR;
                                               (02554) (
                                               (02555) (-------------------------------------------------------------------------------
                                               (02556) 'LATCH
                                               (02557) (
                                               (02558) (	  LATCH
                                               (02559) (	  =====
                                               (02560) (
                                               (02561) (---------------------------------------------------------------------
                                               (02562) (
                                               (02563) (A LATCH IS PROVIDED, WHICH CAN BE LOADED FROM G (THE REGISTER ADDRESSED
                                               (02564) (BY COUNTER R, OR THE ASTACK ELEMENT ADDRESSED BY THE ASTACK COUNTER),
                                               (02565) (FROM THE D-BUS, OR FROM Y-BUS.
                                               (02566) (
                                               (02567) (THE LATCH IS NO LONGER ACTUALLY A LATCH, BUT A REGISTER. IT IS LOADED AT
                                               (02568) (THE END OF THE MICROINSTRUCTION CYCLE AND A LOADED VALUE CAN THEREFORE
                                               (02569) (NOT BE ACCESSED UNTIL THE NEXT CYCLE.
                                               (02570) (
                                               (02571) (IT IS INTENDED TO BE USED FOR THE FOLLOWING PURPOSES:
                                               (02572) (
                                               (02573) (A)  TEMPORARY STORAGE OF MEMORY DATA
                                               (02574) (
                                               (02575) (IN SOME SITUATIONS IT IS DESIRABLE TO RECEIVE DATA FROM MEMORY, SO
                                               (02576) (THAT NEXT MEMORY CYCLE CAN BE STARTED, ALTHOUGH THE ALU IS OCCUPIED
                                               (02577) (AND THEREFORE CANNOT TAKE CARE OF THE DATA.
                                               (02578) (DATA FROM MEMORY CAN THEN BE STORED IN THE LATCH, UNTIL IT CAN BE
                                               (02579) (PROCESSED BY THE ALU.
                                               (02580) (TO STORE MEMORY DATA IN THE LATCH, WRITE LIKE THIS:
                                               (02581) (	 DSOURCE MEM, LOAD LATCH FROM D
                                               (02582) (
                                               (02583) (B)  WHEN PERFORMING BARREL SHIFT OR MULTIPLYER FUNCTIONS. THE SOURCE IS LATCH
                                               (02584) (
                                               (02585) (EXAMPLE 3: USING MBM LOGIC  (BARRELSHIFTER)
                                               (02586) (NOTE! THAT THE LATCH IS A REGISTER!
                                               (02587) (
                                               (02588) (     PASS W1	   		   (Y-BUS IS OLD W1
                                               (02589) (     LOAD LATCH FROM Y 	   (LOAD LATCH WITH OLD W1
                                               (02590) (     ;
                                               (02591) (  (----------------------------------------
                                               (02592) (     FIRSTSHIFT		   (PERFORM A BARREL SHIFT, SOURCE IS LATCH
                                               (02593) (     DSOURCE MBM		   (D-BUS IS SHIFTED LATCH DATA
                                               (02594) (     PASS D TO W1		   (W1:= SHIFTED W1
                                               (02595) (     ;
                                               (02596) (-------------------------------------------------------------------------------
                                               (02597) 'MEMORY
                                               (02598) (
                                               (02599) (	  MEMORY CONTROL
                                               (02600) (	  ==============
                                               (02601) (
                                               (02602) (-------------------------------------------------------------------------------
                                               (02603) (EACH MICROINSTRUCTION CONSTITUTES AN ELEMENT IN A SEQUENCE WHICH
                                               (02604) (PRODUCES A MEMORY CYCLE OF SOME KIND.
                                               (02605) (THERE ARE FOUR DIFFERENT TYPES OF ELEMENTS, NAMED:
                                               (02606) ( R, RW, C, M.
                                               (02607) '
                                               (02608) (A MICROINSTRUCTION OF TYPE M COMPLETES ANY MEMORY CYCLE.
                                               (02609) (FURTHER ACCESS TO THE MEMORY REQUIRES THE START OF A NEW COMPLETE
                                               (02610) (MEMORY CYCLE, GIVING FULL ADDRESS.
                                               (02611) (
                                               (02612) (FOLLOWING M, ANY NUMBER OF C AND/OR M TYPE MICROINSTRUCTIONS
                                               (02613) (MAY FOLLOW WITHOUT CAUSING A NEW MEMORY CYCLE. CONTENTS OF
                                               (02614) (REGISTERS ADH, ADL, AND DTM IS IRRELEVANT DURING THIS INACTIVE
                                               (02615) (TIME. THEY ARE RELEVANT ONLY AT SPECIFIC POINTS IN THE ACTIVE
                                               (02616) (TIME, AS DESCRIBED BELOW.
                                               (02617) (
                                               (02618) (THERE ARE NO TIME RESTRICTIONS FOR GP2000. HOWEVER, SOME SEQUENCES
                                               (02619) (MAY CAUSE AUTOMATIC EXTENSION OF CYCLES TO COMPLY WITH MEMORY TIMING.
                                               (02620) (
                                               (02621) (FOLLOWING TYPE M (OR INACTIVE C) A COMPLETE MEMORY CYCLE IS STARTED BY
                                               (02622) (A MICROINSTRUCTION OF TYPE R OR RW. THE CONTENTS OF SADP, ADP AND ADH
                                               (02623) (DURING THE EXECUTION OF THIS FIRST MICROINSTRUCTION WILL BE USED FOR
                                               (02624) (PRODUCING THE ROW ADDRESS FOR THE COMPLETE MEMORY CYCLE, CHANGING THEM
                                               (02625) (IN THIS CYCLE OR ANY OF THE FOLLOWING WITHIN THE ACTIVE TIME HAS NO
                                               (02626) (EFFECT.
                                               (02627) (
                                               (02628) (THE ACTIVE TIME, I.E. THE COMPLETE MEMORY CYCLE, CONSISTS OF
                                               (02629) (THIS FIRST MICROINSTRUCTION AND ALL THE FOLLOWING, UP TO AND
                                               (02630) (INCLUDING THE FIRST M-TYPE MICROINSTRUCTION. THIS ACTIVE TIME
                                               (02631) (MAY INCLUDE MANY PAGE-MODE-READ OR PAGE-MODE-WRITE
                                               (02632) (CYCLES.
                                               (02633) (
                                               (02634) (THE CONTENTS OF SADP, ADP OR ADH MAY BE CHANGED AT ANY TIME, ALSO WITHIN THE
                                               (02635) (ACTIVE TIME. THE NEW CONTENTS WILL, HOWEVER, NOT BE USED UNTIL THE
                                               (02636) (START OF THE NEXT COMPLETE CYCLE.
                                               (02637) (
                                               (02638) (WRITING WILL TAKE PLACE DURING A C-TYPE FOLLOWING AN RW-
                                               (02639) (TYPE MICROINSTRUCTION. THE CONTENTS OF DTM DURING THIS C-TYPE
                                               (02640) (MICROINSTRUCTION WILL BE WRITTEN. THE CONTENTS OF ADL AT THIS TIME
                                               (02641) (WILL BE USED AS COLUMN ADDRESS. THEREFORE, THE CONTENTS OF ADL AND
                                               (02642) (DTM REGISTERS MUST BE LOADED IN THE RW-CYCLE OR EARLIER.
                                               (02643) (
                                               (02644) (WHEN READING, THE OUTPUT OF THE DFM REGISTER WILL HOLD THE OLD VALUE
                                               (02645) (DURING TWO CYCLES FOLLOWING R. THE NEW DATA WILL BECOME VALID
                                               (02646) (IN TIME TO BE USED BY THE NEXT MICROINSTRUCTION. IF THIS NEXT
                                               (02647) (MICROINSTRUCTION WAS NOT R, THE DATA IN DFM WILL REMAIN
                                               (02648) (UNCHANGED UP TO AND INCLUDING THE NEXT R AND TWO CYCLES AFTER THAT.
                                               (02649) (THE CONTENTS OF ADL WHEN THE READING TAKES PLACE (IN THE CYCLE FOLLOWING
                                               (02650) (THE R-CYCLE) IS USED AS COLUMN ADDRESS. THEREFORE, THE CONTENTS OF THE ADL
                                               (02651) (REGISTER MUST BE LOADED IN THE R-CYCLE OR EARLIER.
                                               (02652) (
                                               (02653) (-------------------------------------------------------------------------------
                                               (02654) (COMMON BASIC SEQUENCES:
                                               (02655) (-------------------------------------------------------------------------------
                                               (02656) (REFRESH:
                                               (02657) (
                                               (02658) (Refresh is handled by a special R-C-M sequence when ALLRAS is active
                                               (02659) (-------------------------------------------------------------------------------
                                               (02660) (
                                               (02661) (READ:
                                               (02662) (		 READ: R-C-M
                                               (02663) (      PAGE MODE READ: R-C-R-(C-R-..)-C-M
                                               (02664) ( ONE CYCLE READ LOOP: R-R-(R-..)-C-M
                                               (02665) (-------------------------------------------------------------------------------
                                               (02666) (
                                               (02667) (WRITE:
                                               (02668) (		WRITE: RW-C-M
                                               (02669) (     PAGE MODE WRITE: RW-C-RW-(C-RW-..)-C-M
                                               (02670) (ONE CYCLE WRITE LOOP: RW-RW-(RW-..)-C-M
                                               (02671) (-------------------------------------------------------------------------------
                                               (02672) (
                                               (02673) (NOTE THAT PAGE MODE READ AND WRITE CAN BE COMBINED
                                               (02674) '
                                               (02675) (
                                               (02676) C:	  MEMCP := 0;
                                               (02677) M:	  MEMCP := 1;
                                               (02678) R:	  MEMCP := 2;
                                               (02679) RW:	  MEMCP := 3;
                                               (02680) (
                                               (02681) $:	  MEMCP := 0;
                                               (02682) $C:	  MEMCP := 0;
                                               (02683) $M:	  MEMCP := 1;
                                               (02684) $R:	  MEMCP := 2;
                                               (02685) $RW:	  MEMCP := 3;
                                               (02686) (
                                               (02687) (-------------------------------------------------------------------------------
                                               (02688) '
                                               (02689) (THE FOLLOWING DEFINITIONS WILL ALLOW TIMING CONTROL SPECIFICATIONS TO REMAIN
                                               (02690) (IN OLD GP1000 CODE WITHOUT HAVING ANY EFFECT.
                                               (02691) (
                                               (02692) (2:  C;
                                               (02693) (3:  C;
                                               (02694) (R2: R;
                                               (02695) (R3: R;
                                               (02696) (RW2: RW;
                                               (02697) (RW3: RW;
                                               (02698) (C2: C;
                                               (02699) (C3: C;
                                               (02700) (M2: M;
                                               (02701) (M3: M;
                                               (02702) 
                                               (02703) (C4: C;
                                               (02704) (C5: C;
                                               (02705) (C6: C;
                                               (02706) (C7: C;
                                               (02707) (R4: R;
                                               (02708) (R5: R;
                                               (02709) (R6: R;
                                               (02710) (R7: R;
                                               (02711) (RW4: RW;
                                               (02712) (RW5: RW;
                                               (02713) (RW6: RW;
                                               (02714) (RW7: RW;
                                               (02715) (M4: M;
                                               (02716) (M5: M;
                                               (02717) (M6: M;
                                               (02718) (M7: M;
                                               (02719) (4: ''
                                               (02720) (5: ''
                                               (02721) (6: ''
                                               (02722) (7: ''
                                               (02723) 
                                               (02724) (-------------------------------------------------------------------------------
                                               (02725) (-------------------------------------------------------------------------------
                                               (02726) (-------------------------------------------------------------------------------
                                               (02727) (MORE OBSOLETE DEFINITIONS
                                               (02728) (-------------------------------------------------------------------------------
                                               (02729) (Preselect GAS:
                                               (02730) PRESELECT: 'PRESELECT'
                                               (02731) PRESELECTGR:     ''
                                               (02732) PRESELECTSB: 	 ''
                                               (02733) PRESELECTMSTACK: ''
                                               (02734) PRESELECTPSTACK: ''
                                               (02735) PRESELECTRSTACK: ''
                                               (02736) PRESELECTLSTACK: ''
                                               (02737) (-------------------------------------------------------------------------------
                                               (02738) (---------    E N D    O F    D E F I N I T I O N S   --------------------------
                                               (02739) (-------------------------------------------------------------------------------
                                               (02740) 
FILE: Tmpgm/Definitions_VE.mas
                                               (00001) WR_NON_ACT:             REG_WRITE := 0;
                                               (00002) WR_RE_START_ADDR_L:     REG_WRITE := 1;  ( // write left starting address of receive engine
                                               (00003) WR_RE_START_ADDR_R:     REG_WRITE := 2;  ( // write right starting address of recieve engine
                                               (00004) WR_RE_LC:               REG_WRITE := 3;  ( // write receive engine's loop counter
                                               (00005) WR_DFY_ADDR_A:          REG_WRITE := 4;  ( // push back address from DFY, A mode
                                               (00006) WR_DFY_ADDR_B:          REG_WRITE := 5;  ( // push back address from DFY, B mode
                                               (00007) WR_VE_START_ADDR_L:     REG_WRITE := 6;  ( // vector engine's left starting address
                                               (00008) WR_VE_START_ADDR_R:     REG_WRITE := 7;  ( // vector engine's right starting address
                                               (00009) WR_VE_LC:               REG_WRITE := 8;  ( // vector engine's loop counter
                                               (00010) WR_VE_OFFSET_L:         REG_WRITE := 9;  ( // left offset
                                               (00011) WR_VE_OFFSET_R:         REG_WRITE := A;  ( // right offset
                                               (00012) WR_VE_DEPTH_L:          REG_WRITE := B;  ( // left depth
                                               (00013) WR_VE_JUMP_L:           REG_WRITE := C;  ( // left jump
                                               (00014) WR_DFY_REG_SING:        REG_WRITE := D;  ( // write individual 8bit registers using the destination field.
                                               (00015) WR_DFY_FROM_MAC_ALL:    REG_WRITE := E;  ( // write all outputs from the macs to DFY.
                                               (00016) WR_DTM_REG_SING:        REG_WRITE := F;  ( // write single byte to DTM. Write in top byte and it is shifted down. Y->3->2->1->0.
                                               (00017) WR_VE_OUTER_LC:         REG_WRITE := 10; ( // write the outer loopcounter.
                                               (00018) WR_VE_LOOP_CFG:         REG_WRITE := 11; ( // write the configuration for auto restart of loop.
                                               (00019) WR_RING_END:            REG_WRITE := 12; ( // write the end address of ring mode operations. This address is non inclusive!
                                               (00020) WR_RING_START:          REG_WRITE := 13; ( // write the ring start and also sets the current ringAddress.
                                               (00021) WR_ZP_DATA:             REG_WRITE := 14; ( //
                                               (00022) WR_ZP_WEIGHT:           REG_WRITE := 15; ( //
                                               (00023) WR_SCALE_FACTOR:        REG_WRITE := 16; ( //
                                               (00024) WR_POST_ENABLE:         REG_WRITE := 17; ( //
                                               (00025) WR_BIAS_DATA_END:       REG_WRITE := 18; ( //
                                               (00026) WR_BIAS_DATA_START:     REG_WRITE := 19; ( // This should also write the current bias idx.
                                               (00027) 
                                               (00028) (( WR_CURRENT_BIAS_IDX:    REG_WRITE := 1B; (( //
                                               (00029) 
                                               (00030) 
                                               (00031) WR_REG_1B:              REG_WRITE := 1B; (( //
                                               (00032) WR_REG_1C:              REG_WRITE := 1C; (( //
                                               (00033) WR_REG_1D:              REG_WRITE := 1D; (( //
                                               (00034) WR_REG_1E:              REG_WRITE := 1E; (( //
                                               (00035) 
                                               (00036)            (( More registers needs to be added for alternative addressing mode..
                                               (00037) 
                                               (00038) WR_MAC_SWITCH:          REG_WRITE := 1F; ( // write the multiplier control register
                                               (00039) 
                                               (00040) VE_RELOAD_L:            ADDR_VE_RELOAD := 1, MODE_A := 1, MODE_B := 0; (( MODE_C := 0, MODE_D := 0;
                                               (00041) VE_RELOAD_R:            ADDR_VE_RELOAD := 1, MODE_A := 0, MODE_B := 1; (( MODE_C := 0, MODE_D := 0;
                                               (00042) VE_RELOAD_BOTH:         ADDR_VE_RELOAD := 1, MODE_A := 1, MODE_B := 1; (( MODE_C := 0, MODE_D := 0;
                                               (00043) 
                                               (00044) VE_RELOAD_LC:           ADDR_VE_RELOAD := 1; (( Added to allow for seperate loading of loop counter without affecting addresses..
                                               (00045) 
                                               (00046) VE_RINGMODE:            MODE_C :=1;
                                               (00047) 
                                               (00048) VE_LATCH_AND_CLEAR:     ACCTOREG :=1, CLR_ACC :=1;
                                               (00049) VE_LATCH:               ACCTOREG :=1;
                                               (00050) VE_CLEAR:               CLR_ACC :=1;
                                               (00051) VE_START:               VE_ST := 1;
                                               (00052) 
                                               (00053) RE_PUSHBACK_RINGMODE:   RE_DFY_SRC := 1, ADDR_RE_RELOAD := 0, MODE_A := 0, MODE_B := 0, MODE_C := 1, MODE_D := 0, RCV_ST := 1;
                                               (00054) 
                                               (00055) RE_PUSHBACK_INIT_A:     RE_DFY_SRC := 1, ADDR_RE_RELOAD := 1, MODE_A := 1, RCV_ST := 0;
                                               (00056) RE_PUSHBACK_INIT_B:     RE_DFY_SRC := 1, ADDR_RE_RELOAD := 1, MODE_B := 1, RCV_ST := 0;
                                               (00057) 
                                               (00058) RE_PUSHBACK_INIT_ST_A:  RE_DFY_SRC := 1, ADDR_RE_RELOAD := 1, MODE_A := 1, RCV_ST := 1;
                                               (00059) RE_PUSHBACK_INIT_ST_B:  RE_DFY_SRC := 1, ADDR_RE_RELOAD := 1, MODE_B := 1, RCV_ST := 1;
                                               (00060) 
                                               (00061) RE_PUSHBACK_CONT_A:     RE_DFY_SRC := 1, ADDR_RE_RELOAD := 0, MODE_A := 1, RCV_ST := 1;
                                               (00062) RE_PUSHBACK_CONT_B:     RE_DFY_SRC := 1, ADDR_RE_RELOAD := 0, MODE_B := 1, RCV_ST := 1;
                                               (00063) 
                                               (00064) RE_RECEIVE_RING_MODE:   RE_DFY_SRC := 0, ADDR_RE_RELOAD := 1, MODE_A := 0, MODE_B := 0, MODE_C := 1, MODE_D := 0, RCV_ST := 1;
                                               (00065) 
                                               (00066) RE_RECEIVE_INIT_LEFT:   RE_DFY_SRC := 0, ADDR_RE_RELOAD := 1, MODE_A := 1, RCV_ST := 0;
                                               (00067) RE_RECEIVE_INIT_RIGHT:  RE_DFY_SRC := 0, ADDR_RE_RELOAD := 1, MODE_B := 1, RCV_ST := 0;
                                               (00068) 
                                               (00069) RE_RECEIVE_INIT_ST_LEFT:    RE_DFY_SRC := 0, ADDR_RE_RELOAD := 1, MODE_A := 1, MODE_B := 0, RCV_ST := 1;
                                               (00070) RE_RECEIVE_INIT_ST_RIGHT:   RE_DFY_SRC := 0, ADDR_RE_RELOAD := 1, MODE_A := 0, MODE_B := 1, RCV_ST := 1;
                                               (00071) RE_RECEIVE_INIT_ST_BIAS:    RE_DFY_SRC := 0, ADDR_RE_RELOAD := 1, MODE_A := 1, MODE_B := 1, RCV_ST := 1;
                                               (00072) 
                                               (00073) RE_RECEIVE_CONT_LEFT:   RE_DFY_SRC := 0, ADDR_RE_RELOAD := 0, MODE_A := 1, RCV_ST := 1;
                                               (00074) RE_RECEIVE_CONT_RIGHT:  RE_DFY_SRC := 0, ADDR_RE_RELOAD := 0, MODE_B := 1, RCV_ST := 1;
                                               (00075) 
                                               (00076) WR_DTM_0:               DEST_BYTE := 0, LOAD DTM FROM Y;
                                               (00077) WR_DTM_1:               DEST_BYTE := 1, LOAD DTM FROM Y;
                                               (00078) WR_DTM_2:               DEST_BYTE := 2, LOAD DTM FROM Y;
                                               (00079) WR_DTM_3:               DEST_BYTE := 3, LOAD DTM FROM Y;
                                               (00080) 
                                               (00081) (   This can be used for debug break and other debugging as desired.
                                               (00082) (   Just add codes here. Remove this for production code.
                                               (00083) 
                                               (00084) DEBUG_NOP:              MCLM :=0;
                                               (00085) 
                                               (00086) DEBUG_HALT:             MCLM :=1;
                                               (00087) (( DEBUG_CC_ON:            MCLM :=2;
                                               (00088) (( DEBUG_CC_OFF:           MCLM :=3;
                                               (00089) DEBUG_RE_ON:            MCLM :=4;
                                               (00090) DEBUG_RE_OFF:           MCLM :=5;
                                               (00091) DEBUG_VE_ON:            MCLM :=6;
                                               (00092) DEBUG_VE_OFF:           MCLM :=7;
                                               (00093) DEBUG_FIFO_ON:          MCLM :=8;
                                               (00094) DEBUG_FIFO_OFF:         MCLM :=9;
                                               (00095) DUMP_WORK_REGS:         MCLM :=A;
                                               (00096) DEBUG_FLAGS_ON:         MCLM :=B;
                                               (00097) DEBUG_FLAGS_OFF:        MCLM :=C;
                                               (00098) DEBUG_DSOURCE:          MCLM :=D;
                                               (00099) DEBUG_PUSHBACK_ON:      MCLM :=E;
                                               (00100) DEBUG_PUSHBACK_OFF:     MCLM :=F;
                                               (00101) DEBUG_GMEM_ON:          MCLM :=10;
                                               (00102) DEBUG_GMEM_OFF:         MCLM :=11;
                                               (00103) DEBUG_DY_ON:            MCLM :=12;
                                               (00104) DEBUG_DY_OFF:           MCLM :=13;
                                               (00105) DEBUG_DTM_ON:           MCLM :=14;
                                               (00106) DEBUG_DTM_OFF:          MCLM :=15;
                                               (00107) 
                                               (00108) 
                                               (00109) DEBUG_PW1_DATA:         MCLM :=16;
                                               (00110) DEBUG_SHOW_CLK_E_ON:    MCLM :=17;
                                               (00111) DEBUG_SHOW_CLK_E_OFF:   MCLM :=18;
                                               (00112) 
                                               (00113) (( Allow for diffrent section of statistics.
                                               (00114) DEBUG_CHOOSE_STAT_0:    MCLM := 19; (( Default value..
                                               (00115) DEBUG_CHOOSE_STAT_1:    MCLM := 1A;
                                               (00116) DEBUG_CHOOSE_STAT_2:    MCLM := 1B;
                                               (00117) DEBUG_CHOOSE_STAT_3:    MCLM := 1C;
                                               (00118) DEBUG_CHOOSE_STAT_4:    MCLM := 1D;
                                               (00119) DEBUG_CHOOSE_STAT_5:    MCLM := 1E;
                                               (00120) DEBUG_CHOOSE_STAT_6:    MCLM := 1F;
                                               (00121) DEBUG_CHOOSE_STAT_7:    MCLM := 20;
                                               (00122) 
                                               (00123) 
                                               (00124) CONVOLUTION_DONE_RETURN: MCLM :=FF;
                                               (00125) Convolution_Done_Return: MCLM :=FF;
                                               (00126) PE_RDY:                  MCLM :=2;
                                               (00127) 
                                               (00128) 
                                               (00129) 
                                               (00130) ( IF:        'IF'
                                               (00131) ( IFNOT:     'FN'
                                               (00132) ( IFZERO:    COND:=00 CPOL:=0;      (ZERO FLIPFLOP
                                               (00133) ( FNZERO:    COND:=00 CPOL:=1;
                                               (00134) ( IFCARRY:   COND:=01 CPOL:=0;      (CARRY FLIPFLOP
                                               (00135) ( FNCARRY:   COND:=01 CPOL:=1;
                                               (00136) 
                                               (00137) ( COND_VE_FREE  = 0x20;
                                               (00138) ( COND_VE_INUSE = 0x21;             ( Running = 1
                                               (00139) ( COND_RE_FREE  = 0x22;
                                               (00140) ( COND_RE_INUSE = 0x23;             ( Running = 1
                                               (00141) ( COND_DFM_DATA = 0x24;             ( Data available = 1
                                               (00142) 
                                               (00143) 
                                               (00144) ( CPOL toggle/inverse the bit.
                                               (00145) IFVE_FREE:      C5:=1 COND:=0 CPOL:=0;  ( 32
                                               (00146) IFVE_INUSE:     C5:=1 COND:=0 CPOL:=1;  ( 32
                                               (00147) IFRE_FREE:      C5:=1 COND:=1 CPOL:=0;  ( 33
                                               (00148) IFRE_INUSE:     C5:=1 COND:=1 CPOL:=1;  ( 33
                                               (00149) IFDFM_DATA:     C5:=1 COND:=2 CPOL:=0;  ( 34
                                               (00150) FIFO:           C5:=1 COND:=3 CPOL:=1;  ( 35
                                               (00151) RESUME:         C5:=1 COND:=4 CPOL:=1;  ( 36
                                               (00152) 
                                               (00153) 
                                               (00154) USING_WORK_REG_A_HIGH: A_SRC_HIGH:=1;
                                               (00155) USING_WORK_REG_B_HIGH: B_SRC_HIGH:=1;
                                               (00156) USING_DEST_REG_B_HIGH: B_SRC_HIGH:=1;
FILE: Tmpgm/Depthwise_stride1_1A_short_pp.mas
                                               (00013) 
                                               (00014) (( Up to 32 sections can be used..
                                               (00015) STAT_DEFAULT:           DEBUG_CHOOSE_STAT_0;
                                               (00016) STAT_DATA_LOAD:         DEBUG_CHOOSE_STAT_1;
                                               (00017) STAT_KERNEL_LOAD_1:     DEBUG_CHOOSE_STAT_2;
                                               (00018) STAT_KERNEL_LOAD_2:     DEBUG_CHOOSE_STAT_3;
                                               (00019) STAT_KERNEL_LOAD_3:     DEBUG_CHOOSE_STAT_4;
                                               (00020) STAT_PW1:               DEBUG_CHOOSE_STAT_5;
                                               (00021) STAT_DW:                DEBUG_CHOOSE_STAT_6;
                                               (00022) STAT_PW2:               DEBUG_CHOOSE_STAT_7;
                                               (00023) 
                                               (00024) *PROGRAM*                   (// END of definitions, START of PROGRAM.
FILE: Definitions/AluRegsVe.mas
                                               (00001) ( File: AluRegs.mas
                                               (00002) (
                                               (00003) ( Copyright (C) 2006  Imsys AB.
                                               (00004) ( All rights reserved.
                                               (00005) (
                                               (00006) ( 06-02-06  PA	  Created for GP3000
                                               (00007) ( 06-09-13  PA    Register name changed from TBFLGS to SFR
                                               (00008) (
                                               (00009) (===============================================================================
                                               (00010) (
                                               (00011) (	REGISTER NAMES
                                               (00012) (
                                               (00013) (===============================================================================
                                               (00014) 
                                               (00015) (ADDR   NAME
                                               (00016)  #0:    W0:
                                               (00017)  #1:    W1:
                                               (00018)  #2:    W2:
                                               (00019)  #3:    W3:
                                               (00020)  #4:    W4:
                                               (00021)  #4:    W_T2_DATA_STORAGE_LOW:
                                               (00022)  #4:    W_DATA_OUT_ROW_BASE_LOW:
                                               (00023)  #5:    W5:
                                               (00024)  #5:    W_T2_DATA_STORAGE_HIGH:
                                               (00025)  #5:    W_DATA_OUT_ROW_BASE_HIGH:
                                               (00026)  #6:    W_DATA_OUT_BASE_LOW:
                                               (00027)  #6:    W6:
                                               (00028)  #7:    W_DATA_OUT_BASE_HIGH:
                                               (00029)  #7:    W7:
                                               (00030)  #8:    W8:
                                               (00031)  #8:    W_PW2_LOOPS:
                                               (00032)  #8:    W_MINIMUS_LOOPS:
                                               (00033)  #9:    W9:
                                               (00034)  #9:    W_PW2_KERNELS:    ( Same as the number of kernels?
                                               (00035)  #A:    WA:
                                               (00036)  #A:    W_DW1_SRAM_KERNELS:
                                               (00037)  #B:    WB:
                                               (00038)  #B:    W_PW1_SRAM_KERNELS:
                                               (00039)  #C:    WC:
                                               (00040)  #C:    W_MAJOR_LOOPS:
                                               (00041)  #D:    W_MINOR_LOOPS:
                                               (00042)  #E:    W_ADDR_DATA:
                                               (00043)  #F:    W_INNER_COL:
                                               (00044)  #10:   W_INNER_ROW:
                                               (00045)  #10:   W_INNER_COL_ROW:
                                               (00046)  #11:   W_KERNEL_BASE_LOW:
                                               (00047)  #11:   W_KERNEL_1_BASE_LOW:
                                               (00048)  #12:   W_KERNEL_BASE_HIGH:
                                               (00049)  #12:   W_KERNEL_1_BASE_HIGH:
                                               (00050)  #13:   W_KERNEL_2_BASE_LOW:
                                               (00051)  #14:   W_KERNEL_2_BASE_HIGH:
                                               (00052)  #15:   W_KERNEL_3_BASE_LOW:
                                               (00053)  #15:   W_T2_INNER_OFF:
                                               (00054)  #15:   W_DATA_IN_CURRENT_LOW:
                                               (00055)  #16:   W_DATA_IN_CURRENT_HIGH:
                                               (00056)  #16:   W_KERNEL_3_BASE_HIGH:
                                               (00057)  #17:   W_DATA_IN_CURRENT_BASE_LOW:
                                               (00058)  #18:   W_DATA_IN_CURRENT_BASE_HIGH:
                                               (00059)  #19:   W_ROW_SIZE_LOW:
                                               (00060)  #1A:   W_ROW_SIZE_HIGH:
                                               (00061)  #1B:   W_REQ_SHORT_WORDS:
                                               (00062)  #1C:   W_REQ_CM_ADDR_LOW:
                                               (00063)  #1D:   W_REQ_CM_ADDR_HIGH:
                                               (00064)  #1E:   W_CONV_COL:
                                               (00065)  #1F:   W_CONV_ROW:
                                               (00066) 
                                               (00067) 
                                               (00068) (( Another copy that includes the reg_index
                                               (00069)  #0:    W00:
                                               (00070)  #1:    W01:
                                               (00071)  #2:    W02:
                                               (00072)  #3:    W03:
                                               (00073)  #4:    W04:
                                               (00074)  #4:    W04_T2_DATA_STORAGE_LOW:
                                               (00075)  #4:    W04_DATA_OUT_ROW_BASE_LOW:
                                               (00076)  #5:    W05:
                                               (00077)  #5:    W05_T2_DATA_STORAGE_HIGH:
                                               (00078)  #5:    W05_DATA_OUT_ROW_BASE_HIGH:
                                               (00079)  #6:    W06_DATA_OUT_BASE_LOW:
                                               (00080)  #6:    W06:
                                               (00081)  #7:    W07_DATA_OUT_BASE_HIGH:
                                               (00082)  #7:    W07:
                                               (00083)  #8:    W08:
                                               (00084)  #8:    W08_PW2_LOOPS:
                                               (00085)  #8:    W08_MINIMUS_LOOPS:
                                               (00086)  #9:    W09:
                                               (00087)  #9:    W09_PW2_KERNELS:    ( Same as the number of kernels?
                                               (00088)  #A:    W0A:
                                               (00089)  #A:    W0A_DW1_SRAM_KERNELS:
                                               (00090)  #B:    W0B:
                                               (00091)  #B:    W0B_PW1_SRAM_KERNELS:
                                               (00092)  #C:    W0C:
                                               (00093)  #C:    W0C_MAJOR_LOOPS:
                                               (00094)  #D:    W0D_MINOR_LOOPS:
                                               (00095)  #E:    W0E_ADDR_DATA:
                                               (00096)  #F:    W0F_INNER_COL:
                                               (00097)  #10:   W10_INNER_ROW:
                                               (00098)  #10:   W10_INNER_COL_ROW:
                                               (00099)  #11:   W11_KERNEL_BASE_LOW:
                                               (00100)  #11:   W11_KERNEL_1_BASE_LOW:
                                               (00101)  #12:   W12_KERNEL_BASE_HIGH:
                                               (00102)  #12:   W12_KERNEL_1_BASE_HIGH:
                                               (00103)  #13:   W13_KERNEL_2_BASE_LOW:
                                               (00104)  #14:   W14_KERNEL_2_BASE_HIGH:
                                               (00105)  #15:   W15_KERNEL_3_BASE_LOW:
                                               (00106)  #15:   W15_T2_INNER_OFF:
                                               (00107)  #15:   W15_DATA_IN_CURRENT_LOW:
                                               (00108)  #16:   W16_DATA_IN_CURRENT_HIGH:
                                               (00109)  #16:   W16_KERNEL_3_BASE_HIGH:
                                               (00110)  #17:   W17_DATA_IN_CURRENT_BASE_LOW:
                                               (00111)  #18:   W18_DATA_IN_CURRENT_BASE_HIGH:
                                               (00112)  #19:   W19_ROW_SIZE_LOW:
                                               (00113)  #1A:   W1A_ROW_SIZE_HIGH:
                                               (00114)  #1B:   W1B_REQ_SHORT_WORDS:
                                               (00115)  #1C:   W1C_REQ_CM_ADDR_LOW:
                                               (00116)  #1D:   W1D_REQ_CM_ADDR_HIGH:
                                               (00117)  #1E:   W1E_CONV_COL:
                                               (00118)  #1F:   W1F_CONV_ROW:
                                               (00119) 
FILE: Tmpgm/Depthwise_stride1_1A_short_pp.mas
                                               (00026) (( *INCLUDE* Conv_Bottle_58_58_24_params.mas;
                                               (00027) 
                                               (00028) #0:  SRAM_LEFT_START:
                                               (00029) #0:  SRAM_RIGHT_START:
                                               (00030) 
                                               (00031) #80:    CM_RD_REQ:
                                               (00032) #C0:    CM_WR_REQ:
                                               (00033) #40:    CM_BR_REQ:
                                               (00034) #3:     WR_REQ_SIZE:
                                               (00035) 
                                               (00036) ( The actual bottle neck implementation..
                                               (00037) 
                                               (00038) (((( Parameters to use for this.
                                               (00039) ((#1:  KERNEL_80_IN_ADDR_HIGH:     ( SZ16..
                                               (00040) ((#0:  KERNEL_80_IN_ADDR_LOW:      ( SZ16..
                                               (00041) ((
                                               (00042) ((#1:  KERNEL_64_IN_ADDR_HIGH:     ( SZ16.. Add 80 kernels a 24 bytes divided by 16 to get the offset of 120 = 0x78 long words
                                               (00043) ((#78:  KERNEL_64_IN_ADDR_LOW:      ( SZ16..
                                               (00044) ((
                                               (00045) ((
                                               (00046) #0: DATA_IN_ADDR_LOW:   ( SZ16
                                               (00047) #4: DATA_IN_ADDR_HIGH:  ( SZ16
                                               (00048) 
                                               (00049) ((
                                               (00050) (( This is needed for the loading offset.
                                               (00051) ((#E: INDATA_ROW_SIZE_LOW:        (( SZ16  (58/2+1)*144 / 16 = 270 = 0x10E   LONG_WORDS CM_WORDS
                                               (00052) ((#1: INDATA_ROW_SIZE_HIGH:      ((
                                               (00053) #2D: INDATA_ROW_SIZE_LOW:         (( Shorter variant is 3+2 = 5*144/16 = 45 0x02D CM_WORDS
                                               (00054) #0: INDATA_ROW_SIZE_HIGH:
                                               (00055) ((
                                               (00056) #0:  DATA_OUT_ADDR_LOW:
                                               (00057) #44: DATA_OUT_ADDR_HIGH:
                                               (00058) 
                                               (00059) (( This remains the same when loading 3 pixels.
                                               (00060) #36: LOAD_DATA_SIZE:             (( 144*3/8 = 54 = 0x36
                                               (00061) 
                                               (00062) #9:  COLUMN_OFFSET_LOW:              (( This is the same as the depth.
                                               (00063) #0:  COLUMN_OFFSET_HIGH:              (( This is the same as the depth.
                                               (00064) 
                                               (00065) #A2: LOAD_KERNEL_SIZE:          (( 144*9/8 = 162 = 0xA2 short words.
                                               (00066) 
                                               (00067) #0: KERNEL_BASE_LOW:
                                               (00068) #1: KERNEL_BASE_HIGH:
                                               (00069) 
                                               (00070) #2: BIAS_ADDR_HIGH:
                                               (00071) #0: BIAS_ADDR_LOW:
                                               (00072) #24: BIAS_LEN_SHORT_WORDS:          ( SRAM_WORDS, bias is 16 bit. 144*2/8 = 36 = 0x24  )
                                               (00073) 
                                               (00074) #0000:
                                               (00075) ((  DEBUG_CC_ON;
                                               (00076) ((  DEBUG_FIFO_ON;
                                               (00077) ((  DEBUG_RE_ON;
00: 0100 0000 0000 0068 0062 2406 0AA0 0040/00 (00078)     DEBUG_HALT;
                                               (00079)     (( Turn on all macs.
                                               (00080)     (( DSOURCE CONSTANT FF, PASS D, WR_MAC_SWITCH; (( Enable all macs.
                                               (00081)     (( Set Default Stepping
01: 0000 0120 0000 0068 0062 0506 AAA0 0040/00 (00082)     DSOURCE CONSTANT 1, PASS D,  WR_VE_OFFSET_L;
02: 0000 0140 0000 0068 0062 0506 AAA0 0040/00 (00083)     DSOURCE CONSTANT 1, PASS D,  WR_VE_OFFSET_R;
                                               (00084) 
                                               (00085) (( This values should be taken from parameters in future.
03: 0000 0280 0000 0068 2062 1506 8AA0 41C0/00 (00086)     DSOURCE CONSTANT 3C, PASS D, WR_ZP_DATA;        ((
04: 0000 02A0 0000 0068 0062 0506 CAA0 0140/00 (00087)     DSOURCE CONSTANT 6, PASS D, WR_ZP_WEIGHT;       ((
05: 0000 02C0 0000 0068 0062 0506 8AA0 0140/00 (00088)     DSOURCE CONSTANT 4, PASS D, WR_SCALE_FACTOR;    ((
                                               (00089) 
                                               (00090) (( We should setup and load the bias data too and it is done once.
                                               (00091) (( As usual we start the re-engine in the correct mode and then send's away
                                               (00092) (( the read-request.
                                               (00093) (( Our priming of cm needs to be fixed.
                                               (00094) (( Bias is here loaded at byte addr 0x2000
                                               (00095) 
06: 0000 0300 0000 0068 0066 0506 EAA0 00C0/00 (00096)     DSOURCE CONSTANT 8f, PASS D, WR_BIAS_DATA_END;                  (( Up to 144 elements..
07: 0000 0320 0000 0068 0062 0506 8AA0 0040/00 (00097)     DSOURCE CONSTANT 0, PASS D, WR_BIAS_DATA_START;
                                               (00098) 
08: 0000 0060 0000 006A 206B 0504 8AA0 4142/00 (00099)     DSOURCE LABEL BIAS_LEN_SHORT_WORDS, PASS D TO W_REQ_SHORT_WORDS, WR_RE_LC;
09: 0000 0000 0000 004A 004B 0506 8AA0 0042/00 (00100)     DSOURCE LABEL BIAS_ADDR_LOW,     PASS D TO W_REQ_CM_ADDR_LOW;            (// CM_LOW
0A: 0000 0000 0000 004A 006B 0506 CAA0 0042/00 (00101)     DSOURCE LABEL BIAS_ADDR_HIGH,    PASS D TO W_REQ_CM_ADDR_HIGH;           (// CM_HIGH
0B: 0000 001E 0000 0068 0062 2406 0AA0 0040/00 (00102)     RE_RECEIVE_INIT_ST_BIAS;
                                               (00103) 
0C: 0000 0000 0000 0068 0862 2422 0FA2 8078/00 (00104)     UNC DO SEND_READ_REQ;  (( Trashes W0
                                               (00105)     (( Wait after to simplify and keep it easy.
                                               (00106)     WAIT_RE_LD_BIAS:
0D: 0008 0000 0000 0068 2062 6022 0BA0 8050/00 (00107)         GOTO WAIT_RE_LD_BIAS IF RE_INUSE;
                                               (00108) 
                                               (00109) 
                                               (00110)     (( DW: Set the base address to point to the current column to process.
                                               (00111)     (( This is incremented by one for each new column.
0E: 0000 0000 0000 0062 006B 0506 8AA0 0042/00 (00112)     DSOURCE LABEL DATA_IN_ADDR_LOW, PASS D TO W17_DATA_IN_CURRENT_BASE_LOW;
0F: 0000 0000 0000 004A 004B 0504 8AA0 0142/00 (00113)     DSOURCE LABEL DATA_IN_ADDR_HIGH, PASS D TO W18_DATA_IN_CURRENT_BASE_HIGH;
                                               (00114) 
                                               (00115)     (( DW: This is used for incrementing the rows in the column that is used.
10: 0000 0000 0000 1042 006B 2406 8AA4 0012/00 (00116)     ASOURCE W17_DATA_IN_CURRENT_BASE_LOW PASS A TO W15_DATA_IN_CURRENT_LOW;
11: 0000 0000 0000 1062 0009 2406 80A4 0052/00 (00117)     ASOURCE W18_DATA_IN_CURRENT_BASE_HIGH PASS A TO W16_DATA_IN_CURRENT_HIGH;
                                               (00118) 
                                               (00119)     (( Base address for the data out. This should be incremented with 1 word or so after
                                               (00120)     (( each column is done.
12: 0000 0000 0000 0022 004B 0506 8A80 0042/00 (00121)     DSOURCE LABEL DATA_OUT_ADDR_LOW  PASS D TO W06_DATA_OUT_BASE_LOW;
13: 0000 0000 0000 0022 006B 0506 8AC0 0142/00 (00122)     DSOURCE LABEL DATA_OUT_ADDR_HIGH PASS D TO W07_DATA_OUT_BASE_HIGH;
                                               (00123) 
                                               (00124)    (( This is incremented with the offset of one row.
14: 0000 0000 0000 1002 0049 2406 8804 0012/00 (00125)     ASOURCE W06_DATA_OUT_BASE_LOW  PASS A TO W04_DATA_OUT_ROW_BASE_LOW;
15: 0000 0000 0000 1002 006B 2406 8A04 0012/00 (00126)     ASOURCE W07_DATA_OUT_BASE_HIGH PASS A TO W05_DATA_OUT_ROW_BASE_HIGH;
                                               (00127) 
16: 0000 0000 0000 0042 006B 0504 8AA0 0042/00 (00128)     DSOURCE LABEL KERNEL_BASE_LOW, PASS D TO W11_KERNEL_BASE_LOW;
17: 0000 0000 0000 0062 004B 0504 AAA0 0042/00 (00129)     DSOURCE LABEL KERNEL_BASE_HIGH, PASS D TO W12_KERNEL_BASE_HIGH;
18: 0000 0000 0000 0068 0062 2422 8EA2 A060/00 (00130)     UNC DO LOAD_KERNELS; (( This can possible be done once..
                                               (00131) 
                                               (00132) 
                                               (00133)     (( Ring mode needs a start address wich can be zero.
                                               (00134)     (( It also needs an end address wich is 9*144 bytes or 1296 bytes = 162 short words = 0xA2
19: 0000 0260 0000 0068 0062 0506 8AA0 0040/00 (00135)     DSOURCE CONSTANT 0, PASS D, WR_RING_START;
1A: 0000 0240 0000 0068 2066 0506 CAA0 4140/00 (00136)     DSOURCE CONSTANT A2, PASS D, WR_RING_END;
                                               (00137) 
1B: 0000 0000 0000 006A 004B 0506 EAA0 0042/00 (00138)     DSOURCE CONSTANT 3, PASS D TO W1E_CONV_COL;  (( Do 28 Columns out!  ==> changed to 3 for short version.
                                               (00139) 
                                               (00140) ((    DSOURCE CONSTANT 11, PASS D, WR_POST_ENABLE;  (( Enable parallell output and writing dtm_data_reg. bit 4='1', 3='0' ,0='1'
1C: 0000 02E0 0000 0068 2066 1506 AAE0 4140/00 (00141)     DSOURCE CONSTANT F1, PASS D, WR_POST_ENABLE;    (( Enable parallell output and writing dtm_data_reg Full automation..
                                               (00142) 
                                               (00143) COL_LOOP:
                                               (00144) 
1D: 0000 0260 0000 0068 0062 0506 8AA0 0040/00 (00145)     DSOURCE CONSTANT 0, PASS D, WR_RING_START;      (( Ensure we have a good ring start.
1E: 0000 0000 0000 1042 006B 2406 8AA4 0012/00 (00146)     ASOURCE W17_DATA_IN_CURRENT_BASE_LOW PASS A TO W15_DATA_IN_CURRENT_LOW;
1F: 0000 0000 0000 1062 0009 2406 80A4 0052/00 (00147)     ASOURCE W18_DATA_IN_CURRENT_BASE_HIGH PASS A TO W16_DATA_IN_CURRENT_HIGH;
                                               (00148) 
                                               (00149)     (( Update this to point to the next column. The offset to the next column is
                                               (00150)     (( Just 144 bytes. Since it is a CMEM offset we add 144/16 = 9.
20: 0000 0000 0000 1062 006B 0406 2AA0 0090/00 (00151)     DSOURCE LABEL COLUMN_OFFSET_LOW,   ASOURCE W17_DATA_IN_CURRENT_BASE_LOW, ADD AD, BDEST W17_DATA_IN_CURRENT_BASE_LOW, LOAD CZ ARI, RAM;  (( This value should be added to W3,W2
21: 0000 0000 0000 904A 0009 0404 00B0 0252/00 (00152)     DSOURCE LABEL COLUMN_OFFSET_HIGH,  ASOURCE W18_DATA_IN_CURRENT_BASE_HIGH, ADDREGCARRY AD, BDEST W18_DATA_IN_CURRENT_BASE_HIGH, RAM;
                                               (00153) 
                                               (00154)     (( Pre load into the ring with two rows a 3 pixels.
22: 0000 0000 0000 0068 0062 2422 0FA2 8070/00 (00155)     UNC DO LOAD_THREE_PIX;
23: 0000 0000 0000 0068 0062 2422 0FA2 8070/00 (00156)     UNC DO LOAD_THREE_PIX;
                                               (00157) 
                                               (00158) 
24: 0000 0000 0000 006A 006B 0506 CAA0 0142/00 (00159)    DSOURCE CONSTANT 6, PASS D TO W1F_CONV_ROW;  (( Do 56 Rows, changed to 6 rows for short version.
                                               (00160)    ((DSOURCE CONSTANT 2, PASS D TO W1F_CONV_ROW;  (( Do 2 rows for testing
                                               (00161) 
                                               (00162) 
                                               (00163) ROW_LOOP:
25: 0000 0000 0000 0068 0062 2422 0FA2 8070/00 (00164)     UNC DO LOAD_THREE_PIX;
26: 0000 0000 0000 0068 0862 2402 AAA0 A468/00 (00165)     UNC DO DEPTHWISE;   (( Do 144 channels and write it out..
                                               (00166) 
                                               (00167) (( Here a row is done and we point the out put to the next row.
                                               (00168) (( Relatively the current out address is already consumed. So subtract one from the actual row-size.
                                               (00169) 
                                               (00170)     (( Once one point is done the offset for data out should be incremented by 28-1 pixel = 27*144 bytes.
                                               (00171)     (( 3888 = 0xF3
                                               (00172)     (( Changed to 3-1 = 288 bytes = 0x120. = 0x12 CM-Words. I.e we skip the next two pixels.
27: 0000 0000 0000 1002 0049 1406 4000 0010/00 (00173)     DSOURCE CONSTANT 12, ASOURCE W04_DATA_OUT_ROW_BASE_LOW,  ADD AD, BDEST W04_DATA_OUT_ROW_BASE_LOW, LOAD CZ ARI, RAM;
28: 0000 0000 0000 9002 006B 0406 0210 0212/00 (00174)     DSOURCE CONSTANT 0, ASOURCE W05_DATA_OUT_ROW_BASE_HIGH, ADDREGCARRY AD, BDEST W05_DATA_OUT_ROW_BASE_HIGH, RAM;
                                               (00175) 
29: 0000 0000 0000 106A 0063 2506 0AA4 0052/00 (00176)     ASOURCE W1F_CONV_ROW, DECR A, TO W1F_CONV_ROW;
2A: 0000 0000 0000 4068 2062 2022 2BA0 8440/00 (00177)     GOTO ROW_LOOP IF NOT FZ;
                                               (00178) 
                                               (00179) (( Here all rows are done!
                                               (00180) 
                                               (00181) (( When all rows are done we should move to the next column.
2B: 0000 0000 0000 1022 0049 0406 2800 0092/00 (00182)     DSOURCE CONSTANT 9, ASOURCE W06_DATA_OUT_BASE_LOW, ADD AD TO W06_DATA_OUT_BASE_LOW; (( Increment to next column.. Actually 144 bytes.
2C: 0000 0000 0000 9022 006B 0406 0A10 0212/00 (00183)     DSOURCE CONSTANT 0, ASOURCE W07_DATA_OUT_BASE_HIGH, ADDREGCARRY AD TO W07_DATA_OUT_BASE_HIGH; (( Increment to next column.. Actually 144 bytes.
                                               (00184) (( Transfer this to the running pointer.
2D: 0000 0000 0000 1002 0049 2406 8804 0012/00 (00185)     ASOURCE W06_DATA_OUT_BASE_LOW PASS A TO W04_DATA_OUT_ROW_BASE_LOW;
2E: 0000 0000 0000 1002 006B 2406 8A04 0012/00 (00186)     ASOURCE W07_DATA_OUT_BASE_HIGH PASS A TO W05_DATA_OUT_ROW_BASE_HIGH;
                                               (00187) 
                                               (00188) (( And restart with a new column.
                                               (00189) 
2F: 0000 0000 0000 106A 0041 2506 08A4 0052/00 (00190)     ASOURCE W1E_CONV_COL, DECR A, TO W1E_CONV_COL;
30: 0000 0000 0000 4068 2862 2022 0BA0 8058/00 (00191)     GOTO COL_LOOP IF NOT FZ;
                                               (00192) 
                                               (00193) STOP_x:
31: 0200 0000 0000 0068 0862 2402 2BA0 8448/00 (00194)     PE_RDY, UNC GOTO STOP_x;
                                               (00195) 
                                               (00196) (( ***************************************************************************************************
                                               (00197) (( *********************************** SUBROUTINES BELOW *********************************************
                                               (00198) (( ***************************************************************************************************
                                               (00199) (( This is dependent on the number of channels to do.
                                               (00200) DEPTHWISE: (( Only one point to do.
                                               (00201) (( Depthwise here should do totally 144 channels and it can do 8 channels at a time.
                                               (00202) (( It needs to write out 16 channels and 144/16 = 9, so 9 major loops and each
                                               (00203) (( major loop do two minimus loops.
32: 0000 0000 0000 000A 004B 0506 AA80 00C2/00 (00204)     DSOURCE CONSTANT 9, PASS D TO W0C_MAJOR_LOOPS;
33: 0000 0000 0000 0002 006B 0504 8A80 0042/00 (00205)     DSOURCE CONSTANT 0, PASS D TO W1;                               (( Set Level/depth to 0  // This should be incremented later..
34: 0000 00E0 0000 1068 0022 2406 82A4 0010/00 (00206)     ASOURCE W11_KERNEL_BASE_LOW, PASS A, WR_VE_START_ADDR_R;        (( Kernel starts. This is really a CM Address! ??
                                               (00207)                                                                     (( It can be reused though but really wrong.
35: 0000 0802 0000 0068 0062 2406 0AA0 0040/00 (00208)     VE_RELOAD_R;
                                               (00209) 
                                               (00210) ((  Ring Mode Address is used for the left side.
36: 0000 0120 0000 0068 0062 1506 CAA0 0040/00 (00211)     DSOURCE CONSTANT 12, PASS D, WR_VE_OFFSET_L;      (( The data stepping should be 18 short words.. Why?
                                               (00212)                                                       (( We have loaded all incoming channels for this 9 pixels. Thats why!
                                               (00213)                                                       (( 144 channels is 18*8 rounds.
37: 0000 0100 0000 0068 0062 0506 AAA0 00C0/00 (00214)     DSOURCE CONSTANT 9, PASS D, WR_VE_LC;
                                               (00215) 
                                               (00216) (( It would be interesting to analyse if we could use outer looping here.
                                               (00217) DW_MAJOR_LOOP:
                                               (00218) 
                                               (00219)     (( The VE must use ringmode here and thus needs layered data execution.
38: 0000 0160 0000 1068 0022 2406 8224 0010/00 (00220)     ASOURCE W1, PASS A, WR_VE_DEPTH_L;                (( Write our current level/depth.
39: 0000 0000 0000 9002 002B 2504 0214 0012/00 (00221)     ASOURCE W1, INCR A TO W1;                         (( Increment Level/depth with 1 for the next round.
                                               (00222) 
                                               (00223) (( *************************** Try to use full automation here ********************************
3A: 0000 0000 0000 0068 0862 2422 0FA2 8068/00 (00224)     UNC DO MAKE_WR_REQ_RESULT;
                                               (00225) 
3B: 0000 0800 F000 0068 0062 2406 0AA0 0040/00 (00226)     VE_RELOAD_LC, VE_LATCH_AND_CLEAR, VE_START, VE_RINGMODE;    (( Ensure ringmode is activated. Kernel pointer and loopcounter still set.
                                               (00227) WAIT_VE_DW1:
3C: 0008 0000 0000 0068 2862 2022 2AA0 8458/00 (00228)     GOTO WAIT_VE_DW1 IF VE_INUSE;
                                               (00229)                                                                 (( Now it is passed to the pipeline directly.
3D: 0000 0160 0000 1068 0022 2406 8224 0010/00 (00230)     ASOURCE W1, PASS A, WR_VE_DEPTH_L;                          (( Set next Level and increment.
3E: 0000 0000 0000 9002 002B 2504 0214 0012/00 (00231)     ASOURCE W1, INCR A TO W1;
                                               (00232) 
3F: 0000 0800 F000 0068 0062 2406 0AA0 0040/00 (00233)     VE_RELOAD_LC, VE_LATCH_AND_CLEAR, VE_START, VE_RINGMODE;        ((  Here we start the next round.
                                               (00234) WAIT_VE_DW2:
40: 0008 0000 0000 0068 2062 2002 0EA2 8040/00 (00235)     GOTO WAIT_VE_DW2 IF VE_INUSE;                                   (( When the second round is finished we
                                               (00236)                                                                     (( continue to pick up the last bytes.
41: 0000 0000 0000 100A 0041 2506 0004 0052/00 (00237)     ASOURCE W0C_MAJOR_LOOPS, DECR A TO W0C_MAJOR_LOOPS;
42: 0000 0000 0000 4068 2862 2002 2AA0 8458/00 (00238)     GOTO DW_MAJOR_LOOP IF NOT FZ;
                                               (00239) 
                                               (00240) (( Here it is expected that the VE signals the core when the VE is ready and thus we don't need to do anything here.
                                               (00241) 
43: 0000 0160 0000 0068 0062 0506 8AA0 0040/00 (00242)     DSOURCE CONSTANT 0, PASS D, WR_VE_DEPTH_L;
44: 0000 0120 0000 0068 0062 0506 AAA0 0040/00 (00243)     DSOURCE CONSTANT 1, PASS D, WR_VE_OFFSET_L;      (( Restore the data stepping to 1..
45: 0000 0000 0000 0068 0062 2406 0AA0 0060/00 (00244)     UNC RETURN;
                                               (00245) 
                                               (00246) 
                                               (00247) (( Load 144 kernels a 9 bytes each.
                                               (00248) (( Number of short words is 162 = 0xA2
                                               (00249) 
                                               (00250) LOAD_KERNELS:
                                               (00251) 
46: 0000 0060 0000 006A 206F 0504 CAA0 4142/00 (00252)     DSOURCE LABEL LOAD_KERNEL_SIZE, PASS D TO W1B_REQ_SHORT_WORDS, WR_RE_LC;    (( It is okay to write the external registers even if the engine isrunning.
47: 0000 0000 0000 104A 000B 2406 82A4 0012/00 (00253)     ASOURCE W11_KERNEL_BASE_LOW,  PASS A TO W1C_REQ_CM_ADDR_LOW;
48: 0000 0000 0000 104A 0029 2406 88A4 0012/00 (00254)     ASOURCE W12_KERNEL_BASE_HIGH, PASS A TO W1D_REQ_CM_ADDR_HIGH;
                                               (00255) 
49: 0000 0040 0000 0068 0062 0506 8AA0 0040/00 (00256)     DSOURCE CONSTANT 0, PASS D, WR_RE_START_ADDR_R;
4A: 0000 001A 0000 0068 0862 2422 0FA2 8078/00 (00257)     RE_RECEIVE_INIT_ST_RIGHT, UNC DO SEND_READ_REQ;  (( Trashes W0
                                               (00258) 
                                               (00259)     WAIT_RE_3:
4B: 0008 0000 0000 0068 2062 6002 8FA2 A050/00 (00260)         GOTO WAIT_RE_3 IF RE_INUSE;
                                               (00261) 
4C: 0000 0000 0000 0068 0062 2406 0AA0 0060/00 (00262)     UNC RETURN;
                                               (00263) 
                                               (00264) 
                                               (00265) LOAD_THREE_PIX:
                                               (00266) 
4D: 0000 0060 0000 006A 206B 1504 CAA0 4142/00 (00267)     DSOURCE LABEL LOAD_DATA_SIZE, PASS D TO W_REQ_SHORT_WORDS, WR_RE_LC;
                                               (00268) 
4E: 0000 0000 0000 104A 004B 2406 82A4 0012/00 (00269)     ASOURCE W15_DATA_IN_CURRENT_LOW,     PASS A TO W_REQ_CM_ADDR_LOW;            (// CM_LOW
4F: 0000 0000 0000 104A 0069 2406 88A4 0012/00 (00270)     ASOURCE W16_DATA_IN_CURRENT_HIGH,    PASS A TO W_REQ_CM_ADDR_HIGH;           (// CM_HIGH
50: 0000 0018 1000 0068 0862 2422 0FA2 8078/00 (00271)     RE_RECEIVE_RING_MODE, UNC DO SEND_READ_REQ;  (( Trashes W0
                                               (00272) 
                                               (00273)     (( Wait after to simplify and keep it easy.
                                               (00274)     WAIT_RE_LTP:
51: 0008 0000 0000 0068 2862 6002 0FA2 8048/00 (00275)         GOTO WAIT_RE_LTP IF RE_INUSE;
                                               (00276) 
                                               (00277)     ((  Add the row offset to this
52: 0000 0000 0000 1042 206B 0406 22A0 4190/00 (00278)     DSOURCE LABEL INDATA_ROW_SIZE_LOW,   ASOURCE W15_DATA_IN_CURRENT_LOW, ADD AD, BDEST W15_DATA_IN_CURRENT_LOW, LOAD CZ ARI, RAM;  (( This value should be added to W3,W2
53: 0000 0000 0000 9062 0049 0406 08B0 0212/00 (00279)     DSOURCE LABEL INDATA_ROW_SIZE_HIGH,  ASOURCE W16_DATA_IN_CURRENT_HIGH, ADDREGCARRY AD, BDEST W16_DATA_IN_CURRENT_HIGH, RAM;
                                               (00280) 
54: 0000 0000 0000 0068 0062 2406 0AA0 0060/00 (00281)     UNC RETURN;
                                               (00282) 
                                               (00283) 
                                               (00284) (( For this Depthwise is should offset with FC0 bytes between each row.
                                               (00285) (( How is the base registers used?
                                               (00286) (( W_DATA_OUT_ROW_BASE_LOW this should be used for the inner offsets..
                                               (00287) MAKE_WR_REQ_RESULT:
55: 0000 0000 0000 0068 0062 2406 0AA0 0040/00 (00288)     DEBUG_NOP;
                                               (00289) (( The above NOP'S. The post-processing is kind of late
                                               (00290) (( and interfere with this writing of DTM.
                                               (00291) 
56: 0000 0000 0000 1068 0060 2C46 8024 0010/00 (00292)     ASOURCE W04_DATA_OUT_ROW_BASE_LOW, PASS A,  WR_DTM_0;    (( Low part of address
57: 0010 0000 0000 1068 0062 2C46 8224 0010/00 (00293)     ASOURCE W05_DATA_OUT_ROW_BASE_HIGH, PASS A, WR_DTM_1;    (( High part of address
58: 0020 0000 0000 0068 0062 0D46 EAA0 0040/00 (00294)     DSOURCE LABEL WR_REQ_SIZE, PASS D,    WR_DTM_2;
59: 0030 0000 0000 0068 0066 0D46 8AE0 0140/00 (00295)     DSOURCE LABEL CM_WR_REQ, PASS D,      WR_DTM_3;    (( Write request.
5A: 0004 0000 0000 0068 0062 2406 0AA0 0040/00 (00296)     FIFO_PUSH := 1;
                                               (00297) 
                                               (00298)     (( This offset is within one pixel I.e Depth..
                                               (00299)     (( Between pixels should be done above.
                                               (00300)     (( If we re-design it can be possible to have this above and thus saving the NOP cycle above.
5B: 0000 0000 0000 1002 0049 0406 2000 0010/00 (00301)     DSOURCE CONSTANT 1, ASOURCE W04_DATA_OUT_ROW_BASE_LOW,  ADD AD, BDEST W04_DATA_OUT_ROW_BASE_LOW, LOAD CZ ARI, RAM;
5C: 0000 0000 0000 9002 006B 0406 0210 0232/00 (00302)     DSOURCE CONSTANT 0, ASOURCE W05_DATA_OUT_ROW_BASE_HIGH, ADDREGCARRY AD, BDEST W05_DATA_OUT_ROW_BASE_HIGH, RAM,
                                               (00303)     UNC RETURN;
                                               (00304) 
                                               (00305) (( ***************************************************************************************************
                                               (00306) SEND_READ_REQ: (( Trashes W0
5D: 0030 0000 0000 0068 0866 0D62 0FA2 A158/00 (00307)     DSOURCE LABEL CM_RD_REQ, PASS D, WR_DTM_3,                      (( Read request.
                                               (00308)     UNC GOTO CONT_READ_REQ;
                                               (00309) 
                                               (00310) (( ***************************************************************************************************
                                               (00311) SEND_BRC_READ_REQ: (( Trashes W0
5E: 0030 0000 0000 0068 0062 0D46 8AE0 0040/00 (00312)     DSOURCE LABEL CM_BR_REQ, PASS D, WR_DTM_3;                      (( Read request.
                                               (00313) CONT_READ_REQ:
5F: 0000 0000 0000 1068 0060 2C46 80A4 0050/00 (00314)     ASOURCE W_REQ_CM_ADDR_LOW,      PASS A, WR_DTM_0;               (( Low part of address  BYTE_SEL = 0;
60: 0010 0000 0000 1068 0062 2C46 82A4 0050/00 (00315)     ASOURCE W_REQ_CM_ADDR_HIGH,     PASS A, WR_DTM_1;               (( High part of address
61: 0000 0000 0000 1080 000B 2404 8A84 0050/00 (00316)     ASOURCE W_REQ_SHORT_WORDS,      BDEST W0, PASS A, RAMRIGHT;     (( Trashes W0
62: 0020 0000 0000 1068 0028 2D46 0024 0010/00 (00317)     ASOURCE W0, DECR A, WR_DTM_2;
                                               (00318) 
63: 0006 0000 0000 0068 0062 2406 0AA0 0060/00 (00319)     FIFO_PUSH := 1, SEND_REQ := 1, UNC RETURN;
                                               (00320) 
100: 0000 0000 0000 0068 0062 2406 0AA0 0040/00 (00321) #FFFF: MCLM := 0;
                                               (00322) *END*
