-----------------------------------------------------------------------
--               Copyright(c) Synopsys, Inc.                           
--     All Rights reserved - Unpublished -rights reserved under        
--     the Copyright laws of the United States of America.             
--                                                                     
--  U.S. Patents: 7,093,156 B1 and 7,406,620 B2 (and more pending).    
--                                                                     
--  This file includes the Confidential information of Synopsys, Inc.  
--  and GLOBALFOUNDRIES.                                               
--  The receiver of this Confidential Information shall not disclose   
--  it to any third party and shall protect its confidentiality by     
--  using the same degree of care, but not less than a reasonable      
--  degree of care, as the receiver uses to protect receiver's own     
--  Confidential Information.                                          
--  Licensee acknowledges and agrees that all output generated for     
--  Licensee by Synopsys, Inc. as described in the pertinent Program   
--  Schedule(s), or generated by Licensee through use of any Compiler  
--  licensed hereunder contains information that complies with the     
--  Virtual Component Identification Physical Tagging Standard (VCID)  
--  as maintained by the Virtual Socket Interface Alliance (VSIA).     
--  Such information may be expressed in GDSII Layer 63 or other such  
--  layer designated by the VSIA, hardware definition languages, or    
--  other formats.  Licensee is not authorized to alter or change any  
--  such information.                                                  
-----------------------------------------------------------------------
--                                                                     
--  Built for linux64 and running on linux64.                          
--                                                                     
--  Software           : Rev: U-2022.12                                
--  Library Format     : Rev: 1.05.00                                  
--  Compiler Name      : gf22nsd42p11s1drl128sa04p1                    
--  Platform           : Linux3.10.0-957.5.1.el7.x86_64                
--                     : #1 SMP Wed Dec 19 10:46:58 EST 2018x86_64     
--  Date of Generation : Fri Dec 09 14:35:33 CET 2022                  
--                                                                     
-----------------------------------------------------------------------
--   --------------------------------------------------------------     
--                       Template Revision : 4.5.4                      
--   --------------------------------------------------------------     
--                 * Synchronous, 2-Port Register File *              
--     WARNING: Ports with underscores not allowed in VITAL models    
--                THIS IS A SYNCHRONOUS 2-PORT MEMORY MODEL           
--                                                                    
--   Memory Name:SNPS_RF_DP_UHD_512x80                                
--   Memory Size:256 words x 80 bits                                  
--                                                                    
--                               PORT NAME                            
--                               ---------                            
--               Output Ports                                         
--                                   QB[79:0]                         
--               Input Ports:                                         
--                                   ADRA[7:0]                        
--                                   DA[79:0]                         
--                                   WEA                              
--                                   MEA                              
--                                   CLKA                             
--                                   TEST1A                           
--                                   TEST_RNMA                        
--                                   RMEA                             
--                                   RMA[3:0]                         
--                                   WA[1:0]                          
--                                   WPULSE[2:0]                      
--                                   LS                               
--                                   ADRB[7:0]                        
--                                   MEB                              
--                                   CLKB                             
--                                   TEST1B                           
--                                   RMEB                             
--                                   RMB[3:0]                         



library IEEE;
use IEEE.std_logic_1164.all;

entity generic_vhd_SNPS_RF_DP_UHD_512x80 is
  generic (
        words             : integer                := 256;
        addrbits          : integer                := 8;
        bits              : integer                := 80;
        NW                : integer                := 1;
        NADDR             : integer                := 1;
        rmbits            : integer                := 3;
        wabits           : integer                 := 2;
        wpulsebits           : integer             := 3;
        MES_CNTRL           : string                := "ON"
   );
   port (
  QB : out std_logic_vector (bits-1 downto 0);
  ADRA : in std_logic_vector (addrbits-1 downto 0);
  DA : in std_logic_vector (bits-1 downto 0);
  WEA : in std_logic;
  MEA : in std_logic;
  CLKA : in std_logic;
  TEST1A : in std_logic;
  TEST_RNMA : in std_logic;
  RMEA : in std_logic;
  RMA : in std_logic_vector (rmbits-1 downto 0);
  WA : in std_logic_vector (wabits-1 downto 0);
  WPULSE : in std_logic_vector (wpulsebits-1 downto 0);
  LS : in std_logic;
  ADRB : in std_logic_vector (addrbits-1 downto 0);
  MEB : in std_logic;
  CLKB : in std_logic;
  TEST1B : in std_logic;
  RMEB : in std_logic;
  RMB : in std_logic_vector (rmbits-1 downto 0);
  t3a_me : in time;
  t3b_me : in time
   );
end generic_vhd_SNPS_RF_DP_UHD_512x80;

architecture behav of generic_vhd_SNPS_RF_DP_UHD_512x80 is
subtype A_WORD is std_logic_vector( bits-1 downto 0 );
TYPE    ram_array is ARRAY  (0 to words -1) of std_logic_vector( bits-1 downto 0 );
SIGNAL  TEMP : A_WORD;
SIGNAL  allx : std_logic_vector( bits-1 downto 0 ) := (others=>'X');
SIGNAL  allz : std_logic_vector( bits-1 downto 0 ) := (others=>'Z');
SIGNAL  ADRA_lat : integer range (2**NADDR)-1 downto 0;

SIGNAL  WEA_old : std_logic;
SIGNAL  MEA_old : std_logic;
SIGNAL  ADRA_old : std_logic_vector(7 downto 0);
SIGNAL  DA_old : std_logic_vector(79 downto 0);
SIGNAL  WA_old : std_logic_vector(1 downto 0);
SIGNAL  WPULSE_old : std_logic_vector(2 downto 0);
SIGNAL  ADRB_lat : integer range (2**NADDR)-1 downto 0;
SIGNAL  QB_tmp : std_logic_vector (bits-1 downto 0);
SIGNAL test1_rd_wr : std_ulogic := '0';
SIGNAL flag_simul_clk : std_ulogic := '0';

SIGNAL  MEB_old : std_logic;
SIGNAL  ADRB_old : std_logic_vector(7 downto 0);
SIGNAL  mes_all_valid : Boolean := false;

--  Address Calculate FUNCTION
function TO_INT( address : std_logic_vector(NADDR-1 downto 0) ) return integer is
  variable add : integer := 0;
begin  
  for index in 0 to NADDR-1 loop
    if( address(index) = '1' ) then
      add := add + (2**index);
    end if;
  end loop;
  return add;
end TO_INT;

function TO_OR(oper : std_logic_vector) return std_logic is
  variable or_bit : std_logic;
begin
  or_bit := '0';
  for i in oper'RANGE loop
    or_bit := or_bit or oper(i);
  end loop;
  return or_bit;
end TO_OR;

begin


-- Latch Syncronous signals

    MEA_old <= MEA;
    ADRA_old <= ADRA;
    DA_old <= DA;
    WEA_old <= WEA;
    WA_old <= WA;
    WPULSE_old <= WPULSE;
    MEB_old <= MEB;
    ADRB_old <= ADRB;


-- Address Calculate
      ADRA_lat <= ADRA_lat when (IS_X(ADRA)) else TO_INT(ADRA_old);
      ADRB_lat <= ADRB_lat when (IS_X(ADRB)) else TO_INT(ADRB_old);


-- Aport Data Output
control_QB:
process( QB_tmp ) begin
-- Normal Mode
   QB <= QB_tmp;
end process;


port_A_B  :
process( CLKA ,DA , TEST1A ,CLKB , TEST1B ,TEST_RNMA, t3a_me, t3b_me)
   VARIABLE RAMDATA_tmp : A_WORD ;
   VARIABLE mem_core_array : ram_array;
   VARIABLE addressax : Boolean := false;
   VARIABLE addressa : integer;
   VARIABLE WEAlatched : std_logic;
   VARIABLE MEAlatched : std_logic;
   VARIABLE ADRAlatched : std_logic_vector(7 downto 0);
   VARIABLE DAlatched : std_logic_vector(79 downto 0);
   VARIABLE WAlatched : std_logic_vector(1 downto 0);
   VARIABLE WPULSElatched : std_logic_vector(2 downto 0);
   VARIABLE diff_me_tcha  : std_ulogic   := '0';
   VARIABLE diff_me_tcca  : std_ulogic   := '0';
   VARIABLE t0a_pfirst : time := 0 ns;
   VARIABLE t1a_pfirst : time := 0 ns;
   VARIABLE t2a_pnow   : time := 0 ns;
   VARIABLE t2a_nnow   : time := 0 ns;

   VARIABLE addressbx : Boolean := false;
   VARIABLE addressb : integer;
   VARIABLE MEBlatched : std_logic;
   VARIABLE ADRBlatched : std_logic_vector(7 downto 0);
   VARIABLE diff_me_tchb  : std_ulogic   := '0';
   VARIABLE diff_me_tccb  : std_ulogic   := '0';
   VARIABLE t0b_pfirst : time := 0 ns;
   VARIABLE t1b_pfirst : time := 0 ns;
   VARIABLE t2b_pnow   : time := 0 ns;
   VARIABLE t2b_nnow   : time := 0 ns;

   VARIABLE CLKA_time : time := 0.0 ns;
   VARIABLE TEST1Alatched : std_ulogic := '0';
   VARIABLE TEST_RNMAlatched : std_ulogic := '0';
   VARIABLE QB_temp : std_logic_vector (bits-1 downto 0);
   VARIABLE CLKB_time : time := 0.0 ns;
   VARIABLE TEST1Blatched : std_ulogic := '0';
   VARIABLE memdata_bef_wrt : std_logic_vector (79 downto 0);
   VARIABLE bit_corrupt : std_logic_vector (79 downto 0);

function local_slr ( oper : STD_LOGIC_VECTOR; count : NATURAL) return STD_LOGIC_VECTOR is
   variable temp_oper : STD_LOGIC_VECTOR(oper'range) := oper;
   variable value : STD_LOGIC_VECTOR(oper'range);
 begin
  value(oper'Left+count-1 downto oper'Left) := ( others => '0');
  value(oper'Left-count downto oper'Right) := oper(oper'Left downto oper'Right+count);
  return (value);
 end local_slr;

function to_unsigned_integer (oper : STD_LOGIC_VECTOR) return INTEGER is
 variable value : INTEGER := 0;
 variable temp_no : INTEGER := 1;
 variable temp_oper : STD_LOGIC_VECTOR(oper'range) := oper;
 variable INDEX : INTEGER := 1;
 begin
  if ( MES_CNTRL="ON" or MES_CNTRL="WARN") then
  assert oper'length <= 31
  report "<<VIRL_MEM_WARNING: argument is too large in TO_INTEGER, only lower 31 bits will be taken>>"
  severity note;
  end if;
  if (not (Is_X(oper))) then
   for I in temp_oper'reverse_range loop
    case (temp_oper(I)) is
     when '1' =>
      value := value + temp_no;
     when others =>
      null;
    end case;
    INDEX := INDEX + 1;
    exit when INDEX > 31;
    temp_no := temp_no + temp_no;
   end loop;
  else
    if ( MES_CNTRL="ON" or MES_CNTRL="WARN") then
   assert FALSE report "<<VIRL_MEM_WARNING: Illegal value detected in conversion TO_unsigned_INTEGER>>" severity note;
   end if;
  value := 0;
  end if;
  return (value);
 end to_unsigned_integer;

function to_std_logicvector (oper,no_of_bits : NATURAL) return STD_LOGIC_VECTOR is
 variable temp_oper : NATURAL := 0;
 variable vect : STD_LOGIC_VECTOR(no_of_bits-1 downto 0) := (others => '0');
 begin
  temp_oper := oper;
  for i in vect'reverse_range loop
   if ((temp_oper mod 2) = 1) then
    vect(i) := '1';
   else
    vect(i) := '0';
   end if;
   temp_oper := temp_oper/2;
  end loop;
  return (vect);
 end to_std_logicvector;

procedure trash_mem(mem_core_array : inout ram_array) is
 variable word_line : std_logic_vector (79 downto 0);
 begin
  for i in 0 to 255 loop
   word_line := mem_core_array(i);
   for j in 0 to 79 loop
    word_line(j) := 'X';
   end loop;
   mem_core_array(i) := word_line;
  end loop;
 end;
 




procedure corrupt_cur_loc(mem_core_array : inout ram_array; Adr : in NATURAL) is
 variable word_line : std_logic_vector (79 downto 0);
 begin
  word_line := mem_core_array(Adr);
  for i in 0 to 79 loop
   word_line(i) := 'X';
  end loop;
  mem_core_array(Adr) := word_line;
 end;

 
-- function for sll operation ( Modelsim Requirement)

   function local_sll ( oper : STD_LOGIC_VECTOR; count : NATURAL) return STD_LOGIC_VECTOR is
        variable temp_oper : STD_LOGIC_VECTOR(oper'range) := oper;
        variable value : STD_LOGIC_VECTOR(oper'range);
    begin
     value(oper'Right+count-1 downto oper'Right) := ( others => '0');
     value(oper'Left downto oper'Right+count) := oper(oper'Left-count downto oper'Right);
     return (value);
    end local_sll;
 
-- function for sla operation ( Modelsim Requirement)
 
   function local_sla ( oper : BIT_VECTOR; count : NATURAL) return BIT_VECTOR is
        variable temp_oper : BIT_VECTOR(oper'range) := oper;
        variable value : BIT_VECTOR(oper'range);
    begin
     value(oper'Right+count-1 downto oper'Right) := ( others => oper(oper'Right));
     value(oper'Left downto oper'Right+count) := oper(oper'Left-count downto oper'Right);
     return (value);
    end local_sla;
 
begin


      -------------------------------------------------
      -------------------------------------------------

  if ( CLKA'event and CLKA /= '0' ) then
    t0a_pfirst := t1a_pfirst;
    t1a_pfirst := t2a_pnow;
    t2a_pnow := now;
    if ((t1a_pfirst < t3a_me) and (t3a_me < t2a_pnow)) then
      diff_me_tcha := '1';
    end if;
    if ((t0a_pfirst < t3a_me) and (t3a_me < t2a_pnow)) then
      diff_me_tcca := '1';
    end if;
  end if;
  if ( CLKA'event and CLKA = '0' ) then
      t2a_nnow := now;
  end if;
  if ( CLKA'event and CLKA /= '1' and CLKA'last_value /= '0' ) then
    diff_me_tcha := '0';
    diff_me_tcca := '0';
  end if;

  if ( t3a_me'event ) then
    if ((t2a_pnow < t3a_me) and (t2a_nnow < t3a_me)) then
      diff_me_tcha := '1';
    end if;
  end if;

-- Normal Mode
-- CLKA 0->X OR X->1 OR 1->X 
 if( (CLKA'event and CLKA'last_value='0' and CLKA='X') and (diff_me_tcha = '1' or MEA /= '0') ) then          -- if CLKA 0->X
    if( (MES_CNTRL= "ON" or MES_CNTRL="ERR") and NOW /= 0 ns and mes_all_valid  ) then
      assert false report "<<VIRL_MEM_ERR: CLKA(0->X) unknown>>" severity note;
    end if;
    trash_mem(mem_core_array);
 elsif( CLKA'event and CLKA'last_value='X' and CLKA='1' and (diff_me_tcha = '1' or MEA /= '0') ) then       -- if CLKA X->1
 elsif( CLKA'event and CLKA'last_value='1' and CLKA='X' and MEA /= '0' ) then       -- if CLKA 1->X
   if( (MES_CNTRL= "ON" or MES_CNTRL="ERR") and NOW /= 0 ns and mes_all_valid  ) then
     assert false report "<<VIRL_MEM_ERR:CLKA(1->X) unknown>>" severity note;
   end if;
   trash_mem(mem_core_array);
 end if;


-- Posedge of CLKA
 if( CLKA'event and CLKA'last_value='0' and CLKA='1' ) then       -- if CLKA 0->1
      CLKA_time := NOW;
       ADRAlatched := TO_X01(ADRA_old);
       MEAlatched := TO_X01(MEA_old);
       WEAlatched := TO_X01(WEA_old);
       DAlatched := TO_X01(DA_old);
       TEST1Alatched := TO_X01(TEST1A);
       WAlatched := TO_X01(WA_old);
       WPULSElatched := TO_X01(WPULSE_old);
       TEST_RNMAlatched := TO_X01(TEST_RNMA);
       if (TEST_RNMAlatched = '1') then
         MEAlatched := '0';
       end if;
       if (LS = 'X' and (MEAlatched /= '0' and WEAlatched /= '0')) then
          if( (MES_CNTRL="ON" or MES_CNTRL="ERR") and NOW /= 0 ns and mes_all_valid  ) then
           assert false report "<<VIRL_MEM_ERR: LS unknown>>" severity note;
          end if;
         trash_mem(mem_core_array);
         QB_tmp <= allx;
       else 
-- Check for ADRA unknown
       if ( IS_X(ADRAlatched) and MEAlatched /= '0' and (MES_CNTRL="ON" or MES_CNTRL="ERR") and NOW /= 0 ns and mes_all_valid  ) then
         assert false report "<<VIRL_MEM_ERR: ADRA unknown>>" severity note;
       end if;
       addressax := IS_X(ADRAlatched);
      if ( not addressax) then
        addressa := to_unsigned_integer(ADRAlatched);
      end if ;                            

-- Normal read/write operation 
-- ME = X
    if( MEAlatched ='X' ) then
      if(( MES_CNTRL="ON" or MES_CNTRL="ERR") and NOW /= 0 ns and mes_all_valid  ) then
        assert false report "<<VIRL_MEM_ERR:MEA unknown>>" severity note;
      end if;
       trash_mem(mem_core_array);
        if( WEAlatched = '1' ) then   -- if Write mode and ME is X
          if( IS_X(ADRAlatched) ) then
          elsif( ADRA_lat >= NW ) then
            if(( MES_CNTRL="ON" or MES_CNTRL="WARN") and mes_all_valid ) then
              assert false report "<<VIRL_MEM_WARNING: ADRA greater fixed WORD space>>" severity note;
            end if;
          else
           if( (MES_CNTRL="ON" or MES_CNTRL="ERR") and NOW /= 0 ns and mes_all_valid ) then
             assert false report "<<VIRL_MEM_ERR: Valid ADRA ,But memory corrupted due to unknown MEA >>" severity note;
           end if;
          end if;
        end if;                      -- end of if write enable and ME is X
    end if;          -- end of if ME X

-- MEA=1  (ME Enable)
    if( MEAlatched ='1' ) then
    if ( WEAlatched='X' ) then     
      if ( IS_X(WAlatched) ) then
        if( (MES_CNTRL="ON" or MES_CNTRL="ERR") and NOW /= 0 ns and mes_all_valid  ) then
          assert false report "<<VIRL_MEM_ERR: WA unknown>>" severity note;
        end if;
        trash_mem(mem_core_array);
      end if;
      if ( IS_X(WPULSElatched) ) then
        if( (MES_CNTRL="ON" or MES_CNTRL="ERR") and NOW /= 0 ns and mes_all_valid  ) then
          assert false report "<<VIRL_MEM_ERR: WPULSE unknown>>" severity note;
        end if;
        trash_mem(mem_core_array);
      end if;
    end if;

-- Memory enable and Write mode 
    if ( WEAlatched='1' ) then     
       if ( IS_X(RMA) ) then 
         if (( MES_CNTRL="ON" or MES_CNTRL="ERR") and NOW /= 0 ns and mes_all_valid and RMEA = '1'  ) then
           assert false report "<<VIRL_MEM_ERR:RMA unknown>>" severity note;
         end if;
         corrupt_cur_loc(mem_core_array,addressa);
       else
        if ( IS_X(TEST1A) ) then
         if(( MES_CNTRL="ON" or MES_CNTRL="ERR") and NOW /= 0 ns and mes_all_valid  ) then
           assert false report "<<VIRL_MEM_ERR: TEST1A unknown - Write mode>>" severity note;
         end if;
         corrupt_cur_loc(mem_core_array,addressa);
        elsif( IS_X(ADRAlatched) ) then    -- if Add X 
         trash_mem(mem_core_array);
        elsif ( IS_X(WAlatched) ) then
          if( (MES_CNTRL="ON" or MES_CNTRL="ERR") and NOW /= 0 ns and mes_all_valid  ) then
            assert false report "<<VIRL_MEM_ERR: WA unknown>>" severity note;
          end if;
          trash_mem(mem_core_array);
        elsif ( IS_X(WPULSElatched) ) then
          if( (MES_CNTRL="ON" or MES_CNTRL="ERR") and NOW /= 0 ns and mes_all_valid  ) then
            assert false report "<<VIRL_MEM_ERR: WPULSE unknown>>" severity note;
          end if;
          trash_mem(mem_core_array);
        elsif ( IS_X(TEST_RNMAlatched) ) then
          if( (MES_CNTRL="ON" or MES_CNTRL="ERR") and NOW /= 0 ns and mes_all_valid  ) then
            assert false report "<<VIRL_MEM_ERR: TEST_RNMA unknown>>" severity note;
          end if;
          trash_mem(mem_core_array);
        elsif( ADRA_lat >= NW ) then    -- else if of Add X
         if( (MES_CNTRL="ON" or MES_CNTRL="WARN") and mes_all_valid ) then
           assert false report "<<VIRL_MEM_WARNING: ADRA greater fixed WORD space>>" severity note;
         end if;
        else                                   -- else of Add X (Memory write)
         if (CLKB = '1' and TEST1Blatched = '1' and (MEAlatched = MEBlatched) and (ADRAlatched = ADRBlatched) ) then
           test1_rd_wr <= '1';
         end if;
          memdata_bef_wrt := mem_core_array(ADRA_lat);
        mem_core_array(ADRA_lat) := DAlatched;
        QB_temp :=  mem_core_array(ADRA_lat);
        mes_all_valid <= true;
          if ( IS_X(DAlatched) and (MES_CNTRL="ON" or MES_CNTRL="ERR") and NOW /= 0 ns and mes_all_valid  ) then
            assert false report "<<VIRL_MEM_ERR:DA unknown>>" severity note;
          end if;
        end if;
       end if;         -- end of RM is X

-- Memory is enable and Write enable is X
    elsif( WEAlatched='X' ) then
      if( (MES_CNTRL="ON" or MES_CNTRL="ERR") and NOW /= 0 ns and mes_all_valid  ) then
        assert false report "<<VIRL_MEM_ERR:WEA unknown>>" severity note;
      end if;

      if( IS_X(ADRAlatched) ) then    -- WE and Add both X
        trash_mem(mem_core_array);
      elsif( ADRA_lat >= NW ) then   -- else if of Add X and WE X
        if(( MES_CNTRL="ON" or MES_CNTRL="WARN") and mes_all_valid ) then
          assert false report "<<VIRL_MEM_WARNING: ADRA greater fixed WORD space>>" severity note;
        end if;
      else      -- else of Add X
        corrupt_cur_loc(mem_core_array,addressa);
      end if;
    end if;
 end if;


     if ( CLKB='1' and CLKB'event and CLKB'last_value = '0' ) then
       if ( not IS_X(ADRAlatched) ) then
         addressa := to_unsigned_integer(ADRAlatched);
       end if;
       if ( not IS_X(ADRB_old) ) then
         addressb := to_unsigned_integer(ADRB_old);
       end if;
     end if;

 if( MEAlatched = '1' and ADRA_lat < NW) then
-- checked activity on A -PORT, simultaneous checking.
-----------------------
-- PORT A is active. --
-----------------------

-- ADRA equal to ADRB
--  and A:WRITE(mem_core_arrayA=DA) / B:READ (out=XXXX)

   if(   CLKB='1' and CLKB'event and CLKB'last_value = '0'     and (
      (MEB_old ='1' and to_unsigned_integer(ADRAlatched) = to_unsigned_integer(ADRB_old)   and WEAlatched = '1') )) then
          if (TEST_RNMAlatched = '1') then
            QB_temp := (mem_core_array(ADRB_lat));
          else
          flag_simul_clk <= '1';
          if (TEST1B = '0') then
            bit_corrupt := memdata_bef_wrt xor DAlatched;
            QB_temp := (allx and bit_corrupt) xor memdata_bef_wrt; 
            QB_tmp <= QB_temp;
           end if;
     end if;    -- end of if TEST_RNMA
     end if;    -- end of if posedge of CLKB and condition for control singlas in two port
   end if;      -- end of if MEAlatched = '1' 

   end if; -- end of else of no power control pin unknown
 end if; -- end of posedge of clock

 if (TEST_RNMA'event and TEST1Alatched = '1' and CLKA = '1' and MEAlatched = '1' and WEAlatched = '1') then
    corrupt_cur_loc(mem_core_array,to_unsigned_integer(ADRAlatched));
 end if;


      if ( TEST1A'event ) then
        if ( TEST1A = '1' ) then
          if ( (MES_CNTRL="ON" or MES_CNTRL="WARN") and NOW /= 0 ns and mes_all_valid) then
          assert FALSE
          report "VIRL_MEM_WARNING: Tcc value in the RAM model is for TEST1A=0,but the input value is TEST1A=1 "
          severity note;
          end if;
        end if;
        if ( CLKA='1' and MEAlatched='1' and (LS='0') ) then
          if ( WEAlatched='1') then
            corrupt_cur_loc(mem_core_array,addressa);
          end if;
          QB_tmp <= allx;
        end if;
      end if;


-- ------------------------------------------- NEXT PORT ------------------
  if ( CLKB'event and CLKB /= '0' ) then
    t0b_pfirst := t1b_pfirst;
    t1b_pfirst := t2b_pnow;
    t2b_pnow := now;
    if ((t1b_pfirst < t3b_me) and (t3b_me < t2b_pnow)) then
      diff_me_tchb := '1';
    end if;
    if ((t0b_pfirst < t3b_me) and (t3b_me < t2b_pnow)) then
      diff_me_tccb := '1';
    end if;
  end if;
  if ( CLKB'event and CLKB = '0' ) then
      t2b_nnow := now;
  end if;
  if ( CLKB'event and CLKB /= '1' and CLKB'last_value /= '0' ) then
    diff_me_tchb := '0';
    diff_me_tccb := '0';
  end if;

  if ( t3b_me'event ) then
    if ((t2b_pnow < t3b_me) and (t2b_nnow < t3b_me)) then
      diff_me_tchb := '1';
    end if;
  end if;

-- Normal Mode
-- CLKB 0->X OR X->1 OR 1->X 
 if( (CLKB'event and CLKB'last_value='0' and CLKB='X') and (diff_me_tchb = '1' or MEB /= '0') ) then          -- if CLKB 0->X
    if( (MES_CNTRL= "ON" or MES_CNTRL="ERR") and NOW /= 0 ns and mes_all_valid  ) then
      assert false report "<<VIRL_MEM_ERR: CLKB(0->X) unknown>>" severity note;
    end if;
    QB_tmp <= allx;
 elsif( CLKB'event and CLKB'last_value='X' and CLKB='1' and (diff_me_tchb = '1' or MEB /= '0') ) then       -- if CLKB X->1
    QB_tmp <= allx;
 elsif( CLKB'event and CLKB'last_value='1' and CLKB='X' and MEB /= '0' ) then       -- if CLKB 1->X
   if( (MES_CNTRL= "ON" or MES_CNTRL="ERR") and NOW /= 0 ns and mes_all_valid  ) then
     assert false report "<<VIRL_MEM_ERR:CLKB(1->X) unknown>>" severity note;
   end if;
    QB_tmp <= allx;
 end if;

-- Negedge of CLKB
 if( CLKB'event and CLKB'last_value='1' and CLKB='0' ) then       -- if CLKB 1->0
    if ( TEST1Blatched = '1' and MEBlatched = '1' and ADRB_lat < NW  ) then
      if ((MEAlatched = MEBlatched and to_unsigned_integer(ADRAlatched) = to_unsigned_integer(ADRBlatched)   and WEAlatched = '1') or (test1_rd_wr = '1')) then
        if (test1_rd_wr = '1') then
          QB_temp := allx;
          QB_tmp <= QB_temp;
          test1_rd_wr <= '0';
        elsif (flag_simul_clk = '1') then
          bit_corrupt := memdata_bef_wrt xor DAlatched;
          QB_temp := (allx and bit_corrupt) xor memdata_bef_wrt; 
          QB_tmp <= QB_temp;
          flag_simul_clk <= '0';
        else
          QB_temp := mem_core_array(to_unsigned_integer(ADRBlatched));
          QB_tmp <= QB_temp;
        end if;
      else
        if (test1_rd_wr = '1') then
          QB_temp := allx;
          QB_tmp <= QB_temp;
          test1_rd_wr <= '0';
        else
          QB_temp := mem_core_array(to_unsigned_integer(ADRBlatched));
          QB_tmp <= QB_temp;
        end if;
      end if;
    else
      flag_simul_clk <= '0';
    end if;
 end if;

-- Posedge of CLKB
 if( CLKB'event and CLKB'last_value='0' and CLKB='1' ) then       -- if CLKB 0->1
      CLKB_time := NOW;
       ADRBlatched := TO_X01(ADRB_old);
       MEBlatched := TO_X01(MEB_old);
       TEST1Blatched := TO_X01(TEST1B);
       if (LS = 'X' and MEBlatched /= '0') then
          if( (MES_CNTRL="ON" or MES_CNTRL="ERR") and NOW /= 0 ns and mes_all_valid  ) then
           assert false report "<<VIRL_MEM_ERR: LS unknown>>" severity note;
          end if;
         trash_mem(mem_core_array);
         QB_tmp <= allx;
       else 
-- Check for ADRB unknown
       if ( IS_X(ADRBlatched) and MEBlatched /= '0' and (MES_CNTRL="ON" or MES_CNTRL="ERR") and NOW /= 0 ns and mes_all_valid  ) then
         assert false report "<<VIRL_MEM_ERR: ADRB unknown>>" severity note;
       end if;
       addressbx := IS_X(ADRBlatched);
      if ( not addressbx) then
        addressb := to_unsigned_integer(ADRBlatched);
      end if ;                            

-- Normal read/write operation 
-- ME = X
    if( MEBlatched ='X' ) then
      if(( MES_CNTRL="ON" or MES_CNTRL="ERR") and NOW /= 0 ns and mes_all_valid  ) then
        assert false report "<<VIRL_MEM_ERR:MEB unknown>>" severity note;
      end if;
       QB_tmp <= allx;
    end if;          -- end of if ME X

-- MEB=1  (ME Enable)
    if( MEBlatched ='1' ) then
       if ( IS_X(RMB) ) then 
           if ( (MES_CNTRL="ON" or MES_CNTRL="ERR") and NOW /= 0 ns and mes_all_valid and RMEB = '1'  ) then
             assert false report "<<VIRL_MEM_ERR:RMB unknown>>" severity note;
           end if;
           QB_tmp <= allx;
       else
        if ( IS_X(TEST1B) ) then
          if(( MES_CNTRL="ON" or MES_CNTRL="ERR") and NOW /= 0 ns and mes_all_valid  ) then
            assert false report "<<VIRL_MEM_ERR:TEST1B unknown>>" severity note;
          end if;
          QB_tmp <= allx;
        elsif( IS_X(ADRBlatched) ) then    -- if WE disable, ME enable & Address X
          QB_tmp <= allx;
        elsif( ADRB_lat >= NW ) then     -- else if of Add X
          if(( MES_CNTRL="ON" or MES_CNTRL="WARN") and mes_all_valid ) then 
            assert false report "<<VIRL_MEM_WARNING: ADRB greater fixed WORD space>>" severity note;
          end if;
          QB_tmp <= allx;
        else				-- else of Add X (Normal Read memory)
          QB_temp := mem_core_array(ADRB_lat);
          QB_tmp <= QB_temp;
          if ( TEST1B = '1' ) then
            QB_tmp <= allx;
          end if;
        end if;  -- end of address check
       end if;  -- end of RM X
     end if;  -- end of Read Memory Enable


     if ( CLKA='1' and CLKA'event and CLKA'last_value = '0' ) then
       if ( not IS_X(ADRBlatched) ) then
         addressb := to_unsigned_integer(ADRBlatched);
       end if;
       if ( not IS_X(ADRA_old) ) then
         addressa := to_unsigned_integer(ADRA_old);
       end if;
     end if;

 if( MEBlatched = '1' and ADRA_lat < NW) then
-- checked activity on B -PORT, simultaneous checking.
-----------------------
-- PORT B is active. --
-----------------------

-- ADRB equal to ADRA
--  and B:READ (out=XXXX) / A:WRITE(mem_core_arrayA=DA)

  if(   CLKA='1' and CLKA'event and CLKA'last_value = '0'     and ((MEA_old ='1' and to_unsigned_integer(ADRBlatched) = to_unsigned_integer(ADRA_old)   and WEA_old = '1') )) then
          if (TEST_RNMAlatched = '1') then
            QB_temp := (mem_core_array(ADRB_lat));
          else
          flag_simul_clk <= '1';
          if (TEST1B = '0') then
            bit_corrupt := memdata_bef_wrt xor DAlatched;
            QB_temp := (allx and bit_corrupt) xor memdata_bef_wrt; 
            QB_tmp <= QB_temp;
           end if;
           end if; -- end of TEST_RNMA
 
     if( (MES_CNTRL="ON" or MES_CNTRL="ERR") and mes_all_valid ) then
       assert false report
       "<<VIRL_MEM_ERR: Simultaneous access to the same address on B-port(READ) and A-port(WRITE)>>"
       severity note;
     end if;

 
     end if;    -- end of if posedge of CLKA and condition for control singlas in two port
   end if;      -- end of if MEBlatched = '1' 

   end if; -- end of else of no power control pin unknown
 end if; -- end of posedge of clock



      if ( TEST1B'event ) then
        if ( TEST1B = '1' ) then
          if ( (MES_CNTRL="ON" or MES_CNTRL="WARN") and NOW /= 0 ns and mes_all_valid) then
          assert FALSE
          report "VIRL_MEM_WARNING: Tcc value in the RAM model is for TEST1B=0,but the input value is TEST1B=1 "
          severity note;
          end if;
        end if;
        if ( CLKB='1' and MEBlatched='1' and (LS='0') ) then
          QB_tmp <= allx;
          TEST1Blatched := '0';
        end if;
      end if;


  end process;

end behav;

---------------- ACTUAL MEMORY DESCRIPTION   ---------------------------

library IEEE;
library work;
use IEEE.std_logic_1164.all;

entity SNPS_RF_DP_UHD_512x80 is

  generic (
        XGenerationOn     : Boolean                := True;
        words             : integer                := 256;
        addrbits          : integer                := 8;
        bits              : integer                := 80;
        MES_CNTRL         : string                 := "ON"
   ); 

 port (
        QB : out std_logic_vector(79 downto 0);
        ADRA : in std_logic_vector(7 downto 0);
        DA : in std_logic_vector(79 downto 0);
        WEA : in std_logic;
        MEA : in std_logic;
        CLKA : in std_logic;
        TEST1A : in std_logic;
        TEST_RNMA : in std_logic;
        RMEA : in std_logic;
        RMA : in std_logic_vector(3 downto 0);
        WA : in std_logic_vector(1 downto 0);
        WPULSE : in std_logic_vector(2 downto 0);
        LS : in std_logic;
        ADRB : in std_logic_vector(7 downto 0);
        MEB : in std_logic;
        CLKB : in std_logic;
        TEST1B : in std_logic;
        RMEB : in std_logic;
        RMB : in std_logic_vector(3 downto 0) );

end SNPS_RF_DP_UHD_512x80;

architecture behaviour of SNPS_RF_DP_UHD_512x80 is

component generic_vhd_SNPS_RF_DP_UHD_512x80
  generic (
        words             : integer                := 256;
        addrbits          : integer                := 8;
        bits              : integer                := 80;
        NW                : integer                := 1;
        NADDR             : integer                := 1;
        rmbits            : integer                := 3;
        wabits           : integer                 := 2;
        wpulsebits           : integer             := 3;
        MES_CNTRL           : string                := "ON"
  );

  port (
  QB : out std_logic_vector (bits-1 downto 0);
  ADRA : in std_logic_vector (addrbits-1 downto 0);
  DA : in std_logic_vector (bits-1 downto 0);
  WEA : in std_logic;
  MEA : in std_logic;
  CLKA : in std_logic;
  TEST1A : in std_logic;
  TEST_RNMA : in std_logic;
  RMEA : in std_logic;
  RMA : in std_logic_vector (rmbits-1 downto 0);
  WA : in std_logic_vector (wabits-1 downto 0);
  WPULSE : in std_logic_vector (wpulsebits-1 downto 0);
  LS : in std_logic;
  ADRB : in std_logic_vector (addrbits-1 downto 0);
  MEB : in std_logic;
  CLKB : in std_logic;
  TEST1B : in std_logic;
  RMEB : in std_logic;
  RMB : in std_logic_vector (rmbits-1 downto 0);
  t3a_me : in time;
  t3b_me : in time
  );

end component;

SIGNAL WEA_buf : STD_LOGIC;
SIGNAL MEA_buf : STD_LOGIC;
SIGNAL MEB_buf : STD_LOGIC;
SIGNAL t3a_me  : time := 0 ns;
SIGNAL t3b_me  : time := 0 ns;

SIGNAL ADRA_buf : STD_LOGIC_VECTOR(7 downto 0) := (others=>'0');
SIGNAL ADRA_mout : STD_LOGIC_VECTOR(7 downto 0) := (others=>'0');
SIGNAL DA_buf : STD_LOGIC_VECTOR(79 downto 0) := (others=>'0');
SIGNAL DA_mout : STD_LOGIC_VECTOR(79 downto 0) := (others=>'0');
SIGNAL WEA_mout  :STD_LOGIC ;
SIGNAL MEA_mout  :STD_LOGIC ;
SIGNAL LS_oldA  :STD_LOGIC ;
SIGNAL LS_oldB  :STD_LOGIC ;
SIGNAL WA_old  :STD_LOGIC_VECTOR(1 downto 0);
SIGNAL WPULSE_old  :STD_LOGIC_VECTOR(2 downto 0) ;
SIGNAL CLKA_mem  :STD_LOGIC := '0';

SIGNAL RMAVAL  : STD_LOGIC_VECTOR(2 downto 0) := "011";
SIGNAL RMA_int : STD_LOGIC_VECTOR(2 downto 0);
SIGNAL ADRB_buf : STD_LOGIC_VECTOR(7 downto 0) := (others=>'0');
SIGNAL ADRB_mout : STD_LOGIC_VECTOR(7 downto 0) := (others=>'0');
SIGNAL MEB_mout  :STD_LOGIC ;
SIGNAL CLKB_mem  :STD_LOGIC := '0';

SIGNAL RMBVAL  : STD_LOGIC_VECTOR(2 downto 0) := "011";
SIGNAL RMB_int : STD_LOGIC_VECTOR(2 downto 0);
SIGNAL disp_LS_msgA :STD_LOGIC :='1';
SIGNAL disp_LS_msgB :STD_LOGIC :='1';


SIGNAL CLKA_buf: STD_LOGIC;
SIGNAL TEST1A_buf: STD_LOGIC;
SIGNAL TEST_RNMA_buf: STD_LOGIC;
SIGNAL RMEA_buf: STD_LOGIC;
SIGNAL RMA_buf: STD_LOGIC_VECTOR(3 downto 0);
SIGNAL WA_buf: STD_LOGIC_VECTOR(1 downto 0);
SIGNAL WPULSE_buf: STD_LOGIC_VECTOR(2 downto 0);
SIGNAL LS_buf: STD_LOGIC;
SIGNAL CLKB_buf: STD_LOGIC;
SIGNAL TEST1B_buf: STD_LOGIC;
SIGNAL RMEB_buf: STD_LOGIC;
SIGNAL RMB_buf: STD_LOGIC_VECTOR(3 downto 0);



  for uut : generic_vhd_SNPS_RF_DP_UHD_512x80 use entity work.generic_vhd_SNPS_RF_DP_UHD_512x80(behav);
  BEGIN

    LS_oldA <= LS_buf when (CLKA_buf = '0') else LS_oldA ;
    LS_oldB <= LS_buf when (CLKB_buf = '0') else LS_oldB ;
    CLKA_mem <= '0' when ((MEA_mout /= 'X' and LS_oldA = '1' and CLKA_buf /= 'X') ) else CLKA_buf;
    CLKB_mem <= '0' when ((MEB_mout /= 'X' and LS_oldB = '1' and CLKB_buf /= 'X') ) else CLKB_buf;
  process ( CLKA_buf, ADRA_buf )
  begin
    if ( (CLKA_buf'last_value /= '0' and CLKA_buf = '0') or NOW = 0 ns ) then
      ADRA_mout <= ADRA_buf;
    end if;
  end process;
  process ( CLKA_buf, DA_buf )
  begin
    if ( (CLKA_buf'last_value /= '0' and CLKA_buf = '0') or NOW = 0 ns ) then
      DA_mout <= DA_buf;
    end if;
  end process;
  process ( CLKA_buf, MEA_buf )
  begin
    if ( (CLKA_buf'last_value /= '0' and CLKA_buf = '0') or NOW = 0 ns ) then
      MEA_mout <= MEA_buf;
    end if;
  end process;
  process ( CLKA_buf, WEA_buf )
  begin
    if ( (CLKA_buf'last_value /= '0' and CLKA_buf = '0') or NOW = 0 ns ) then
      WEA_mout <= WEA_buf;
    end if;
  end process;
  process ( CLKA_buf, WA_buf )
  begin
    if ( (CLKA_buf'last_value /= '0' and CLKA_buf = '0') or NOW = 0 ns ) then
      WA_old <= WA_buf;
    end if;
  end process;
  process ( CLKA_buf, WPULSE_buf )
  begin
    if ( (CLKA_buf'last_value /= '0' and CLKA_buf = '0') or NOW = 0 ns ) then
      WPULSE_old <= WPULSE_buf;
    end if;
  end process;
  process ( CLKB_buf, ADRB_buf )
  begin
    if ( (CLKB_buf'last_value /= '0' and CLKB_buf = '0') or NOW = 0 ns ) then
      ADRB_mout <= ADRB_buf;
    end if;
  end process;
  process ( CLKB_buf, MEB_buf )
  begin
    if ( (CLKB_buf'last_value /= '0' and CLKB_buf = '0') or NOW = 0 ns ) then
      MEB_mout <= MEB_buf;
    end if;
  end process;
  process(RMA_buf(3))
  begin
   if(RMA_buf(3) = 'X' ) then
      if ( (MES_CNTRL= "ON" or MES_CNTRL = "WARN") and NOW /= 0 ns) then
        assert false report "<<VIRL_MEM_WARNING: RMA[3] is unknown>>" severity note;
      end if;
   end if;
  end process;
  process(RMB_buf(3))
  begin
   if(RMB_buf(3) = 'X' ) then
      if ( (MES_CNTRL= "ON" or MES_CNTRL = "WARN") and NOW /= 0 ns) then
        assert false report "<<VIRL_MEM_WARNING: RMB[3] is unknown>>" severity note;
      end if;
   end if;
  end process;

  uut : generic_vhd_SNPS_RF_DP_UHD_512x80
  generic map (
        NW                     => 256, 
        NADDR                  => 8,
        rmbits                 => 3,
        wabits                 => 2,
        wpulsebits             => 3,
        words                  => 256,
        addrbits               => 8,
        bits                   => 80,
        MES_CNTRL                => MES_CNTRL
  )
  port map (
   QB =>    QB,
   ADRA =>    ADRA_mout,
   DA =>    DA_mout,
   WEA =>    WEA_mout,
   MEA =>    MEA_mout,
   CLKA =>    CLKA_mem,
   TEST1A =>    TEST1A_buf,
   TEST_RNMA =>    TEST_RNMA_buf,
   RMEA =>    RMEA_buf,
   RMA =>    RMA_int,
   WA =>    WA_old,
   WPULSE =>    WPULSE_old,
   LS =>    LS_buf,
   ADRB =>    ADRB_mout,
   MEB =>    MEB_mout,
   CLKB =>    CLKB_mem,
   TEST1B =>    TEST1B_buf,
   RMEB =>    RMEB_buf,
   RMB =>    RMB_int,
   t3a_me => t3a_me,
   t3b_me => t3b_me
  );

    ADRA_buf(0) <= 'X' when ADRA(0) = 'Z' else  ADRA(0);
    ADRA_buf(1) <= 'X' when ADRA(1) = 'Z' else  ADRA(1);
    ADRA_buf(2) <= 'X' when ADRA(2) = 'Z' else  ADRA(2);
    ADRA_buf(3) <= 'X' when ADRA(3) = 'Z' else  ADRA(3);
    ADRA_buf(4) <= 'X' when ADRA(4) = 'Z' else  ADRA(4);
    ADRA_buf(5) <= 'X' when ADRA(5) = 'Z' else  ADRA(5);
    ADRA_buf(6) <= 'X' when ADRA(6) = 'Z' else  ADRA(6);
    ADRA_buf(7) <= 'X' when ADRA(7) = 'Z' else  ADRA(7);
    DA_buf(0) <= 'X' when DA(0) = 'Z' else  DA(0);
    DA_buf(1) <= 'X' when DA(1) = 'Z' else  DA(1);
    DA_buf(2) <= 'X' when DA(2) = 'Z' else  DA(2);
    DA_buf(3) <= 'X' when DA(3) = 'Z' else  DA(3);
    DA_buf(4) <= 'X' when DA(4) = 'Z' else  DA(4);
    DA_buf(5) <= 'X' when DA(5) = 'Z' else  DA(5);
    DA_buf(6) <= 'X' when DA(6) = 'Z' else  DA(6);
    DA_buf(7) <= 'X' when DA(7) = 'Z' else  DA(7);
    DA_buf(8) <= 'X' when DA(8) = 'Z' else  DA(8);
    DA_buf(9) <= 'X' when DA(9) = 'Z' else  DA(9);
    DA_buf(10) <= 'X' when DA(10) = 'Z' else  DA(10);
    DA_buf(11) <= 'X' when DA(11) = 'Z' else  DA(11);
    DA_buf(12) <= 'X' when DA(12) = 'Z' else  DA(12);
    DA_buf(13) <= 'X' when DA(13) = 'Z' else  DA(13);
    DA_buf(14) <= 'X' when DA(14) = 'Z' else  DA(14);
    DA_buf(15) <= 'X' when DA(15) = 'Z' else  DA(15);
    DA_buf(16) <= 'X' when DA(16) = 'Z' else  DA(16);
    DA_buf(17) <= 'X' when DA(17) = 'Z' else  DA(17);
    DA_buf(18) <= 'X' when DA(18) = 'Z' else  DA(18);
    DA_buf(19) <= 'X' when DA(19) = 'Z' else  DA(19);
    DA_buf(20) <= 'X' when DA(20) = 'Z' else  DA(20);
    DA_buf(21) <= 'X' when DA(21) = 'Z' else  DA(21);
    DA_buf(22) <= 'X' when DA(22) = 'Z' else  DA(22);
    DA_buf(23) <= 'X' when DA(23) = 'Z' else  DA(23);
    DA_buf(24) <= 'X' when DA(24) = 'Z' else  DA(24);
    DA_buf(25) <= 'X' when DA(25) = 'Z' else  DA(25);
    DA_buf(26) <= 'X' when DA(26) = 'Z' else  DA(26);
    DA_buf(27) <= 'X' when DA(27) = 'Z' else  DA(27);
    DA_buf(28) <= 'X' when DA(28) = 'Z' else  DA(28);
    DA_buf(29) <= 'X' when DA(29) = 'Z' else  DA(29);
    DA_buf(30) <= 'X' when DA(30) = 'Z' else  DA(30);
    DA_buf(31) <= 'X' when DA(31) = 'Z' else  DA(31);
    DA_buf(32) <= 'X' when DA(32) = 'Z' else  DA(32);
    DA_buf(33) <= 'X' when DA(33) = 'Z' else  DA(33);
    DA_buf(34) <= 'X' when DA(34) = 'Z' else  DA(34);
    DA_buf(35) <= 'X' when DA(35) = 'Z' else  DA(35);
    DA_buf(36) <= 'X' when DA(36) = 'Z' else  DA(36);
    DA_buf(37) <= 'X' when DA(37) = 'Z' else  DA(37);
    DA_buf(38) <= 'X' when DA(38) = 'Z' else  DA(38);
    DA_buf(39) <= 'X' when DA(39) = 'Z' else  DA(39);
    DA_buf(40) <= 'X' when DA(40) = 'Z' else  DA(40);
    DA_buf(41) <= 'X' when DA(41) = 'Z' else  DA(41);
    DA_buf(42) <= 'X' when DA(42) = 'Z' else  DA(42);
    DA_buf(43) <= 'X' when DA(43) = 'Z' else  DA(43);
    DA_buf(44) <= 'X' when DA(44) = 'Z' else  DA(44);
    DA_buf(45) <= 'X' when DA(45) = 'Z' else  DA(45);
    DA_buf(46) <= 'X' when DA(46) = 'Z' else  DA(46);
    DA_buf(47) <= 'X' when DA(47) = 'Z' else  DA(47);
    DA_buf(48) <= 'X' when DA(48) = 'Z' else  DA(48);
    DA_buf(49) <= 'X' when DA(49) = 'Z' else  DA(49);
    DA_buf(50) <= 'X' when DA(50) = 'Z' else  DA(50);
    DA_buf(51) <= 'X' when DA(51) = 'Z' else  DA(51);
    DA_buf(52) <= 'X' when DA(52) = 'Z' else  DA(52);
    DA_buf(53) <= 'X' when DA(53) = 'Z' else  DA(53);
    DA_buf(54) <= 'X' when DA(54) = 'Z' else  DA(54);
    DA_buf(55) <= 'X' when DA(55) = 'Z' else  DA(55);
    DA_buf(56) <= 'X' when DA(56) = 'Z' else  DA(56);
    DA_buf(57) <= 'X' when DA(57) = 'Z' else  DA(57);
    DA_buf(58) <= 'X' when DA(58) = 'Z' else  DA(58);
    DA_buf(59) <= 'X' when DA(59) = 'Z' else  DA(59);
    DA_buf(60) <= 'X' when DA(60) = 'Z' else  DA(60);
    DA_buf(61) <= 'X' when DA(61) = 'Z' else  DA(61);
    DA_buf(62) <= 'X' when DA(62) = 'Z' else  DA(62);
    DA_buf(63) <= 'X' when DA(63) = 'Z' else  DA(63);
    DA_buf(64) <= 'X' when DA(64) = 'Z' else  DA(64);
    DA_buf(65) <= 'X' when DA(65) = 'Z' else  DA(65);
    DA_buf(66) <= 'X' when DA(66) = 'Z' else  DA(66);
    DA_buf(67) <= 'X' when DA(67) = 'Z' else  DA(67);
    DA_buf(68) <= 'X' when DA(68) = 'Z' else  DA(68);
    DA_buf(69) <= 'X' when DA(69) = 'Z' else  DA(69);
    DA_buf(70) <= 'X' when DA(70) = 'Z' else  DA(70);
    DA_buf(71) <= 'X' when DA(71) = 'Z' else  DA(71);
    DA_buf(72) <= 'X' when DA(72) = 'Z' else  DA(72);
    DA_buf(73) <= 'X' when DA(73) = 'Z' else  DA(73);
    DA_buf(74) <= 'X' when DA(74) = 'Z' else  DA(74);
    DA_buf(75) <= 'X' when DA(75) = 'Z' else  DA(75);
    DA_buf(76) <= 'X' when DA(76) = 'Z' else  DA(76);
    DA_buf(77) <= 'X' when DA(77) = 'Z' else  DA(77);
    DA_buf(78) <= 'X' when DA(78) = 'Z' else  DA(78);
    DA_buf(79) <= 'X' when DA(79) = 'Z' else  DA(79);
    WEA_buf <= 'X' when WEA = 'Z' else  WEA;
    MEA_buf <= 'X' when MEA = 'Z' else  MEA;
    CLKA_buf <= 'X' when CLKA = 'Z' else  CLKA;
    TEST1A_buf <= 'X' when TEST1A = 'Z' else  TEST1A;
    TEST_RNMA_buf <= 'X' when TEST_RNMA = 'Z' else  TEST_RNMA;
    RMEA_buf <= 'X' when RMEA = 'Z' else  RMEA;
    RMA_buf(0) <= 'X' when RMA(0) = 'Z' else  RMA(0);
    RMA_buf(1) <= 'X' when RMA(1) = 'Z' else  RMA(1);
    RMA_buf(2) <= 'X' when RMA(2) = 'Z' else  RMA(2);
    RMA_buf(3) <= 'X' when RMA(3) = 'Z' else  RMA(3);
    WA_buf(0) <= 'X' when WA(0) = 'Z' else  WA(0);
    WA_buf(1) <= 'X' when WA(1) = 'Z' else  WA(1);
    WPULSE_buf(0) <= 'X' when WPULSE(0) = 'Z' else  WPULSE(0);
    WPULSE_buf(1) <= 'X' when WPULSE(1) = 'Z' else  WPULSE(1);
    WPULSE_buf(2) <= 'X' when WPULSE(2) = 'Z' else  WPULSE(2);
    LS_buf <= 'X' when LS = 'Z' else  LS;
    ADRB_buf(0) <= 'X' when ADRB(0) = 'Z' else  ADRB(0);
    ADRB_buf(1) <= 'X' when ADRB(1) = 'Z' else  ADRB(1);
    ADRB_buf(2) <= 'X' when ADRB(2) = 'Z' else  ADRB(2);
    ADRB_buf(3) <= 'X' when ADRB(3) = 'Z' else  ADRB(3);
    ADRB_buf(4) <= 'X' when ADRB(4) = 'Z' else  ADRB(4);
    ADRB_buf(5) <= 'X' when ADRB(5) = 'Z' else  ADRB(5);
    ADRB_buf(6) <= 'X' when ADRB(6) = 'Z' else  ADRB(6);
    ADRB_buf(7) <= 'X' when ADRB(7) = 'Z' else  ADRB(7);
    MEB_buf <= 'X' when MEB = 'Z' else  MEB;
    CLKB_buf <= 'X' when CLKB = 'Z' else  CLKB;
    TEST1B_buf <= 'X' when TEST1B = 'Z' else  TEST1B;
    RMEB_buf <= 'X' when RMEB = 'Z' else  RMEB;
    RMB_buf(0) <= 'X' when RMB(0) = 'Z' else  RMB(0);
    RMB_buf(1) <= 'X' when RMB(1) = 'Z' else  RMB(1);
    RMB_buf(2) <= 'X' when RMB(2) = 'Z' else  RMB(2);
    RMB_buf(3) <= 'X' when RMB(3) = 'Z' else  RMB(3);


process(MEA_buf,MEB_buf)

VARIABLE t3a_me_tmp : time := 0 ns;
VARIABLE t3b_me_tmp : time := 0 ns;

begin

  if ( MEA_buf'event ) then
    t3a_me_tmp := now;
    t3a_me <= t3a_me_tmp;
  end if;

  if ( MEB_buf'event ) then
    t3b_me_tmp := now;
    t3b_me <= t3b_me_tmp;
  end if;

end process;

   RMA_int <= RMA_buf(2 downto 0) when RMEA_buf = '1' else RMAVAL when RMEA_buf = '0' else (others=>'X');

process (CLKA_buf)
begin
   if ( CLKA_buf'event and CLKA_buf'last_value='0' and CLKA_buf = '1') then
     if ( RMEA_buf = 'X' and MEA_buf = '1' ) then
       if( (MES_CNTRL="ON" or MES_CNTRL="ERR") and NOW /= 0 ns  ) then
         assert false report "<<VIRL_MEM_ERR: RMEA unknown>>" severity note;
       end if;
     end if;
   end if;
end process;

   RMB_int <= RMB_buf(2 downto 0) when RMEB_buf = '1' else RMBVAL when RMEB_buf = '0' else (others=>'X');

process (CLKB_buf)
begin
   if ( CLKB_buf'event and CLKB_buf'last_value='0' and CLKB_buf = '1') then
     if ( RMEB_buf = 'X' and MEB_buf = '1' ) then
       if( (MES_CNTRL="ON" or MES_CNTRL="ERR") and NOW /= 0 ns  ) then
         assert false report "<<VIRL_MEM_ERR: RMEB unknown>>" severity note;
       end if;
     end if;
   end if;
end process;


process (LS_buf,CLKA_buf)
begin
  if (LS_buf'event and LS_buf'last_value /= '0' and LS_buf /= '1') then
    disp_LS_msgA <= '1';
  end if;

  if (LS_buf = '1' and MEA_mout /= '0' and (LS_buf'event or (CLKA_buf'event and CLKA_buf /= '0' and CLKA_buf'last_value /= '1'))) then
    if( (MES_CNTRL="ON" or MES_CNTRL="WARN") and disp_LS_msgA = '1' ) then
      assert FALSE report "<<VIRL_MEM_WARNING: Port A : No Operation as Memory is in Light Sleep mode.>>" severity note;
      disp_LS_msgA <= '0';
    end if;
  end if;
end process;

process (LS_buf,CLKB_buf)
begin
  if (LS_buf'event and LS_buf'last_value /= '0' and LS_buf /= '1') then
    disp_LS_msgB <= '1';
  end if;

  if (LS_buf = '1' and MEB_mout /= '0' and (LS_buf'event or (CLKB_buf'event and CLKB_buf /= '0' and CLKB_buf'last_value /= '1'))) then
    if( (MES_CNTRL="ON" or MES_CNTRL="WARN") and disp_LS_msgB = '1' ) then
      assert FALSE report "<<VIRL_MEM_WARNING: Port B : No Operation as Memory is in Light Sleep mode.>>" severity note;
      disp_LS_msgB <= '0';
    end if;
  end if;
end process;

end behaviour;

configuration conf_SNPS_RF_DP_UHD_512x80_behaviour of SNPS_RF_DP_UHD_512x80 is
for behaviour
end for;
end conf_SNPS_RF_DP_UHD_512x80_behaviour;
