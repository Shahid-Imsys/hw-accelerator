//---------------------------------------------------------------------
//               Copyright(c) Synopsys, Inc.                           
//     All Rights reserved - Unpublished -rights reserved under        
//     the Copyright laws of the United States of America.             
//                                                                     
//  U.S. Patents: 7,093,156 B1 and 7,406,620 B2 (and more pending).    
//                                                                     
//  This file includes the Confidential information of Synopsys, Inc.  
//  and GLOBALFOUNDRIES.                                               
//  The receiver of this Confidential Information shall not disclose   
//  it to any third party and shall protect its confidentiality by     
//  using the same degree of care, but not less than a reasonable      
//  degree of care, as the receiver uses to protect receiver's own     
//  Confidential Information.                                          
//  Licensee acknowledges and agrees that all output generated for     
//  Licensee by Synopsys, Inc. as described in the pertinent Program   
//  Schedule(s), or generated by Licensee through use of any Compiler  
//  licensed hereunder contains information that complies with the     
//  Virtual Component Identification Physical Tagging Standard (VCID)  
//  as maintained by the Virtual Socket Interface Alliance (VSIA).     
//  Such information may be expressed in GDSII Layer 63 or other such  
//  layer designated by the VSIA, hardware definition languages, or    
//  other formats.  Licensee is not authorized to alter or change any  
//  such information.                                                  
//---------------------------------------------------------------------
//                                                                     
//  Built for linux64 and running on linux64.                          
//                                                                     
//  Software           : Rev: S-2021.09-SP1                            
//  Library Format     : Rev: 1.05.00                                  
//  Compiler Name      : gf22nsd41p11s1dcl02msa04p1                    
//  Platform           : Linux3.10.0-957.5.1.el7.x86_64                
//                     : #1 SMP Wed Dec 19 10:46:58 EST 2018x86_64     
//  Date of Generation : Mon May 23 16:06:06 CEST 2022                 
//                                                                     
//---------------------------------------------------------------------
//   --------------------------------------------------------------     
//                       Template Revision : 6.2.5                      
//   --------------------------------------------------------------     
//                      * Synchronous, 1-Port SRAM *                  
//                    * Verilog Behavioral/RTL Model *                
//                THIS IS A SYNCHRONOUS 1-PORT MEMORY MODEL           
//                                                                    
//   Memory Name:SNPS_SP_HD_16Kx8                                     
//   Memory Size:16384 words x 8 bits                                 
//                                                                    
//                               PORT NAME                            
//                               ---------                            
//               Output Ports                                         
//                                   Q[7:0]                           
//               Input Ports:                                         
//                                   ADR[13:0]                        
//                                   D[7:0]                           
//                                   WE                               
//                                   ME                               
//                                   CLK                              
//                                   TEST1                            
//                                   TEST_RNM                         
//                                   RME                              
//                                   RM[3:0]                          
//                                   WA[1:0]                          
//                                   WPULSE[2:0]                      
//                                   LS                               
//                                   BC0                              
//                                   BC1                              
//                                   BC2                              
// -------------------------------------------------------------------- 
// -------------------------------------------------------------------- 
// This instance is generated with Periphery_Vt = ULTRALOW option.    
// -------------------------------------------------------------------- 


`resetall 
`timescale 1 ns / 1 ps 
`celldefine 
`ifdef verifault // for fault simulation purpose 
`suppress_faults 
`enable_portfaults 
`endif 

`define True    1'b1
`define False   1'b0

module SNPS_SP_HD_16Kx8 ( Q, ADR, D, WE, ME, CLK, TEST1, TEST_RNM, RME, RM, WA, WPULSE, LS, BC0, BC1, BC2);

// Input/Output Ports Declaration
output  [7:0] Q;
input  [13:0] ADR;
input  [7:0] D;
input WE;
input ME;
input CLK;
input TEST1;
input TEST_RNM;
input RME;
input  [3:0] RM;
input  [1:0] WA;
input  [2:0] WPULSE;
input LS;
input BC0;
input BC1;
input BC2;

// Local registers, wires, etc
`ifdef MEM_CHECK_OFF
parameter MES_CNTRL = "OFF";
`else
parameter MES_CNTRL = "ON";
`endif
parameter MemFault_Inj = 0;

`ifndef MES_CNTRL_DEL_BEGIN
  `define MES_CNTRL_DEL_BEGIN 0
`endif

`ifndef MES_CNTRL_DEL_END
  `define MES_CNTRL_DEL_END 0
`endif
parameter MesCntrl_Begin = `MES_CNTRL_DEL_BEGIN;
parameter MesCntrl_End = `MES_CNTRL_DEL_END;


`ifdef VIRAGE_FAST_VERILOG
`else
// Notifiers Declaration
reg notif_adr;
wire [7:0] notif_d;
reg notif_d_7, notif_d_6, notif_d_5, notif_d_4, notif_d_3, notif_d_2, notif_d_1, notif_d_0;
reg notif_we;
reg notif_me;
reg notif_clk;
reg notif_clkp;
reg notif_test1;
reg notif_test_rnm;
reg notif_rme;
reg notif_rm;
reg notif_wa;
reg notif_wpulse;
reg notif_ls;
reg notif_bc0;
reg notif_bc1;
reg notif_bc2;
`endif
reg ADRFLAGA;
`ifdef VIRAGE_FAST_VERILOG
wire [7:0] Q_buf;
assign Q[0] = Q_buf[0];
assign Q[1] = Q_buf[1];
assign Q[2] = Q_buf[2];
assign Q[3] = Q_buf[3];
assign Q[4] = Q_buf[4];
assign Q[5] = Q_buf[5];
assign Q[6] = Q_buf[6];
assign Q[7] = Q_buf[7];
wire [13:0] ADR_buf;
assign  ADR_buf[0] = (ADR[0] === 1'bZ) ? 1'bX : ( ADR[0]);
assign  ADR_buf[1] = (ADR[1] === 1'bZ) ? 1'bX : ( ADR[1]);
assign  ADR_buf[2] = (ADR[2] === 1'bZ) ? 1'bX : ( ADR[2]);
assign  ADR_buf[3] = (ADR[3] === 1'bZ) ? 1'bX : ( ADR[3]);
assign  ADR_buf[4] = (ADR[4] === 1'bZ) ? 1'bX : ( ADR[4]);
assign  ADR_buf[5] = (ADR[5] === 1'bZ) ? 1'bX : ( ADR[5]);
assign  ADR_buf[6] = (ADR[6] === 1'bZ) ? 1'bX : ( ADR[6]);
assign  ADR_buf[7] = (ADR[7] === 1'bZ) ? 1'bX : ( ADR[7]);
assign  ADR_buf[8] = (ADR[8] === 1'bZ) ? 1'bX : ( ADR[8]);
assign  ADR_buf[9] = (ADR[9] === 1'bZ) ? 1'bX : ( ADR[9]);
assign  ADR_buf[10] = (ADR[10] === 1'bZ) ? 1'bX : ( ADR[10]);
assign  ADR_buf[11] = (ADR[11] === 1'bZ) ? 1'bX : ( ADR[11]);
assign  ADR_buf[12] = (ADR[12] === 1'bZ) ? 1'bX : ( ADR[12]);
assign  ADR_buf[13] = (ADR[13] === 1'bZ) ? 1'bX : ( ADR[13]);
wire [7:0] D_buf;
assign  D_buf[0] = (D[0] === 1'bZ) ? 1'bX : ( D[0]);
assign  D_buf[1] = (D[1] === 1'bZ) ? 1'bX : ( D[1]);
assign  D_buf[2] = (D[2] === 1'bZ) ? 1'bX : ( D[2]);
assign  D_buf[3] = (D[3] === 1'bZ) ? 1'bX : ( D[3]);
assign  D_buf[4] = (D[4] === 1'bZ) ? 1'bX : ( D[4]);
assign  D_buf[5] = (D[5] === 1'bZ) ? 1'bX : ( D[5]);
assign  D_buf[6] = (D[6] === 1'bZ) ? 1'bX : ( D[6]);
assign  D_buf[7] = (D[7] === 1'bZ) ? 1'bX : ( D[7]);
wire WE_buf;
assign  WE_buf = (WE === 1'bZ) ? 1'bX : ( WE);
wire ME_buf;
assign  ME_buf = (ME === 1'bZ) ? 1'bX : ( ME);
wire CLK_buf;
assign  CLK_buf = (CLK === 1'bZ) ? 1'bX : ( CLK);
wire TEST1_buf;
assign  TEST1_buf = (TEST1 === 1'bZ) ? 1'bX : ( TEST1);
wire TEST_RNM_buf;
assign  TEST_RNM_buf = (TEST_RNM === 1'bZ) ? 1'bX : ( TEST_RNM);
wire RME_buf;
assign  RME_buf = (RME === 1'bZ) ? 1'bX : ( RME);
wire [2:0] RM_int;
wire [3:0] RM_buf;
assign  RM_buf[0] = (RM[0] === 1'bZ) ? 1'bX : ( RM[0]);
assign  RM_buf[1] = (RM[1] === 1'bZ) ? 1'bX : ( RM[1]);
assign  RM_buf[2] = (RM[2] === 1'bZ) ? 1'bX : ( RM[2]);
assign  RM_buf[3] = (RM[3] === 1'bZ) ? 1'bX : ( RM[3]);
wire [1:0] WA_buf;
assign  WA_buf[0] = (WA[0] === 1'bZ) ? 1'bX : ( WA[0]);
assign  WA_buf[1] = (WA[1] === 1'bZ) ? 1'bX : ( WA[1]);
wire [2:0] WPULSE_buf;
assign  WPULSE_buf[0] = (WPULSE[0] === 1'bZ) ? 1'bX : ( WPULSE[0]);
assign  WPULSE_buf[1] = (WPULSE[1] === 1'bZ) ? 1'bX : ( WPULSE[1]);
assign  WPULSE_buf[2] = (WPULSE[2] === 1'bZ) ? 1'bX : ( WPULSE[2]);
wire LS_buf;
assign  LS_buf = (LS === 1'bZ) ? 1'bX : ( LS);
wire BC0_buf;
assign  BC0_buf = (BC0 === 1'bZ) ? 1'bX : ( BC0);
wire BC1_buf;
assign  BC1_buf = (BC1 === 1'bZ) ? 1'bX : ( BC1);
wire BC2_buf;
assign  BC2_buf = (BC2 === 1'bZ) ? 1'bX : ( BC2);
`else
wire [7:0] Q_buf;
buf (Q[0], Q_buf[0]);
buf (Q[1], Q_buf[1]);
buf (Q[2], Q_buf[2]);
buf (Q[3], Q_buf[3]);
buf (Q[4], Q_buf[4]);
buf (Q[5], Q_buf[5]);
buf (Q[6], Q_buf[6]);
buf (Q[7], Q_buf[7]);
wire [13:0] ADR_buf;
wire [13:0] delayed_ADR;
buf (ADR_buf[0], delayed_ADR[0]);
buf (ADR_buf[1], delayed_ADR[1]);
buf (ADR_buf[2], delayed_ADR[2]);
buf (ADR_buf[3], delayed_ADR[3]);
buf (ADR_buf[4], delayed_ADR[4]);
buf (ADR_buf[5], delayed_ADR[5]);
buf (ADR_buf[6], delayed_ADR[6]);
buf (ADR_buf[7], delayed_ADR[7]);
buf (ADR_buf[8], delayed_ADR[8]);
buf (ADR_buf[9], delayed_ADR[9]);
buf (ADR_buf[10], delayed_ADR[10]);
buf (ADR_buf[11], delayed_ADR[11]);
buf (ADR_buf[12], delayed_ADR[12]);
buf (ADR_buf[13], delayed_ADR[13]);
wire [7:0] D_buf;
wire [7:0] delayed_D;
buf (D_buf[0], delayed_D[0]);
buf (D_buf[1], delayed_D[1]);
buf (D_buf[2], delayed_D[2]);
buf (D_buf[3], delayed_D[3]);
buf (D_buf[4], delayed_D[4]);
buf (D_buf[5], delayed_D[5]);
buf (D_buf[6], delayed_D[6]);
buf (D_buf[7], delayed_D[7]);
wire delayed_WE;
buf (WE_buf, delayed_WE);
wire delayed_ME;
buf (ME_buf, delayed_ME);
wire delayed_CLK;
buf (CLK_buf, delayed_CLK);
wire delayed_TEST1;
buf (TEST1_buf, delayed_TEST1);
wire delayed_TEST_RNM;
buf (TEST_RNM_buf, delayed_TEST_RNM);
wire delayed_RME;
buf (RME_buf, delayed_RME);
wire [2:0] RM_int;
wire [3:0] RM_buf;
wire [3:0] delayed_RM;
buf (RM_buf[0], delayed_RM[0]);
buf (RM_buf[1], delayed_RM[1]);
buf (RM_buf[2], delayed_RM[2]);
buf (RM_buf[3], delayed_RM[3]);
wire [1:0] WA_buf;
wire [1:0] delayed_WA;
buf (WA_buf[0], delayed_WA[0]);
buf (WA_buf[1], delayed_WA[1]);
wire [2:0] WPULSE_buf;
wire [2:0] delayed_WPULSE;
buf (WPULSE_buf[0], delayed_WPULSE[0]);
buf (WPULSE_buf[1], delayed_WPULSE[1]);
buf (WPULSE_buf[2], delayed_WPULSE[2]);
wire delayed_LS;
buf (LS_buf, delayed_LS);
wire delayed_BC0;
buf (BC0_buf, delayed_BC0);
wire delayed_BC1;
buf (BC1_buf, delayed_BC1);
wire delayed_BC2;
buf (BC2_buf, delayed_BC2);
`endif
// -------------------------------------------------------------------
// Tasks
// -------------------------------------------------------------------

`ifndef MEMFAULTINJ
task fault_inject;
input [13 : 0] address;
input [2:0] bit_pos;
input flt_type;
begin
  if (address < 16384)
  begin
  if (uut.faultinj_en == 0)
  begin
    if (flt_type == 1)
    begin
      uut.mem_fault_array_sa1[address][bit_pos] = 1'b1 ;
      uut.mem_fault_array_sa0[address][bit_pos] = 1'b1 ;
    end
    else
    begin
      uut.mem_fault_array_sa0[address][bit_pos] = 1'b0 ;
      uut.mem_fault_array_sa1[address][bit_pos] = 1'b0 ;
    end
  end
  end
  else
  begin
    $display("\n%m<<VIRL_MEM_ERR: No fault injection for address out of range.>>(time %0t)", $time);
  end
end
endtask
`endif

reg disp_LS_msg;

reg en_msg_cntrl, mes_all_valid_old;
real msg_start_lmt, msg_end_lmt;
reg disp_LS_msg_old;
initial
begin : reinit_msg_blk
  disp_LS_msg_old = 1'b1;
  if (MesCntrl_Begin < 0)
    msg_start_lmt = 0;
  else
    msg_start_lmt = MesCntrl_Begin;
  if (MesCntrl_End < 0)
    msg_end_lmt = 0;
  else
    msg_end_lmt = MesCntrl_End;
  
  if (msg_end_lmt > msg_start_lmt)
  begin
    if ($realtime > 0 )
    begin
      if (msg_start_lmt > $realtime)
      begin
        en_msg_cntrl = 1'b0;
        en_msg_cntrl <= #(msg_start_lmt - $realtime) 1'b1;
      end
      if (msg_end_lmt > $realtime)
        en_msg_cntrl <= #(msg_end_lmt - $realtime) 1'b0;
      else
        en_msg_cntrl = 1'b0;
    end
    else
    begin
      mes_all_valid_old = 1'b0;
      en_msg_cntrl = 1'b0;
      en_msg_cntrl <= #msg_start_lmt 1'b1;
      en_msg_cntrl <= #msg_end_lmt 1'b0;
    end
  end
  else
  begin
    en_msg_cntrl = 1'b0;
    if ($realtime == 0)
      mes_all_valid_old = 1'b0;
  end
end

`ifdef MES_CNTRL_PIN
always @(`MES_CNTRL_PIN)
begin
  if (msg_start_lmt == 0 && msg_end_lmt == 0)
  begin
    if (`MES_CNTRL_PIN  === `MES_CNTRL_PIN_VAL)
    begin
      en_msg_cntrl = 1;
    end
    else
    begin
      en_msg_cntrl = 0;
    end
  end
end
`endif

`ifdef SNPS_SUPPORT_UPF_SIM
(* vcs_always_on *)
`endif
always @( en_msg_cntrl )
begin
  if (en_msg_cntrl !== 1'b0 )
  begin
    if (!(en_msg_cntrl === 1'bx && mes_all_valid_old === 1'b1))
    mes_all_valid_old = uut.mes_all_valid;
    assign uut.mes_all_valid = 0;
    disp_LS_msg_old = disp_LS_msg;
    assign disp_LS_msg = 0;
  end
  else
  begin
    deassign uut.mes_all_valid ;
    uut.mes_all_valid = mes_all_valid_old;
    deassign disp_LS_msg;
    disp_LS_msg = disp_LS_msg_old;
    `ifdef SNPS_SUPPORT_UPF_SIM
    disp_LS_msg = 1'b1;
     `endif
  end
end


wire ADR_valid;
assign ADR_valid =  (ADR_buf <= 14'b11111111111111 )?1'b1:1'b0;

real t0_pfirst, t1_pfirst, t2_pnow, t2_nnow, t3_me;
initial
begin
  t0_pfirst = 0.0;
  t1_pfirst = 0.0;
  t2_pnow = 0.0;
  t2_nnow = 0.0;
  t3_me = 0.0;
end

always @(posedge CLK_buf)
begin
  t0_pfirst = t1_pfirst;
  t1_pfirst = t2_pnow;
  t2_pnow = $realtime;
  if ((t1_pfirst < t3_me) && (t3_me < t2_pnow))
  begin   
    uut.diff_me_tch = 1'b1;
  end
  if ((t0_pfirst < t3_me) && (t3_me < t2_pnow))
  begin   
    uut.diff_me_tcc = 1'b1;
  end
    @(negedge CLK_buf)
    t2_nnow = $realtime;
    #0.001;
    uut.diff_me_tch = 1'b0;
    uut.diff_me_tcc = 1'b0;
end

always @(ME_buf)
begin
  t3_me = $realtime;
  if ((t2_pnow < t3_me) && (t2_nnow < t3_me))
  begin   
    uut.diff_me_tch = 1'b1;
  end
end
// Setup/hold conditions for synchronous signals
reg  ME_pre,WE_pre;
reg  [13:0] ADR_pre;
reg  [7:0] D_pre;
reg flag_ADR_x;

always @(ME_buf or negedge CLK_buf) 
begin : blk_mebuf_0
  if ( CLK_buf == 1'b0)
  begin
    ME_pre = ME_buf;
  end // if of CLK_buf = 0
end // end of always block blk_mebuf_0

always @(WE_buf or negedge CLK_buf) 
begin : blk_webuf_0
  if ( CLK_buf == 1'b0)
  begin
    WE_pre = WE_buf;
  end // if of CLK_buf = 0
end // end of always block blk_webuf_0

always @(ADR_buf or negedge CLK_buf) 
begin : blk_addrbuf_0
  if ( CLK_buf == 1'b0)
  begin
    ADR_pre = ADR_buf;
  end // if of CLK_buf = 0
  if ( (^ADR_buf) === 1'bx)
  begin
    flag_ADR_x = 1'b1;
  end
  else
  begin
    flag_ADR_x = 1'b0;
  end
end // end of always block blk_addrbuf_0

always @(D_buf or negedge CLK_buf) 
begin : blk_dibuf_0
  if ( CLK_buf == 1'b0)
  begin
    D_pre = D_buf;
  end // if of CLK_buf = 0
end // end of always block blk_dibuf_0

`ifdef VIRAGE_FAST_VERILOG
`else
// Setup/hold condition for Address: ADR is : ENADR
wire ENADR;
assign ENADR = ( ME_pre !== 1'b0  && (LS_buf === 1'b0) ? 1'b1 : 1'b0 );
 
// Setup/hold condition for Memory Enable: ME is : ENME
wire ENME;
assign ENME = (( (ADR_valid || flag_ADR_x)) ? 1'b1 : 1'b0 );

// Setup/hold condition for Write Enable: WE is : ENWE
wire ENWE;
assign ENWE = (( ME_pre !== 1'b0   && (LS_buf === 1'b0) ) ?1'b1:1'b0);

// Setup/hold condition for Data In: D is : END
wire END;
assign END = (( ADR_valid && ME_pre !== 1'b0 && WE_pre !== 1'b0   && (LS_buf === 1'b0) )?1'b1:1'b0) ;
// Setup/hold condition for test1 Vector: TEST1 is : ENTEST1
wire ENTEST1;
assign ENTEST1 = ((ME_pre !== 1'b0 && ADR_valid  && (LS_buf === 1'b0))?1'b1:1'b0);
 
// Setup/hold condition for test_rnm Vector: TEST_RNM is : ENTEST_RNM
wire ENTEST_RNM;
assign ENTEST_RNM = ((ME_pre !== 1'b0   && (LS_buf === 1'b0))?1'b1:1'b0);
 
// Setup/hold condition for Read Margin Vector: RM is : ENRM
wire ENRM;
assign ENRM = ((RME_buf === 1'b1 && (ME_pre !== 1'b0 && ADR_valid  && (LS_buf === 1'b0)))?1'b1:1'b0);
// Setup/hold condition for Read Margin Vector Enable: RME is : ENRME
wire ENRME;
assign ENRME = ((ME_pre !== 1'b0 && ADR_valid  && (LS_buf === 1'b0))?1'b1:1'b0);
// Setup/hold condition for Write Assist Vector: WA is : ENWA
wire ENWA;
assign ENWA = (((WE_pre !== 1'b0 && ME_pre !== 1'b0  && (LS_buf === 1'b0)))?1'b1:1'b0);
// Setup/hold condition for Write Pulse Vector: WPULSE is : ENWPULSE
wire ENWPULSE;
assign ENWPULSE = (((WE_pre !== 1'b0 && ME_pre !== 1'b0  && (LS_buf === 1'b0)))?1'b1:1'b0);
// Setup/hold condition for BC0 Vector: BC0 is : ENBC0
wire ENBC0;
assign ENBC0 = ((LS_buf !== 1'b0)?1'b1:1'b0);
// Setup/hold condition for BC1 Vector: BC1 is : ENBC1
wire ENBC1;
assign ENBC1 = ((LS_buf !== 1'b0)?1'b1:1'b0);
// Setup/hold condition for BC2 Vector: BC2 is : ENBC2
wire ENBC2;
assign ENBC2 = ((LS_buf !== 1'b0)?1'b1:1'b0);
// Setup/hold condition for Light Sleep: LS is : ENLS_BC0_0
wire ENLS_BC0_0;
assign ENLS_BC0_0 = ((ME_pre !== 1'b0 && BC0_buf !== 1'b1)?1'b1:1'b0);
// Setup/hold condition for Light Sleep: LS is : ENLS_BC0_1
wire ENLS_BC0_1;
assign ENLS_BC0_1 = ((ME_pre !== 1'b0 && BC0_buf !== 1'b0)?1'b1:1'b0);

wire ENCLK;
assign ENCLK = (( (TEST1_buf === 1'b0))?1'b1:1'b0);
wire ENCLK_test1;
assign ENCLK_test1 = (( (TEST1_buf === 1'b1))?1'b1:1'b0);

wire ENCLK_rmezo,ENCLK_rm0,ENCLK_rm1,ENCLK_rm2,ENCLK_rm3,ENCLK_rm4,ENCLK_rm5;
assign ENCLK_rmezo = ((RME_buf !== 1'b1 && ( WA_buf[0] !== 1'b1 && WA_buf[1] !== 1'b0 ) && ( WPULSE_buf[0] !== 1'b1 && WPULSE_buf[1] !== 1'b1 && WPULSE_buf[2] !== 1'b1 ))?1'b1:1'b0) ;

assign ENCLK_rm0 = ((RME_buf === 1'b1  && (RM_buf[0] !== 1'b1 && RM_buf[1] !== 1'b1 && RM_buf[2] !== 1'b1 && RM_buf[3] !== 1'b1) && ( WA_buf[0] !== 1'b0 && WA_buf[1] !== 1'b0 ) && ( WPULSE_buf[0] !== 1'b1 && WPULSE_buf[1] !== 1'b1 && WPULSE_buf[2] !== 1'b1 ))?1'b1:1'b0) ;
assign ENCLK_rm1 = ((RME_buf === 1'b1  && (RM_buf[0] !== 1'b0 && RM_buf[1] !== 1'b1 && RM_buf[2] !== 1'b1 && RM_buf[3] !== 1'b1) && ( WA_buf[0] !== 1'b0 && WA_buf[1] !== 1'b0 ) && ( WPULSE_buf[0] !== 1'b1 && WPULSE_buf[1] !== 1'b1 && WPULSE_buf[2] !== 1'b1 ))?1'b1:1'b0) ;
assign ENCLK_rm2 = ((RME_buf === 1'b1  && (RM_buf[0] !== 1'b1 && RM_buf[1] !== 1'b0 && RM_buf[2] !== 1'b1 && RM_buf[3] !== 1'b1) && ( WA_buf[0] !== 1'b1 && WA_buf[1] !== 1'b0 ) && ( WPULSE_buf[0] !== 1'b1 && WPULSE_buf[1] !== 1'b1 && WPULSE_buf[2] !== 1'b1 ))?1'b1:1'b0) ;
assign ENCLK_rm3 = ((RME_buf === 1'b1  && (RM_buf[0] !== 1'b0 && RM_buf[1] !== 1'b0 && RM_buf[2] !== 1'b1 && RM_buf[3] !== 1'b1) && ( WA_buf[0] !== 1'b1 && WA_buf[1] !== 1'b0 ) && ( WPULSE_buf[0] !== 1'b1 && WPULSE_buf[1] !== 1'b1 && WPULSE_buf[2] !== 1'b1 ))?1'b1:1'b0) ;
assign ENCLK_rm4 = ((RME_buf === 1'b1  && (RM_buf[0] !== 1'b1 && RM_buf[1] !== 1'b1 && RM_buf[2] !== 1'b0 && RM_buf[3] !== 1'b1) && ( WA_buf[0] !== 1'b0 && WA_buf[1] !== 1'b1 ) && ( WPULSE_buf[0] !== 1'b1 && WPULSE_buf[1] !== 1'b1 && WPULSE_buf[2] !== 1'b1 ))?1'b1:1'b0) ;
assign ENCLK_rm5 = ((RME_buf === 1'b1  && ((RM_buf[0] !== 1'b0 || RM_buf[1] !== 1'b0) && RM_buf[2] !== 1'b0 && RM_buf[3] !== 1'b1) && ( WA_buf[0] !== 1'b0 && WA_buf[1] !== 1'b1 ) && ( WPULSE_buf[0] !== 1'b1 && WPULSE_buf[1] !== 1'b1 && WPULSE_buf[2] !== 1'b1 ))?1'b1:1'b0) ;
`endif // endif of VIRAGE_FAST_VERILOG

reg LS_old;

`ifdef VIRAGE_FAST_VERILOG
`else
specify
 
  specparam
    Tac = 0.121,
    Tcax = 0.080,
    Td4c_l = 0.065,
    Td3c_l = 0.066,
    Td2c_l = 0.066,
    Td1c_l = 0.066,
    Td1c_h = 0.066,
    Td2c_h = 0.066,
    Td3c_h = 0.066,
    Td4c_h = 0.065,
    Tcd4x_l = 0.071,
    Tcd3x_l = 0.071,
    Tcd2x_l = 0.071,
    Tcd1x_l = 0.072,
    Tcd1x_h = 0.072,
    Tcd2x_h = 0.071,
    Tcd3x_h = 0.071,
    Tcd4x_h = 0.071,
    Twc = 0.094,
    Tcwx = 0.079,
    Tmc = 0.044,
    Tcmx = 0.017,
    Tcl = 0.081,
    Tcltest1 = 0.234,
    Tch = 0.100,
    Tchtest1 = 1.169,
    Tcc = 0.666,
    Tccrm0 = 1.298,
    Tccrm1 = 1.285,
    Tccrm2 = 0.898,
    Tccrm3 = 0.666,
    Tccrm4 = 0.651,
    Tccrm5 = 0.629,
    TT1C = 0.153,
    TCT1X = 1.298,
    Ttrnmc = 0.153,
    Tctrnmx = 1.298,
    Trmec = 0.321,
    Tcrmex = 0.001,
    Trmc = 0.321,
    Trm3c = 1.396,
    Tcrmx = 0.001,
    Tcrm3x = 1.298,
    Twac = -0.181,
    Tcwax = 1.298,
    Twpc = -0.213,
    Tcwpx = 1.298,
    Trlsc = 0.088,
    Tfls0c = 1.396,
    Tfls1c = 0.248,
    Tlsx = 0.100,
    Tbc0c = 1.396,
    Tbc1c = 0.166,
    Tbc2c = 0.166,
    Tcq = 0.536,
    Tcqx = 0.388,
    Tcqrm0 = 1.169,
    Tcqrm0x = 0.965,
    Tcqrm1 = 1.158,
    Tcqrm1x = 0.938,
    Tcqrm2 = 0.780,
    Tcqrm2x = 0.582,
    Tcqrm3 = 0.536,
    Tcqrm3x = 0.388,
    Tcqrm4 = 0.521,
    Tcqrm4x = 0.376,
    Tcqrm5 = 0.499,
    Tcqrm5x = 0.358,
    Tcqtest1x = 0.187,
    Tcqtest1 = 0.234;
     if (   !RME & !LS & !TEST1 )
       ( posedge CLK => (  Q[7]  : 1'bx )) = (  Tcq, Tcq, Tcqx, Tcq, Tcqx, Tcq );
     if (   !RME & !LS & !TEST1 )
       ( posedge CLK => (  Q[6]  : 1'bx )) = (  Tcq, Tcq, Tcqx, Tcq, Tcqx, Tcq );
     if (   !RME & !LS & !TEST1 )
       ( posedge CLK => (  Q[5]  : 1'bx )) = (  Tcq, Tcq, Tcqx, Tcq, Tcqx, Tcq );
     if (   !RME & !LS & !TEST1 )
       ( posedge CLK => (  Q[4]  : 1'bx )) = (  Tcq, Tcq, Tcqx, Tcq, Tcqx, Tcq );
     if (   !RME & !LS & !TEST1 )
       ( posedge CLK => (  Q[3]  : 1'bx )) = (  Tcq, Tcq, Tcqx, Tcq, Tcqx, Tcq );
     if (   !RME & !LS & !TEST1 )
       ( posedge CLK => (  Q[2]  : 1'bx )) = (  Tcq, Tcq, Tcqx, Tcq, Tcqx, Tcq );
     if (   !RME & !LS & !TEST1 )
       ( posedge CLK => (  Q[1]  : 1'bx )) = (  Tcq, Tcq, Tcqx, Tcq, Tcqx, Tcq );
     if (   !RME & !LS & !TEST1 )
       ( posedge CLK => (  Q[0]  : 1'bx )) = (  Tcq, Tcq, Tcqx, Tcq, Tcqx, Tcq );
     if (   RME & (!RM[0] & !RM[1] & !RM[2] & !RM[3]) & !LS & !TEST1 )
       ( posedge CLK => (  Q[7]  : 1'bx )) = (  Tcqrm0, Tcqrm0, Tcqrm0x, Tcqrm0, Tcqrm0x, Tcqrm0 );
     if (   RME & (!RM[0] & !RM[1] & !RM[2] & !RM[3]) & !LS & !TEST1 )
       ( posedge CLK => (  Q[6]  : 1'bx )) = (  Tcqrm0, Tcqrm0, Tcqrm0x, Tcqrm0, Tcqrm0x, Tcqrm0 );
     if (   RME & (!RM[0] & !RM[1] & !RM[2] & !RM[3]) & !LS & !TEST1 )
       ( posedge CLK => (  Q[5]  : 1'bx )) = (  Tcqrm0, Tcqrm0, Tcqrm0x, Tcqrm0, Tcqrm0x, Tcqrm0 );
     if (   RME & (!RM[0] & !RM[1] & !RM[2] & !RM[3]) & !LS & !TEST1 )
       ( posedge CLK => (  Q[4]  : 1'bx )) = (  Tcqrm0, Tcqrm0, Tcqrm0x, Tcqrm0, Tcqrm0x, Tcqrm0 );
     if (   RME & (!RM[0] & !RM[1] & !RM[2] & !RM[3]) & !LS & !TEST1 )
       ( posedge CLK => (  Q[3]  : 1'bx )) = (  Tcqrm0, Tcqrm0, Tcqrm0x, Tcqrm0, Tcqrm0x, Tcqrm0 );
     if (   RME & (!RM[0] & !RM[1] & !RM[2] & !RM[3]) & !LS & !TEST1 )
       ( posedge CLK => (  Q[2]  : 1'bx )) = (  Tcqrm0, Tcqrm0, Tcqrm0x, Tcqrm0, Tcqrm0x, Tcqrm0 );
     if (   RME & (!RM[0] & !RM[1] & !RM[2] & !RM[3]) & !LS & !TEST1 )
       ( posedge CLK => (  Q[1]  : 1'bx )) = (  Tcqrm0, Tcqrm0, Tcqrm0x, Tcqrm0, Tcqrm0x, Tcqrm0 );
     if (   RME & (!RM[0] & !RM[1] & !RM[2] & !RM[3]) & !LS & !TEST1 )
       ( posedge CLK => (  Q[0]  : 1'bx )) = (  Tcqrm0, Tcqrm0, Tcqrm0x, Tcqrm0, Tcqrm0x, Tcqrm0 );
     if (   RME & (RM[0] & !RM[1] & !RM[2] & !RM[3]) & !LS & !TEST1 )
       ( posedge CLK => (  Q[7]  : 1'bx )) = (  Tcqrm1, Tcqrm1, Tcqrm1x, Tcqrm1, Tcqrm1x, Tcqrm1 );
     if (   RME & (RM[0] & !RM[1] & !RM[2] & !RM[3]) & !LS & !TEST1 )
       ( posedge CLK => (  Q[6]  : 1'bx )) = (  Tcqrm1, Tcqrm1, Tcqrm1x, Tcqrm1, Tcqrm1x, Tcqrm1 );
     if (   RME & (RM[0] & !RM[1] & !RM[2] & !RM[3]) & !LS & !TEST1 )
       ( posedge CLK => (  Q[5]  : 1'bx )) = (  Tcqrm1, Tcqrm1, Tcqrm1x, Tcqrm1, Tcqrm1x, Tcqrm1 );
     if (   RME & (RM[0] & !RM[1] & !RM[2] & !RM[3]) & !LS & !TEST1 )
       ( posedge CLK => (  Q[4]  : 1'bx )) = (  Tcqrm1, Tcqrm1, Tcqrm1x, Tcqrm1, Tcqrm1x, Tcqrm1 );
     if (   RME & (RM[0] & !RM[1] & !RM[2] & !RM[3]) & !LS & !TEST1 )
       ( posedge CLK => (  Q[3]  : 1'bx )) = (  Tcqrm1, Tcqrm1, Tcqrm1x, Tcqrm1, Tcqrm1x, Tcqrm1 );
     if (   RME & (RM[0] & !RM[1] & !RM[2] & !RM[3]) & !LS & !TEST1 )
       ( posedge CLK => (  Q[2]  : 1'bx )) = (  Tcqrm1, Tcqrm1, Tcqrm1x, Tcqrm1, Tcqrm1x, Tcqrm1 );
     if (   RME & (RM[0] & !RM[1] & !RM[2] & !RM[3]) & !LS & !TEST1 )
       ( posedge CLK => (  Q[1]  : 1'bx )) = (  Tcqrm1, Tcqrm1, Tcqrm1x, Tcqrm1, Tcqrm1x, Tcqrm1 );
     if (   RME & (RM[0] & !RM[1] & !RM[2] & !RM[3]) & !LS & !TEST1 )
       ( posedge CLK => (  Q[0]  : 1'bx )) = (  Tcqrm1, Tcqrm1, Tcqrm1x, Tcqrm1, Tcqrm1x, Tcqrm1 );
     if (   RME & (!RM[0] & RM[1] & !RM[2] & !RM[3]) & !LS & !TEST1 )
       ( posedge CLK => (  Q[7]  : 1'bx )) = (  Tcqrm2, Tcqrm2, Tcqrm2x, Tcqrm2, Tcqrm2x, Tcqrm2 );
     if (   RME & (!RM[0] & RM[1] & !RM[2] & !RM[3]) & !LS & !TEST1 )
       ( posedge CLK => (  Q[6]  : 1'bx )) = (  Tcqrm2, Tcqrm2, Tcqrm2x, Tcqrm2, Tcqrm2x, Tcqrm2 );
     if (   RME & (!RM[0] & RM[1] & !RM[2] & !RM[3]) & !LS & !TEST1 )
       ( posedge CLK => (  Q[5]  : 1'bx )) = (  Tcqrm2, Tcqrm2, Tcqrm2x, Tcqrm2, Tcqrm2x, Tcqrm2 );
     if (   RME & (!RM[0] & RM[1] & !RM[2] & !RM[3]) & !LS & !TEST1 )
       ( posedge CLK => (  Q[4]  : 1'bx )) = (  Tcqrm2, Tcqrm2, Tcqrm2x, Tcqrm2, Tcqrm2x, Tcqrm2 );
     if (   RME & (!RM[0] & RM[1] & !RM[2] & !RM[3]) & !LS & !TEST1 )
       ( posedge CLK => (  Q[3]  : 1'bx )) = (  Tcqrm2, Tcqrm2, Tcqrm2x, Tcqrm2, Tcqrm2x, Tcqrm2 );
     if (   RME & (!RM[0] & RM[1] & !RM[2] & !RM[3]) & !LS & !TEST1 )
       ( posedge CLK => (  Q[2]  : 1'bx )) = (  Tcqrm2, Tcqrm2, Tcqrm2x, Tcqrm2, Tcqrm2x, Tcqrm2 );
     if (   RME & (!RM[0] & RM[1] & !RM[2] & !RM[3]) & !LS & !TEST1 )
       ( posedge CLK => (  Q[1]  : 1'bx )) = (  Tcqrm2, Tcqrm2, Tcqrm2x, Tcqrm2, Tcqrm2x, Tcqrm2 );
     if (   RME & (!RM[0] & RM[1] & !RM[2] & !RM[3]) & !LS & !TEST1 )
       ( posedge CLK => (  Q[0]  : 1'bx )) = (  Tcqrm2, Tcqrm2, Tcqrm2x, Tcqrm2, Tcqrm2x, Tcqrm2 );
     if (   RME & (RM[0] & RM[1] & !RM[2] & !RM[3]) & !LS & !TEST1 )
       ( posedge CLK => (  Q[7]  : 1'bx )) = (  Tcqrm3, Tcqrm3, Tcqrm3x, Tcqrm3, Tcqrm3x, Tcqrm3 );
     if (   RME & (RM[0] & RM[1] & !RM[2] & !RM[3]) & !LS & !TEST1 )
       ( posedge CLK => (  Q[6]  : 1'bx )) = (  Tcqrm3, Tcqrm3, Tcqrm3x, Tcqrm3, Tcqrm3x, Tcqrm3 );
     if (   RME & (RM[0] & RM[1] & !RM[2] & !RM[3]) & !LS & !TEST1 )
       ( posedge CLK => (  Q[5]  : 1'bx )) = (  Tcqrm3, Tcqrm3, Tcqrm3x, Tcqrm3, Tcqrm3x, Tcqrm3 );
     if (   RME & (RM[0] & RM[1] & !RM[2] & !RM[3]) & !LS & !TEST1 )
       ( posedge CLK => (  Q[4]  : 1'bx )) = (  Tcqrm3, Tcqrm3, Tcqrm3x, Tcqrm3, Tcqrm3x, Tcqrm3 );
     if (   RME & (RM[0] & RM[1] & !RM[2] & !RM[3]) & !LS & !TEST1 )
       ( posedge CLK => (  Q[3]  : 1'bx )) = (  Tcqrm3, Tcqrm3, Tcqrm3x, Tcqrm3, Tcqrm3x, Tcqrm3 );
     if (   RME & (RM[0] & RM[1] & !RM[2] & !RM[3]) & !LS & !TEST1 )
       ( posedge CLK => (  Q[2]  : 1'bx )) = (  Tcqrm3, Tcqrm3, Tcqrm3x, Tcqrm3, Tcqrm3x, Tcqrm3 );
     if (   RME & (RM[0] & RM[1] & !RM[2] & !RM[3]) & !LS & !TEST1 )
       ( posedge CLK => (  Q[1]  : 1'bx )) = (  Tcqrm3, Tcqrm3, Tcqrm3x, Tcqrm3, Tcqrm3x, Tcqrm3 );
     if (   RME & (RM[0] & RM[1] & !RM[2] & !RM[3]) & !LS & !TEST1 )
       ( posedge CLK => (  Q[0]  : 1'bx )) = (  Tcqrm3, Tcqrm3, Tcqrm3x, Tcqrm3, Tcqrm3x, Tcqrm3 );
     if (   RME & (!RM[0] & !RM[1] & RM[2] & !RM[3]) & !LS & !TEST1 )
       ( posedge CLK => (  Q[7]  : 1'bx )) = (  Tcqrm4, Tcqrm4, Tcqrm4x, Tcqrm4, Tcqrm4x, Tcqrm4 );
     if (   RME & (!RM[0] & !RM[1] & RM[2] & !RM[3]) & !LS & !TEST1 )
       ( posedge CLK => (  Q[6]  : 1'bx )) = (  Tcqrm4, Tcqrm4, Tcqrm4x, Tcqrm4, Tcqrm4x, Tcqrm4 );
     if (   RME & (!RM[0] & !RM[1] & RM[2] & !RM[3]) & !LS & !TEST1 )
       ( posedge CLK => (  Q[5]  : 1'bx )) = (  Tcqrm4, Tcqrm4, Tcqrm4x, Tcqrm4, Tcqrm4x, Tcqrm4 );
     if (   RME & (!RM[0] & !RM[1] & RM[2] & !RM[3]) & !LS & !TEST1 )
       ( posedge CLK => (  Q[4]  : 1'bx )) = (  Tcqrm4, Tcqrm4, Tcqrm4x, Tcqrm4, Tcqrm4x, Tcqrm4 );
     if (   RME & (!RM[0] & !RM[1] & RM[2] & !RM[3]) & !LS & !TEST1 )
       ( posedge CLK => (  Q[3]  : 1'bx )) = (  Tcqrm4, Tcqrm4, Tcqrm4x, Tcqrm4, Tcqrm4x, Tcqrm4 );
     if (   RME & (!RM[0] & !RM[1] & RM[2] & !RM[3]) & !LS & !TEST1 )
       ( posedge CLK => (  Q[2]  : 1'bx )) = (  Tcqrm4, Tcqrm4, Tcqrm4x, Tcqrm4, Tcqrm4x, Tcqrm4 );
     if (   RME & (!RM[0] & !RM[1] & RM[2] & !RM[3]) & !LS & !TEST1 )
       ( posedge CLK => (  Q[1]  : 1'bx )) = (  Tcqrm4, Tcqrm4, Tcqrm4x, Tcqrm4, Tcqrm4x, Tcqrm4 );
     if (   RME & (!RM[0] & !RM[1] & RM[2] & !RM[3]) & !LS & !TEST1 )
       ( posedge CLK => (  Q[0]  : 1'bx )) = (  Tcqrm4, Tcqrm4, Tcqrm4x, Tcqrm4, Tcqrm4x, Tcqrm4 );
     if (   RME & ((RM[0] | RM[1]) & RM[2] & !RM[3]) & !LS & !TEST1 )
       ( posedge CLK => (  Q[7]  : 1'bx )) = (  Tcqrm5, Tcqrm5, Tcqrm5x, Tcqrm5, Tcqrm5x, Tcqrm5 );
     if (   RME & ((RM[0] | RM[1]) & RM[2] & !RM[3]) & !LS & !TEST1 )
       ( posedge CLK => (  Q[6]  : 1'bx )) = (  Tcqrm5, Tcqrm5, Tcqrm5x, Tcqrm5, Tcqrm5x, Tcqrm5 );
     if (   RME & ((RM[0] | RM[1]) & RM[2] & !RM[3]) & !LS & !TEST1 )
       ( posedge CLK => (  Q[5]  : 1'bx )) = (  Tcqrm5, Tcqrm5, Tcqrm5x, Tcqrm5, Tcqrm5x, Tcqrm5 );
     if (   RME & ((RM[0] | RM[1]) & RM[2] & !RM[3]) & !LS & !TEST1 )
       ( posedge CLK => (  Q[4]  : 1'bx )) = (  Tcqrm5, Tcqrm5, Tcqrm5x, Tcqrm5, Tcqrm5x, Tcqrm5 );
     if (   RME & ((RM[0] | RM[1]) & RM[2] & !RM[3]) & !LS & !TEST1 )
       ( posedge CLK => (  Q[3]  : 1'bx )) = (  Tcqrm5, Tcqrm5, Tcqrm5x, Tcqrm5, Tcqrm5x, Tcqrm5 );
     if (   RME & ((RM[0] | RM[1]) & RM[2] & !RM[3]) & !LS & !TEST1 )
       ( posedge CLK => (  Q[2]  : 1'bx )) = (  Tcqrm5, Tcqrm5, Tcqrm5x, Tcqrm5, Tcqrm5x, Tcqrm5 );
     if (   RME & ((RM[0] | RM[1]) & RM[2] & !RM[3]) & !LS & !TEST1 )
       ( posedge CLK => (  Q[1]  : 1'bx )) = (  Tcqrm5, Tcqrm5, Tcqrm5x, Tcqrm5, Tcqrm5x, Tcqrm5 );
     if (   RME & ((RM[0] | RM[1]) & RM[2] & !RM[3]) & !LS & !TEST1 )
       ( posedge CLK => (  Q[0]  : 1'bx )) = (  Tcqrm5, Tcqrm5, Tcqrm5x, Tcqrm5, Tcqrm5x, Tcqrm5 );
     if ( !LS & TEST1 )
       ( posedge CLK => (  Q[7]  : 1'bx )) = (  Tcqtest1x, Tcqtest1x );
     if ( !LS & TEST1 )
       ( posedge CLK => (  Q[6]  : 1'bx )) = (  Tcqtest1x, Tcqtest1x );
     if ( !LS & TEST1 )
       ( posedge CLK => (  Q[5]  : 1'bx )) = (  Tcqtest1x, Tcqtest1x );
     if ( !LS & TEST1 )
       ( posedge CLK => (  Q[4]  : 1'bx )) = (  Tcqtest1x, Tcqtest1x );
     if ( !LS & TEST1 )
       ( posedge CLK => (  Q[3]  : 1'bx )) = (  Tcqtest1x, Tcqtest1x );
     if ( !LS & TEST1 )
       ( posedge CLK => (  Q[2]  : 1'bx )) = (  Tcqtest1x, Tcqtest1x );
     if ( !LS & TEST1 )
       ( posedge CLK => (  Q[1]  : 1'bx )) = (  Tcqtest1x, Tcqtest1x );
     if ( !LS & TEST1 )
       ( posedge CLK => (  Q[0]  : 1'bx )) = (  Tcqtest1x, Tcqtest1x );
     if ( !LS & TEST1 )
       ( negedge CLK => (  Q[7]  : 1'bx )) = (  Tcqtest1, Tcqtest1 );
     if ( !LS & TEST1 )
       ( negedge CLK => (  Q[6]  : 1'bx )) = (  Tcqtest1, Tcqtest1 );
     if ( !LS & TEST1 )
       ( negedge CLK => (  Q[5]  : 1'bx )) = (  Tcqtest1, Tcqtest1 );
     if ( !LS & TEST1 )
       ( negedge CLK => (  Q[4]  : 1'bx )) = (  Tcqtest1, Tcqtest1 );
     if ( !LS & TEST1 )
       ( negedge CLK => (  Q[3]  : 1'bx )) = (  Tcqtest1, Tcqtest1 );
     if ( !LS & TEST1 )
       ( negedge CLK => (  Q[2]  : 1'bx )) = (  Tcqtest1, Tcqtest1 );
     if ( !LS & TEST1 )
       ( negedge CLK => (  Q[1]  : 1'bx )) = (  Tcqtest1, Tcqtest1 );
     if ( !LS & TEST1 )
       ( negedge CLK => (  Q[0]  : 1'bx )) = (  Tcqtest1, Tcqtest1 );

// Timing Checks

  $width (negedge CLK &&& ENCLK, Tcl, 0, notif_clk);
  $width (negedge CLK &&& ENCLK_test1, Tcltest1, 0, notif_clk);
  $width (posedge CLK &&& ENCLK, Tch, 0, notif_clk);
  $width (posedge CLK &&& ENCLK_test1, Tchtest1, 0, notif_clk);
  $period (posedge CLK &&& ENCLK_rmezo, Tcc, notif_clkp);
  $period (negedge CLK &&& ENCLK_rmezo, Tcc, notif_clk);
  $period (posedge CLK &&& ENCLK_rm0, Tccrm0, notif_clkp);
  $period (negedge CLK &&& ENCLK_rm0, Tccrm0, notif_clk);
  $period (posedge CLK &&& ENCLK_rm1, Tccrm1, notif_clkp);
  $period (negedge CLK &&& ENCLK_rm1, Tccrm1, notif_clk);
  $period (posedge CLK &&& ENCLK_rm2, Tccrm2, notif_clkp);
  $period (negedge CLK &&& ENCLK_rm2, Tccrm2, notif_clk);
  $period (posedge CLK &&& ENCLK_rm3, Tccrm3, notif_clkp);
  $period (negedge CLK &&& ENCLK_rm3, Tccrm3, notif_clk);
  $period (posedge CLK &&& ENCLK_rm4, Tccrm4, notif_clkp);
  $period (negedge CLK &&& ENCLK_rm4, Tccrm4, notif_clk);
  $period (posedge CLK &&& ENCLK_rm5, Tccrm5, notif_clkp);
  $period (negedge CLK &&& ENCLK_rm5, Tccrm5, notif_clk);
  $setuphold (posedge CLK  &&& ENADR, posedge ADR[0], Tac, Tcax, notif_adr,,, delayed_CLK, delayed_ADR[0] );
  $setuphold (posedge CLK  &&& ENADR, negedge ADR[0], Tac, Tcax, notif_adr,,, delayed_CLK, delayed_ADR[0] );
  $setuphold (posedge CLK  &&& ENADR, posedge ADR[1], Tac, Tcax, notif_adr,,, delayed_CLK, delayed_ADR[1] );
  $setuphold (posedge CLK  &&& ENADR, negedge ADR[1], Tac, Tcax, notif_adr,,, delayed_CLK, delayed_ADR[1] );
  $setuphold (posedge CLK  &&& ENADR, posedge ADR[2], Tac, Tcax, notif_adr,,, delayed_CLK, delayed_ADR[2] );
  $setuphold (posedge CLK  &&& ENADR, negedge ADR[2], Tac, Tcax, notif_adr,,, delayed_CLK, delayed_ADR[2] );
  $setuphold (posedge CLK  &&& ENADR, posedge ADR[3], Tac, Tcax, notif_adr,,, delayed_CLK, delayed_ADR[3] );
  $setuphold (posedge CLK  &&& ENADR, negedge ADR[3], Tac, Tcax, notif_adr,,, delayed_CLK, delayed_ADR[3] );
  $setuphold (posedge CLK  &&& ENADR, posedge ADR[4], Tac, Tcax, notif_adr,,, delayed_CLK, delayed_ADR[4] );
  $setuphold (posedge CLK  &&& ENADR, negedge ADR[4], Tac, Tcax, notif_adr,,, delayed_CLK, delayed_ADR[4] );
  $setuphold (posedge CLK  &&& ENADR, posedge ADR[5], Tac, Tcax, notif_adr,,, delayed_CLK, delayed_ADR[5] );
  $setuphold (posedge CLK  &&& ENADR, negedge ADR[5], Tac, Tcax, notif_adr,,, delayed_CLK, delayed_ADR[5] );
  $setuphold (posedge CLK  &&& ENADR, posedge ADR[6], Tac, Tcax, notif_adr,,, delayed_CLK, delayed_ADR[6] );
  $setuphold (posedge CLK  &&& ENADR, negedge ADR[6], Tac, Tcax, notif_adr,,, delayed_CLK, delayed_ADR[6] );
  $setuphold (posedge CLK  &&& ENADR, posedge ADR[7], Tac, Tcax, notif_adr,,, delayed_CLK, delayed_ADR[7] );
  $setuphold (posedge CLK  &&& ENADR, negedge ADR[7], Tac, Tcax, notif_adr,,, delayed_CLK, delayed_ADR[7] );
  $setuphold (posedge CLK  &&& ENADR, posedge ADR[8], Tac, Tcax, notif_adr,,, delayed_CLK, delayed_ADR[8] );
  $setuphold (posedge CLK  &&& ENADR, negedge ADR[8], Tac, Tcax, notif_adr,,, delayed_CLK, delayed_ADR[8] );
  $setuphold (posedge CLK  &&& ENADR, posedge ADR[9], Tac, Tcax, notif_adr,,, delayed_CLK, delayed_ADR[9] );
  $setuphold (posedge CLK  &&& ENADR, negedge ADR[9], Tac, Tcax, notif_adr,,, delayed_CLK, delayed_ADR[9] );
  $setuphold (posedge CLK  &&& ENADR, posedge ADR[10], Tac, Tcax, notif_adr,,, delayed_CLK, delayed_ADR[10] );
  $setuphold (posedge CLK  &&& ENADR, negedge ADR[10], Tac, Tcax, notif_adr,,, delayed_CLK, delayed_ADR[10] );
  $setuphold (posedge CLK  &&& ENADR, posedge ADR[11], Tac, Tcax, notif_adr,,, delayed_CLK, delayed_ADR[11] );
  $setuphold (posedge CLK  &&& ENADR, negedge ADR[11], Tac, Tcax, notif_adr,,, delayed_CLK, delayed_ADR[11] );
  $setuphold (posedge CLK  &&& ENADR, posedge ADR[12], Tac, Tcax, notif_adr,,, delayed_CLK, delayed_ADR[12] );
  $setuphold (posedge CLK  &&& ENADR, negedge ADR[12], Tac, Tcax, notif_adr,,, delayed_CLK, delayed_ADR[12] );
  $setuphold (posedge CLK  &&& ENADR, posedge ADR[13], Tac, Tcax, notif_adr,,, delayed_CLK, delayed_ADR[13] );
  $setuphold (posedge CLK  &&& ENADR, negedge ADR[13], Tac, Tcax, notif_adr,,, delayed_CLK, delayed_ADR[13] );
  $setuphold (posedge CLK  &&& END, posedge D[0], Td4c_l, Tcd4x_l, notif_d_0,,, delayed_CLK, delayed_D[0] );
  $setuphold (posedge CLK  &&& END, negedge D[0], Td4c_l, Tcd4x_l, notif_d_0,,, delayed_CLK, delayed_D[0] );
  $setuphold (posedge CLK  &&& END, posedge D[1], Td3c_l, Tcd3x_l, notif_d_1,,, delayed_CLK, delayed_D[1] );
  $setuphold (posedge CLK  &&& END, negedge D[1], Td3c_l, Tcd3x_l, notif_d_1,,, delayed_CLK, delayed_D[1] );
  $setuphold (posedge CLK  &&& END, posedge D[2], Td2c_l, Tcd2x_l, notif_d_2,,, delayed_CLK, delayed_D[2] );
  $setuphold (posedge CLK  &&& END, negedge D[2], Td2c_l, Tcd2x_l, notif_d_2,,, delayed_CLK, delayed_D[2] );
  $setuphold (posedge CLK  &&& END, posedge D[3], Td1c_l, Tcd1x_l, notif_d_3,,, delayed_CLK, delayed_D[3] );
  $setuphold (posedge CLK  &&& END, negedge D[3], Td1c_l, Tcd1x_l, notif_d_3,,, delayed_CLK, delayed_D[3] );
  $setuphold (posedge CLK  &&& END, posedge D[4], Td1c_h, Tcd1x_h, notif_d_4,,, delayed_CLK, delayed_D[4] );
  $setuphold (posedge CLK  &&& END, negedge D[4], Td1c_h, Tcd1x_h, notif_d_4,,, delayed_CLK, delayed_D[4] );
  $setuphold (posedge CLK  &&& END, posedge D[5], Td2c_h, Tcd2x_h, notif_d_5,,, delayed_CLK, delayed_D[5] );
  $setuphold (posedge CLK  &&& END, negedge D[5], Td2c_h, Tcd2x_h, notif_d_5,,, delayed_CLK, delayed_D[5] );
  $setuphold (posedge CLK  &&& END, posedge D[6], Td3c_h, Tcd3x_h, notif_d_6,,, delayed_CLK, delayed_D[6] );
  $setuphold (posedge CLK  &&& END, negedge D[6], Td3c_h, Tcd3x_h, notif_d_6,,, delayed_CLK, delayed_D[6] );
  $setuphold (posedge CLK  &&& END, posedge D[7], Td4c_h, Tcd4x_h, notif_d_7,,, delayed_CLK, delayed_D[7] );
  $setuphold (posedge CLK  &&& END, negedge D[7], Td4c_h, Tcd4x_h, notif_d_7,,, delayed_CLK, delayed_D[7] );
  $setuphold (posedge CLK  &&& ENWE, posedge WE,Twc, Tcwx, notif_we,,, delayed_CLK, delayed_WE );
  $setuphold (posedge CLK  &&& ENWE, negedge WE,Twc, Tcwx, notif_we,,, delayed_CLK, delayed_WE );
  $setuphold (posedge CLK  &&& ENME, posedge ME,Tmc, Tcmx, notif_me,,, delayed_CLK, delayed_ME );
  $setuphold (posedge CLK  &&& ENME, negedge ME,Tmc, Tcmx, notif_me,,, delayed_CLK, delayed_ME );
  $setuphold (posedge CLK  &&& ENTEST1, posedge TEST1,TT1C, 0, notif_test1,,, delayed_CLK, delayed_TEST1 );
  $setuphold (posedge CLK  &&& ENTEST1, negedge TEST1,TT1C, 0, notif_test1,,, delayed_CLK, delayed_TEST1 );
  $setuphold (negedge CLK  &&& ENTEST1, posedge TEST1,0, TCT1X, notif_test1,,, delayed_CLK, delayed_TEST1 );
  $setuphold (negedge CLK  &&& ENTEST1, negedge TEST1,0, TCT1X, notif_test1,,, delayed_CLK, delayed_TEST1 );
  $setuphold (posedge CLK  &&& ENTEST_RNM, posedge TEST_RNM,Ttrnmc, Tctrnmx, notif_test_rnm,,, delayed_CLK, delayed_TEST_RNM );
  $setuphold (posedge CLK  &&& ENTEST_RNM, negedge TEST_RNM,Ttrnmc, Tctrnmx, notif_test_rnm,,, delayed_CLK, delayed_TEST_RNM );
  $setuphold (posedge CLK  &&& ENRME, posedge RME,Trmec, Tcrmex, notif_rme,,, delayed_CLK, delayed_RME );
  $setuphold (posedge CLK  &&& ENRME, negedge RME,Trmec, Tcrmex, notif_rme,,, delayed_CLK, delayed_RME );
  $setuphold (posedge CLK  &&& ENRM, posedge RM[0], Trmc, Tcrmx, notif_rm,,, delayed_CLK, delayed_RM[0] );
  $setuphold (posedge CLK  &&& ENRM, negedge RM[0], Trmc, Tcrmx, notif_rm,,, delayed_CLK, delayed_RM[0] );
  $setuphold (posedge CLK  &&& ENRM, posedge RM[1], Trmc, Tcrmx, notif_rm,,, delayed_CLK, delayed_RM[1] );
  $setuphold (posedge CLK  &&& ENRM, negedge RM[1], Trmc, Tcrmx, notif_rm,,, delayed_CLK, delayed_RM[1] );
  $setuphold (posedge CLK  &&& ENRM, posedge RM[2], Trmc, Tcrmx, notif_rm,,, delayed_CLK, delayed_RM[2] );
  $setuphold (posedge CLK  &&& ENRM, negedge RM[2], Trmc, Tcrmx, notif_rm,,, delayed_CLK, delayed_RM[2] );
  $setuphold (posedge CLK  &&& ENRM, posedge RM[3], Trm3c, Tcrm3x, notif_rm,,, delayed_CLK, delayed_RM[3] );
  $setuphold (posedge CLK  &&& ENRM, negedge RM[3], Trm3c, Tcrm3x, notif_rm,,, delayed_CLK, delayed_RM[3] );
  $setuphold (posedge CLK  &&& ENWA, posedge WA[0], Twac, Tcwax, notif_wa,,, delayed_CLK, delayed_WA[0] );
  $setuphold (posedge CLK  &&& ENWA, negedge WA[0], Twac, Tcwax, notif_wa,,, delayed_CLK, delayed_WA[0] );
  $setuphold (posedge CLK  &&& ENWA, posedge WA[1], Twac, Tcwax, notif_wa,,, delayed_CLK, delayed_WA[1] );
  $setuphold (posedge CLK  &&& ENWA, negedge WA[1], Twac, Tcwax, notif_wa,,, delayed_CLK, delayed_WA[1] );
  $setuphold (posedge CLK  &&& ENWPULSE, posedge WPULSE[0], Twpc, Tcwpx, notif_wpulse,,, delayed_CLK, delayed_WPULSE[0] );
  $setuphold (posedge CLK  &&& ENWPULSE, negedge WPULSE[0], Twpc, Tcwpx, notif_wpulse,,, delayed_CLK, delayed_WPULSE[0] );
  $setuphold (posedge CLK  &&& ENWPULSE, posedge WPULSE[1], Twpc, Tcwpx, notif_wpulse,,, delayed_CLK, delayed_WPULSE[1] );
  $setuphold (posedge CLK  &&& ENWPULSE, negedge WPULSE[1], Twpc, Tcwpx, notif_wpulse,,, delayed_CLK, delayed_WPULSE[1] );
  $setuphold (posedge CLK  &&& ENWPULSE, posedge WPULSE[2], Twpc, Tcwpx, notif_wpulse,,, delayed_CLK, delayed_WPULSE[2] );
  $setuphold (posedge CLK  &&& ENWPULSE, negedge WPULSE[2], Twpc, Tcwpx, notif_wpulse,,, delayed_CLK, delayed_WPULSE[2] );
  $setuphold (posedge CLK  &&& ENLS_BC0_0, posedge LS,Trlsc, Tlsx, notif_ls,,, delayed_CLK, delayed_LS );
  $setuphold (posedge CLK  &&& ENLS_BC0_0, negedge LS,Tfls0c, Tlsx, notif_ls,,, delayed_CLK, delayed_LS );
  $setuphold (posedge CLK  &&& ENLS_BC0_1, posedge LS,Trlsc, Tlsx, notif_ls,,, delayed_CLK, delayed_LS );
  $setuphold (posedge CLK  &&& ENLS_BC0_1, negedge LS,Tfls1c, Tlsx, notif_ls,,, delayed_CLK, delayed_LS );
  $setuphold (posedge CLK  &&& ENBC0, posedge BC0,Tbc0c, 0, notif_bc0,,, delayed_CLK, delayed_BC0 );
  $setuphold (posedge CLK  &&& ENBC0, negedge BC0,Tbc0c, 0, notif_bc0,,, delayed_CLK, delayed_BC0 );
  $setuphold (posedge CLK  &&& ENBC1, posedge BC1,Tbc1c, 0, notif_bc1,,, delayed_CLK, delayed_BC1 );
  $setuphold (posedge CLK  &&& ENBC1, negedge BC1,Tbc1c, 0, notif_bc1,,, delayed_CLK, delayed_BC1 );
  $setuphold (posedge CLK  &&& ENBC2, posedge BC2,Tbc2c, 0, notif_bc2,,, delayed_CLK, delayed_BC2 );
  $setuphold (posedge CLK  &&& ENBC2, negedge BC2,Tbc2c, 0, notif_bc2,,, delayed_CLK, delayed_BC2 );

endspecify
`endif // endif of VIRAGE_FAST_VERILOG
wire test1_ls_pwr, mux_ls;
assign test1_ls_pwr = ((uut.TEST1latched === 1'b1 && uut.MElatched === 1'b1 ) ) && LS_buf;
assign mux_ls = (test1_ls_pwr === 1'b1) ? LS_old : ((test1_ls_pwr === 1'b0) ? LS_buf : 1'bX);

wire [7:0] Q_mem;
assign Q_buf = Q_mem;
// Corrupt memory if BC0 assert during Light Mode or Deep Sleep Mode
always @(BC0_buf )
begin
 if(($test$plusargs("cpf_sim"))) 
  #0;
  if (LS_buf !== 1'b0)
  begin
    uut.corrupt_all_loc(`True);
    if( (MES_CNTRL=="ON" || MES_CNTRL=="WARN") && $realtime != 0 && uut.mes_all_valid)
    begin
      $display("\n%m<<VIRL_MEM_WARNING: Assertion on BC0 pin during Light Sleep Mode>>(time %0t)\n\n", $time);
    end
  end
  if (BC0_buf === 1'bX)
  begin
    uut.report_unknown("BC0");
    uut.corrupt_all_loc(`True);
  end
end
// Corrupt memory if BC1 or BC2 assert during Light Mode or Deep Sleep Mode
always @(BC1_buf or BC2_buf)
begin
  if (LS_buf !== 1'b0)
  begin
    uut.corrupt_all_loc(`True);
    if( (MES_CNTRL=="ON" || MES_CNTRL=="WARN") && $realtime != 0 && uut.mes_all_valid)
    begin
      $display("\n%m<<VIRL_MEM_WARNING: Assertion on BC1/BC2 pin during Light Sleep Mode>>(time %0t)\n\n", $time);
    end
  end
  if (BC1_buf === 1'bX)
  begin
    uut.report_unknown("BC1");
    uut.corrupt_all_loc(`True);
  end
  if (BC2_buf === 1'bX)
  begin
    uut.report_unknown("BC2");
    uut.corrupt_all_loc(`True);
  end
end


`ifdef VIRAGE_FAST_VERILOG
generic_behav_SNPS_SP_HD_16Kx8 #( MES_CNTRL, MemFault_Inj) uut (  .Q (Q_mem), .ADR (ADR_pre), .D (D_pre), .WE(WE_pre), .ME(ME_pre), .CLK(CLK_mem), .TEST1(TEST1_buf), .TEST_RNM(TEST_RNM_buf), .RME(RME_buf), .RM (RM_int), .WA (WA_buf), .WPULSE (WPULSE_buf), .LS(LS_buf), .BC0(BC0_buf), .BC1(BC1_buf), .BC2(BC2_buf) );
`else
generic_behav_SNPS_SP_HD_16Kx8 #( MES_CNTRL, MemFault_Inj) uut (  .Q (Q_mem), .ADR (ADR_pre), .D (D_pre), .WE(WE_pre), .ME(ME_pre), .CLK(CLK_mem), .TEST1(TEST1_buf), .TEST_RNM(TEST_RNM_buf), .RME(RME_buf), .RM (RM_int), .WA (WA_buf), .WPULSE (WPULSE_buf), .LS(LS_buf), .BC0(BC0_buf), .BC1(BC1_buf), .BC2(BC2_buf),.notif_adr(notif_adr), .notif_d(notif_d), .notif_we(notif_we), .notif_me(notif_me), .notif_clk(notif_clk), .notif_clkp(notif_clkp), .notif_test1(notif_test1), .notif_test_rnm(notif_test_rnm), .notif_rme(notif_rme), .notif_rm(notif_rm), .notif_wa(notif_wa), .notif_wpulse(notif_wpulse), .notif_ls(notif_ls), .notif_bc0(notif_bc0), .notif_bc1(notif_bc1), .notif_bc2(notif_bc2) );
`endif // endif of VIRAGE_FAST_VERILOG

initial
begin

  ADRFLAGA = 1;
end // end of initial block

always @ ( ADR_buf )
begin : blk_address_0
  if ( $realtime != 0)
  begin
    if ( ADR_buf > 14'b11111111111111) 
    begin
      ADRFLAGA = 0;
    end // if of address is out of range
    else
    begin
      ADRFLAGA = 1;
    end // else of if address is out of range
  end // if of $realtime != 0
end // end of always block blk_address_0

assign RM_int = ((RME_buf===1'b1)?RM_buf[2:0]:((RME_buf===1'b0)?3'b011:3'bx));
wire llsb;
assign llsb = (!(mux_ls) || BC0_buf);




initial
begin
disp_LS_msg = 1'b1;
end


// Display the warning when LS is 1.

always @ ( negedge LS_buf )
begin
  disp_LS_msg = 1'b1;
  disp_LS_msg_old = 1'b1;
end

always @ (posedge LS_buf or posedge CLK_buf)
begin : blk_ls_0
  if (LS_buf === 1'b1 && ME_pre !== 1'b0)
  begin
    if( (MES_CNTRL=="ON" || MES_CNTRL=="WARN") && disp_LS_msg === 1'b1 )
    begin
      $display("<<VIRL_MEM_WARNING:  No Operation as Memory is in Light Sleep mode.>> time=%0t instance=%m", $time);
      disp_LS_msg = 1'b0;
    end
  end // if LS = 1
end // end of always block blk_ls_0

always @(RM_buf[3])
begin
  if(RM_buf[3] === 1'bx)
  begin
    if( (MES_CNTRL =="ON" || MES_CNTRL == "WARN") && $realtime != 0 && uut.mes_all_valid)
    begin
      $display("<<VIRL_MEM_WARNING:RM[3] is unknown>> at time=%t; instance=%m (SNPS_SP_HD_16Kx8_core)",$realtime);
    end
  end
end

always @( negedge CLK_mem or LS_buf )
begin 
  if (CLK_mem == 1'b0)
  begin
    LS_old <= LS_buf;
  end
end

`ifdef VIRAGE_FAST_VERILOG
`else
assign notif_d = {notif_d_7, notif_d_6, notif_d_5, notif_d_4, notif_d_3, notif_d_2, notif_d_1, notif_d_0};
`endif // endif of VIRAGE_FAST_VERILOG

assign CLK_mem = CLK_buf;

endmodule
`endcelldefine 
`ifdef verifault 
`disable_portfaults 
`nosuppress_faults 
`endif 


`ifdef VIRAGE_FAST_VERILOG
module generic_behav_SNPS_SP_HD_16Kx8 (  Q, ADR, D, WE, ME, CLK, TEST1, TEST_RNM, RME, RM, WA, WPULSE, LS, BC0, BC1, BC2 );
`else
module generic_behav_SNPS_SP_HD_16Kx8 (  Q, ADR, D, WE, ME, CLK, TEST1, TEST_RNM, RME, RM, WA, WPULSE, LS, BC0, BC1, BC2,notif_adr, notif_d, notif_we, notif_me, notif_clk, notif_clkp, notif_test1, notif_test_rnm, notif_rme, notif_rm, notif_wa, notif_wpulse, notif_ls, notif_bc0, notif_bc1, notif_bc2 );
`endif // endif of VIRAGE_FAST_VERILOG

parameter MES_CNTRL = "ON";
parameter MemFault_Inj = 0;

parameter words = 16384, bits = 8, addrbits = 14, O_delay=0.0, timingmode = 1, rmbits=3, wabits=2, wpulsebits=3;

output [bits-1:0] Q;
input [addrbits-1:0] ADR;
input [bits-1:0] D;
input WE;
input ME;
input CLK;
input TEST1;
input TEST_RNM;
input RME;
input [rmbits-1:0] RM;
input [wabits-1:0] WA;
input [wpulsebits-1:0] WPULSE;
input LS;
input BC0;
input BC1;
input BC2;

`ifdef VIRAGE_FAST_VERILOG
`else
input [7:0] notif_d;
input notif_adr, notif_we, notif_me, notif_clk, notif_clkp, notif_test1, notif_test_rnm, notif_rme, notif_rm, notif_wa, notif_wpulse, notif_ls, notif_bc0, notif_bc1, notif_bc2;

`endif // endif of VIRAGE_FAST_VERILOG

parameter DataX = { bits { 1'bx } };
parameter DataZ = { bits { 1'bz } };



reg  [bits-1:0]  Q;
reg [addrbits-1:0] ADRlatched;

reg [addrbits-1:0] ADR_old;

reg [bits-1:0] Dlatched;

reg [bits-1:0] D_old;

reg WElatched;
reg WE_old;
reg MElatched;
reg ME_old;
reg TEST1latched;
reg TEST_RNMlatched;
reg TEST_RNM_old;
reg [wabits-1:0] WA_old;
reg [wabits-1:0] WAlatched;
reg [wpulsebits-1:0] WPULSE_old;
reg [wpulsebits-1:0] WPULSElatched;
reg diff_me_tch, diff_me_tcc;
reg TEST1_old;
reg disp_LS_msg;
reg
  flaga_read_ok,
  flaga_we_ok,
  flaga_d_ok,
  flaga_rm_ok,
  flaga_adr_ok,
  flaga_range_ok;
reg     flaga_clk_valid;
reg     flaga_viol;
event   ev_read_out_a_port;
event   ev_RST_out_a_port;
real CLK_TIME;
real CLKA_T;
wire   [7:0]  Q_temp;
reg    [7:0]  Q_local_tmp;
reg    [7:0]  Q_local_inj;
reg mes_all_valid;
integer i;
reg  [bits-1:0] mem_core_array [0:words -1];
reg [7:0] mem_core_array_read [0:16383];

reg  [bits-1:0] mem_fault_array_XOR [0:words -1];
reg  [bits-1:0] mem_fault_array_sa0 [0:words -1];
reg  [bits-1:0] mem_fault_array_sa1 [0:words -1];
reg faultinj_en;
initial
begin : reinit_fault_blk
  faultinj_en = 1'b0;
`ifdef MEMFAULTINJ
  faultinj_en = 1'b1;
`else
  if (MemFault_Inj == 1)
    faultinj_en = 1'b1;
`endif
  for (i=0; i< words ; i=i+1)
  begin
    if (faultinj_en == 1)
      mem_fault_array_XOR[i]=0;
    else
    begin
      mem_fault_array_sa0[i]={bits{1'b1}};
      mem_fault_array_sa1[i]=0;
    end
  end
  if (faultinj_en == 1)
  begin
    if ($test$plusargs("asap_error"))
    mem_fault_array_XOR[1] = 1'b1 << (bits - 1);
  end 
end



// Checks whether address input is Valid; 1-bit return value
function is_adr_Valid;  
input [addrbits-1:0] addr_to_check;
reg     ret_value;
begin
  ret_value = `True;
  if ((^addr_to_check) === 1'bx)
  begin
    ret_value = `False;
  end // if addr_to_check is X
  is_adr_Valid = ret_value;
end
endfunction

// -------------------------------------------------------------------
// Common tasks
// -------------------------------------------------------------------

// Task to report unknown messages
task report_unknown;
input [8*8:1] signal;
begin
    if( (MES_CNTRL=="ON" || MES_CNTRL=="ERR") && $realtime != 0 && mes_all_valid )
    begin
      $display("<<VIRL_MEM_ERR:%0s unknown>> at time=%t; instance=%m (RAMS1H)",signal,$realtime);
    end
end
endtask


task corrupt_q;
begin
  Q_local_tmp = 8'bx;
end
endtask

task corrupt_qnb;
begin
  Q_local_tmp <= 8'bx;
end
endtask

// Corrupt Current Location
task corrupt_cur_loc;
input[13:0] Adr_to_corrupt;
integer cnt;
begin
  if (is_adr_Valid (Adr_to_corrupt))
  begin
    mem_core_array[Adr_to_corrupt] = 8'bx;
  end // if of is_adr_Valid (Adr_to_corrupt)
  else
  begin
      corrupt_all_loc(`True);
  end // else of if is_adr_Valid (Adr_to_corrupt)
end
endtask

// Corrupt Entire memory; Do not corrupt entire memory if address is out of range
// during Write; For all other cases, if flag_range_ok is true, corrupt entire memory
task corrupt_all_loc;
input flag_range_ok;
integer row_index;
begin
  if( flag_range_ok == `True)
  begin
    for( row_index = 0; row_index < words ; row_index = row_index + 1)
    begin
      mem_core_array[row_index] = 8'bx;
    end // end of for row_index loop
  end // if of flag_range_ok is true
end
endtask


reg disp_msg_wa;
reg disp_msg_wpulse;
initial begin
  disp_msg_wa = 1'b1;
  disp_msg_wpulse = 1'b1;
end
always @(WA_old or RM)
begin
  disp_msg_wa = 1'b1;
end
always @(WPULSE_old or RM)
begin
  disp_msg_wpulse = 1'b1;
end
wire disp_msg_wr;
assign disp_msg_wr = disp_msg_wa | disp_msg_wpulse;

 
// Perform Assist pins recommended value check against database value.
task checkassist_write;
begin
  casex ({RME,RM})
     4'b1000 :
                          begin
                            if ((WAlatched !== 2'b11) && disp_msg_wa === 1'b1)
                            begin
                              if ((MES_CNTRL=="ON" || MES_CNTRL=="WARN") && $realtime != 0 && mes_all_valid)
                              begin
                                $display("<<VIRL_MEM_WARNING:WA = %b is not recommended value in RM0 mode. >> at time=%t; instance=%m",WAlatched,$realtime);
                                 disp_msg_wa = 1'b0;
                              end
                            end
                            if ((WPULSElatched !== 3'b000) && disp_msg_wpulse === 1'b1)
                            begin
                              if ((MES_CNTRL=="ON" || MES_CNTRL=="WARN") && $realtime != 0 && mes_all_valid)
                              begin
                                $display("<<VIRL_MEM_WARNING:WPULSE = %b is not recommended value in RM0 mode. >> at time=%t; instance=%m",WPULSElatched,$realtime);
                                 disp_msg_wpulse = 1'b0;
                              end
                            end
                          end

     4'b1001 :
                          begin
                            if ((WAlatched !== 2'b11) && disp_msg_wa === 1'b1)
                            begin
                              if ((MES_CNTRL=="ON" || MES_CNTRL=="WARN") && $realtime != 0 && mes_all_valid)
                              begin
                                $display("<<VIRL_MEM_WARNING:WA = %b is not recommended value in RM1 mode. >> at time=%t; instance=%m",WAlatched,$realtime);
                                 disp_msg_wa = 1'b0;
                              end
                            end
                            if ((WPULSElatched !== 3'b000) && disp_msg_wpulse === 1'b1)
                            begin
                              if ((MES_CNTRL=="ON" || MES_CNTRL=="WARN") && $realtime != 0 && mes_all_valid)
                              begin
                                $display("<<VIRL_MEM_WARNING:WPULSE = %b is not recommended value in RM1 mode. >> at time=%t; instance=%m",WPULSElatched,$realtime);
                                 disp_msg_wpulse = 1'b0;
                              end
                            end
                          end

     4'b1010 :
                          begin
                            if ((WAlatched !== 2'b10) && disp_msg_wa === 1'b1)
                            begin
                              if ((MES_CNTRL=="ON" || MES_CNTRL=="WARN") && $realtime != 0 && mes_all_valid)
                              begin
                                $display("<<VIRL_MEM_WARNING:WA = %b is not recommended value in RM2 mode. >> at time=%t; instance=%m",WAlatched,$realtime);
                                 disp_msg_wa = 1'b0;
                              end
                            end
                            if ((WPULSElatched !== 3'b000) && disp_msg_wpulse === 1'b1)
                            begin
                              if ((MES_CNTRL=="ON" || MES_CNTRL=="WARN") && $realtime != 0 && mes_all_valid)
                              begin
                                $display("<<VIRL_MEM_WARNING:WPULSE = %b is not recommended value in RM2 mode. >> at time=%t; instance=%m",WPULSElatched,$realtime);
                                 disp_msg_wpulse = 1'b0;
                              end
                            end
                          end

     4'b1011 :
                          begin
                            if ((WAlatched !== 2'b10) && disp_msg_wa === 1'b1)
                            begin
                              if ((MES_CNTRL=="ON" || MES_CNTRL=="WARN") && $realtime != 0 && mes_all_valid)
                              begin
                                $display("<<VIRL_MEM_WARNING:WA = %b is not recommended value in RM3 mode. >> at time=%t; instance=%m",WAlatched,$realtime);
                                 disp_msg_wa = 1'b0;
                              end
                            end
                            if ((WPULSElatched !== 3'b000) && disp_msg_wpulse === 1'b1)
                            begin
                              if ((MES_CNTRL=="ON" || MES_CNTRL=="WARN") && $realtime != 0 && mes_all_valid)
                              begin
                                $display("<<VIRL_MEM_WARNING:WPULSE = %b is not recommended value in RM3 mode. >> at time=%t; instance=%m",WPULSElatched,$realtime);
                                 disp_msg_wpulse = 1'b0;
                              end
                            end
                          end

     4'b1100 :
                          begin
                            if ((WAlatched !== 2'b01) && disp_msg_wa === 1'b1)
                            begin
                              if ((MES_CNTRL=="ON" || MES_CNTRL=="WARN") && $realtime != 0 && mes_all_valid)
                              begin
                                $display("<<VIRL_MEM_WARNING:WA = %b is not recommended value in RM4 mode. >> at time=%t; instance=%m",WAlatched,$realtime);
                                 disp_msg_wa = 1'b0;
                              end
                            end
                            if ((WPULSElatched !== 3'b000) && disp_msg_wpulse === 1'b1)
                            begin
                              if ((MES_CNTRL=="ON" || MES_CNTRL=="WARN") && $realtime != 0 && mes_all_valid)
                              begin
                                $display("<<VIRL_MEM_WARNING:WPULSE = %b is not recommended value in RM4 mode. >> at time=%t; instance=%m",WPULSElatched,$realtime);
                                 disp_msg_wpulse = 1'b0;
                              end
                            end
                          end

     4'b1111 , 4'b1110 , 4'b1101 :
                          begin
                            if ((WAlatched !== 2'b01) && disp_msg_wa === 1'b1)
                            begin
                              if ((MES_CNTRL=="ON" || MES_CNTRL=="WARN") && $realtime != 0 && mes_all_valid)
                              begin
                                $display("<<VIRL_MEM_WARNING:WA = %b is not recommended value in RM5 mode. >> at time=%t; instance=%m",WAlatched,$realtime);
                                 disp_msg_wa = 1'b0;
                              end
                            end
                            if ((WPULSElatched !== 3'b000) && disp_msg_wpulse === 1'b1)
                            begin
                              if ((MES_CNTRL=="ON" || MES_CNTRL=="WARN") && $realtime != 0 && mes_all_valid)
                              begin
                                $display("<<VIRL_MEM_WARNING:WPULSE = %b is not recommended value in RM5 mode. >> at time=%t; instance=%m",WPULSElatched,$realtime);
                                 disp_msg_wpulse = 1'b0;
                              end
                            end
                          end

     4'b0xxx :
                          begin
                            if ((WAlatched !== 2'b10) && disp_msg_wa === 1'b1)
                            begin
                              if ((MES_CNTRL=="ON" || MES_CNTRL=="WARN") && $realtime != 0 && mes_all_valid)
                              begin
                                $display("<<VIRL_MEM_WARNING:WA = %b is not recommended value. >> at time=%t; instance=%m",WAlatched,$realtime);
                                 disp_msg_wa = 1'b0;
                              end
                            end
                            if ((WPULSElatched !== 3'b000) && disp_msg_wpulse === 1'b1)
                            begin
                              if ((MES_CNTRL=="ON" || MES_CNTRL=="WARN") && $realtime != 0 && mes_all_valid)
                              begin
                                $display("<<VIRL_MEM_WARNING:WPULSE = %b is not recommended value. >> at time=%t; instance=%m",WPULSElatched,$realtime);
                                 disp_msg_wpulse = 1'b0;
                              end
                            end
                          end

  endcase
end
endtask

        

// Perform Sanity Check on Port A, Corrupt memory if required

task checkSanityOnAport;
begin

  #0;                // let CLOCK and NOTIFIER stuff execute first
  case ( {flaga_adr_ok, flaga_we_ok, flaga_d_ok} ) // only 1 and 0
    3'b111   : ;                                                // everything ok!!!
    3'b101,
    3'b100   : corrupt_cur_loc(ADRlatched);          // WE is unstable
    3'b110   : if (WElatched !== 1'b0)
                 corrupt_cur_loc(ADRlatched);         // Data is unstable
    3'b000,
    3'b001   : corrupt_all_loc(flaga_range_ok);            // ADR and WE unstable
    3'b010,
    3'b011   : corrupt_all_loc(flaga_range_ok);    // ADR unstable, WE stable
  endcase
    flaga_adr_ok = `True;
    flaga_we_ok  = `True;
    flaga_d_ok  = `True;
 end
endtask // end of task checkSanityOnAport

// PORT A FUNCTIONALITY (Handle violation behavior)


initial
begin : reinit_uut_blk
  flaga_adr_ok  = `True;
  flaga_range_ok = `True;
  flaga_we_ok   = `True;
  flaga_d_ok    = `True;
  flaga_read_ok = `True;
  flaga_rm_ok = `True;
  diff_me_tch = 1'b0;
  diff_me_tcc = 1'b0;
  flaga_viol = `False;
  flaga_clk_valid = `True;
end

`ifdef SNPS_SUPPORT_UPF_SIM
(* vcs_dont_reinit *)
`endif
initial 
begin
  Q_local_tmp <= 8'bx;
  mes_all_valid = 1'b0;
   disp_LS_msg = 1'b1;
end // end of initial block

// For Zerohold of ADR pin
always @( negedge CLK or ADR )
begin : blk_addrhold_0
if ( CLK == 1'b0 )
  begin
    ADR_old <= ADR;
  end // if of CLK = 0
end // end of always block blk_addrhold_0
// For Zerohold of D pin
always @( negedge CLK or D )
begin : blk_dihold_0
if ( CLK == 1'b0 )
  begin
    D_old <= D;
  end // if of CLK = 0
end // end of always block blk_dihold_0
// For Zerohold of WE pin
always @( negedge CLK or WE )
begin : blk_wehold_0
if ( CLK == 1'b0 )
  begin
    WE_old <= WE;
  end // if of CLK = 0
end // end of always block blk_wehold_0
// For Zerohold of ME pin
always @( negedge CLK or ME or LS  )
begin : blk_mehold_0
if ( CLK == 1'b0 )
  begin
    if ( (LS === 1'b1 && ME !== 1'bx))
      ME_old <= 1'b0;
    else
      ME_old <= ME;
  end // if of CLK = 0
end // end of always block blk_mehold_0
// For Zerohold of TEST_RNM pin
always @( negedge CLK or TEST_RNM )
begin : blk_test_rnmhold_0
if ( CLK == 1'b0 )
  begin
    TEST_RNM_old <= TEST_RNM;
  end // if of CLK = 0
end // end of always block blk_test_rnmhold_0
// For Zerohold of Write Assist pin
always @( negedge CLK or WA )
begin : blk_write_assisthold_0
  if ( CLK == 1'b0 )
  begin
    WA_old <= WA;
  end // if of CLK = 0
end // end of always block blk_write_assisthold_0

// For Zerohold of Write Pulse pin
always @( negedge CLK or WPULSE )
begin : blk_wpulse_hold_0
  if ( CLK == 1'b0 )
  begin
    WPULSE_old <= WPULSE;
  end // if of CLK = 0
end // end of always block blk_writepulse_hold_0

// For Zerohold of Test1 pin
always @( negedge CLK or TEST1 )
begin : blk_test1hold_0
  if ( CLK == 1'b0 )
  begin
    TEST1_old <= TEST1;
  end // if of CLK = 0
end // end of always block blk_test1hold_0


reg LS_old;
always @( negedge CLK or LS )
begin : blk_lshold_0
  if (CLK == 1'b0)
  begin
    LS_old <= LS;
  end
end // end of always block blk_lshold_0

`ifdef VIRAGE_FAST_VERILOG
`else
// PORT A WE violation
always @(notif_we)           
begin : blk_notif_we_0
    if ( WE_old === 1'b0)
    begin
      flaga_viol = `True;
    end // if of WE_old = 0
    flaga_we_ok = `False;
    checkSanityOnAport;
    flaga_read_ok = `False;
    -> ev_read_out_a_port;
    corrupt_qnb;
end // end of always block blk_notif_we_0

// PORT A CLK violation
always @(notif_clk)
begin : blk_notif_clk_0
if (diff_me_tch === 1'b1 || ME !== 1'b0)
begin
  flaga_clk_valid = `False;
  flaga_adr_ok = `False;
  flaga_we_ok  = `False;
  checkSanityOnAport;
  flaga_read_ok = `False;     // irrespective of WE
  -> ev_read_out_a_port;
  end // if (diff_me_tcc
end // end of always block blk_notif_clk_0

// PORT A CLK violation
always @(notif_clkp)
begin : blk_notif_clkp_0
if (diff_me_tcc === 1'b1 || ME !== 1'b0)
begin
  flaga_clk_valid = `False;
  flaga_adr_ok = `False;
  flaga_we_ok  = `False;
  checkSanityOnAport;
  flaga_read_ok = `False;     // irrespective of WE
  -> ev_read_out_a_port;
  end // if (diff_me_tcc
end // end of always block blk_notif_clk_0

// PORT A ME violation
always @(notif_me)           
begin : blk_notif_me_0
    flaga_viol = `True;
    flaga_read_ok = `False;                           
    -> ev_read_out_a_port;
    flaga_adr_ok = `False;
    checkSanityOnAport;
end // end of always block blk_notif_me_0

// PORT A ADR violation
always @(notif_adr)     
begin : blk_notif_addr_0
      flaga_viol = `True;
      flaga_read_ok = `False;                         
      -> ev_read_out_a_port;
      flaga_adr_ok = `False;
      corrupt_all_loc(`True);
end // end of always block blk_notif_addr_0

// PORT A D violation
genvar nk;
generate for (nk=0; nk<8; nk=nk+1)
begin : END_blk

reg [7:0]  tmp_D;

always @(notif_d[nk])
begin
    mem_core_array[ADR_old][nk] = 1'bX;
end // end of always block blk_notif_di_0
end 
endgenerate

//PORT A TEST1 violation
always @(notif_test1)   
begin : blk_notif_test1_0
//  ME_chk = ME_old;
  if ( WElatched === 1'b0 )
  begin
    flaga_viol = `True;
    flaga_read_ok = `False;
    -> ev_read_out_a_port;
  end
  else if ( WElatched === 1'b1 )
  begin
    flaga_d_ok  = `False;
    checkSanityOnAport;
  end
end // end of always block blk_notif_test1_0

// PORT A TEST_RNM violation
always @(notif_test_rnm)     
begin : blk_notif_test_rnm_0
  if (WE_old === 1'b0)
  begin
    flaga_read_ok = `False;                         
    -> ev_read_out_a_port;
  end
  flaga_adr_ok = `False;
  corrupt_all_loc(`True);
end // end of always block blk_notif_test_rnm_0

always @(notif_ls)
begin
  corrupt_all_loc(`True);
  flaga_read_ok = `False;
  -> ev_read_out_a_port;
end

always @(notif_bc0)
begin : blk_notif_bc0_0
  flaga_we_ok  = `False;
  corrupt_all_loc(`True);
end  // blk_notif_bc0_0
always @(notif_bc1 or notif_bc2)
begin : blk_notif_bc1bc2_0
  flaga_we_ok  = `False;
  corrupt_all_loc(`True);
end  // blk_notif_bc1bc2_0

//PORT A RM violation
always @(notif_rm)       
begin : blk_notif_rm_0
    flaga_viol = `True;
    flaga_read_ok = `False;
    -> ev_read_out_a_port;
    flaga_d_ok  = `False;
    checkSanityOnAport;
end // end of always block blk_notif_rm_0

//PORT A RME violation
always @(notif_rme)  
begin : blk_notif_rmen_0
    flaga_viol = `True;
    flaga_read_ok = `False;
    -> ev_read_out_a_port;
    flaga_d_ok  = `False;
    checkSanityOnAport;
end // end of always block blk_notif_rmen_0
`endif // endif of VIRAGE_FAST_VERILOG



`ifdef VIRAGE_FAST_VERILOG
`else
// WA violation; CEM
always @(notif_wa)
begin : blk_notif_wa_0
  flaga_adr_ok = `False;
  checkSanityOnAport;
end // end of always block blk_notif_wa_0

// WPULSE violation; CEM
always @(notif_wpulse)
begin : blk_notif_wpulse_0
  flaga_adr_ok = `False;
  checkSanityOnAport;
end // end of always block blk_notif_wpulse_0

`endif // endif of VIRAGE_FAST_VERILOG

// reset for next cycle

always @(negedge CLK)
begin : blk_intnegclock_0
  if ( CLK !== 1'bx )
  begin
    #0.001;
    flaga_range_ok  = `True;
    flaga_read_ok = `True;
    flaga_rm_ok = `True;
    flaga_clk_valid = `True;
    flaga_adr_ok  = `True;
    flaga_we_ok   = `True;
    flaga_d_ok    = `True;
    flaga_viol    = `False;
  end // if of CLK != X
  else
  begin
    if (ME !== 1'b0)
    begin
    flaga_clk_valid = `False;
    Q_local_tmp = 8'bx;
    corrupt_all_loc(`True);
    report_unknown("CLK");
    end
  end // else of if CLK != X
end // end of always block blk_intnegclock_0

// PORT A FUNCTIONALITY 


always @(posedge CLK)
begin : blk_intposclock_0
  CLKA_T = $realtime;
  MElatched = ME_old;
  WElatched = WE_old;
  TEST1latched = TEST1_old;
  TEST_RNMlatched = TEST_RNM_old;
  ADRlatched = ADR_old;
  Dlatched = D_old;
  WAlatched = WA_old;
  WPULSElatched = WPULSE_old;
  if ((LS_old === 1'b1 && MElatched !== 1'bx) || TEST_RNMlatched === 1'b1)
  begin
    MElatched = 1'b0;
  end
  if (LS_old === 1'bX && MElatched !== 1'b0)
  begin
    report_unknown("LS");
    corrupt_all_loc(`True);
    Q_local_tmp = 8'bx;
  end
  else
  begin
    if (^(ADRlatched) === 1'bx && MElatched !== 1'b0)
    begin
      report_unknown("ADR");
      if ( WElatched === 1'b1 )
      begin
        flaga_viol = `True;
      end // if of WElatched = 1
      else
      begin
        flaga_read_ok = `False;
      end
      `ifdef virage_ignore_read_addx
      if ((WElatched === 1'b1))
      begin
        flaga_adr_ok = `False;
        corrupt_all_loc(flaga_range_ok);
      end // if of write
      `else
        flaga_adr_ok = `False;
        corrupt_all_loc(flaga_range_ok);
      `endif // endif of virage_ignore_read_addx is true
      -> ev_RST_out_a_port;
    end // if of (^ADRlatched) is 1'bx and MElatched != 0
    else if((ADRlatched > 14'b11111111111111) && (MElatched === 1'b1) && (WElatched === 1'b1) )
    begin
      if( (MES_CNTRL=="ON" || MES_CNTRL=="WARN")&& $realtime != 0 && mes_all_valid)
      begin
        $display("\n%m<<VIRL_MEM_WARNING:address is out of range>>(time %0t)\n RANGE: 0 to 16383\n", $time);
      end
      flaga_range_ok = `False;
    end // if of ADRlatched out of range with MElatched = 1
    if (!flaga_clk_valid) 
    begin
      Q_local_tmp = 8'bx;
    end // if of flaga_clk_valid is NOT true
    else if ( CLK === 1'bx )
    begin
    #0.001; 
      if (diff_me_tch === 1'b1 || ME !== 1'b0)
      begin
      Q_local_tmp = 8'bx;
      corrupt_all_loc(flaga_range_ok);
      report_unknown("CLK");
      end // end of if diff_me_tch
    end // if of CLK = X
    else if (BC0 === 1'bX && WElatched !== 1'b0)
    begin
      if( (MES_CNTRL =="ON" || MES_CNTRL =="WARN") && $realtime != 0 && mes_all_valid)
      begin
        //$display("\n%m <<VIRL_MEM_WARNING: BC0 is unknown>>(time %0t)\n\n", $time);
      end
    end
    else if ((BC1 === 1'bX || BC2 === 1'bX) && WElatched !== 1'b0)
    begin
      if( (MES_CNTRL =="ON" || MES_CNTRL =="WARN") && $realtime != 0 && mes_all_valid)
      begin
        //$display("\n%m <<VIRL_MEM_WARNING: BC1 or BC2 is unknown>>(time %0t)\n\n", $time);
      end
    end
    else
    begin
      -> ev_RST_out_a_port;
    end // else of if CLK = X
  end // else of if power pin unknown 
end // end of always block blk_intposclock_0
// PORT A READ-OUT

always @(ev_read_out_a_port)
begin : blk_readout_0
  #0;                // let CLOCK and NOTIFIER module execute first
  if (^RM === 1'bx)
  begin
    flaga_rm_ok = `False;
  end // if of RM is not valid
  if (flaga_adr_ok && flaga_read_ok && flaga_rm_ok)
  begin : OUTPUT_a
    if (WElatched === 1'b0)
    begin
      if (ADRlatched <= 14'b11111111111111)
      begin
          
          if (faultinj_en == 1)
          begin
            Q_local_tmp = mem_core_array[ADRlatched]^mem_fault_array_XOR[ADRlatched];
          end
          else
          begin
            Q_local_inj = mem_core_array[ADRlatched] & mem_fault_array_sa0[ADRlatched];
            Q_local_inj = Q_local_inj | mem_fault_array_sa1[ADRlatched];
            Q_local_tmp = Q_local_inj;
          end
      end // if of ADRlatched <= 14'b11111111111111
    end // if of WElatched = 0
  end //if of flaga_adr_ok is true and flaga_read_ok is true and flaga_rm_ok is true
  else
  begin
    if (flaga_viol)
    begin
      if ((WElatched === 1'b0))
      begin
        corrupt_q;
        flaga_read_ok = `True;
      end  // if of read
    end // if of flaga_viol is true
    else
    begin
      corrupt_q;
      flaga_read_ok = `True;
    end // else of if flaga_viol is true
  end // else of if flaga_adr_ok is true and flaga_read_ok is true and flaga_rm_ok is true
  flaga_read_ok = `True;
  flaga_rm_ok = `True;
end // end of always block blk_readout_0

// Handle Read/Write
always @(ev_RST_out_a_port)
begin : blk_readwrite_0
    if (MElatched !== 1'b0)
    begin
      if ((^WAlatched === 1'bX) && (WElatched !== 1'b0))
      begin
        corrupt_all_loc(`True);
        flaga_we_ok = `False;
        report_unknown("WA");
      end
      if ((^WPULSElatched === 1'bX) && (WElatched !== 1'b0))
      begin
        corrupt_all_loc(`True);
        flaga_we_ok = `False;
        report_unknown("WPULSE");
      end
    end
    if (MElatched !== 1'b0 && !flaga_viol)
    begin
      if (WElatched === 1'bx)
      begin
        flaga_we_ok = `False;
        flaga_read_ok = `False;
        report_unknown("WE");
      end // if of WElatched = X
      if ((^Dlatched === 1'bx))
      begin
        if (Dlatched === 8'bx)
        begin
          flaga_d_ok  = `False;
        end
        if (WElatched !== 1'b0)
        begin
          report_unknown("D");
        end
      end
          if (TEST1latched === 1'bx)
          begin
            report_unknown("TEST1");
            if ( WElatched == 1'b1 )
            begin
              corrupt_cur_loc(ADRlatched);                             
            end // if of WElatched = 1
            else
            begin
              corrupt_q;
            end // else of if WElatched = 1
          end // if TEST1latched = X
          else if (TEST_RNMlatched === 1'bx)
          begin
            report_unknown("TEST_RNM");
            if (WElatched !== 1'b1)
            begin
              corrupt_q;
            end // if of WElatched != 1
            corrupt_all_loc(`True);
          end // else if TEST_RNMlatched = X
          else
          begin
                if (^RM === 1'bx)
                begin
                  if ( RME !== 1'bx )
                    report_unknown("RM");
                  else
                    report_unknown("RME");
                  if ( WElatched == 1'b1 )
                  begin
                    corrupt_cur_loc(ADRlatched);
                  end // if of WElatched = 1
                  else
                  begin
                    corrupt_q;
                  end // else of if WElatched = 1
                end // if of RM = X 
                else
                begin
                  if (MElatched !== 1'b1)
                  begin
                    flaga_we_ok = `False;       // don't know if cycle is On or Off
                  end // if of MElatched != 1 

                  if(ADRlatched > 14'b11111111111111) 
                  begin
                    if( (MES_CNTRL=="ON" || MES_CNTRL=="WARN") && $realtime != 0 && mes_all_valid)
                    begin
                      $display("\n%m<<VIRL_MEM_WARNING:address is out of range>>(time %0t)\n RANGE:0 to 16383\n", $time);
                    end
                    flaga_range_ok = `False;
                    if (WElatched === 1'b0)
                    begin
                      flaga_read_ok = `False;
                    end // if of flaga_read_ok
                  end // if of ADRlatched out of range with MElatched = 1
                  if ( MElatched === 1'bx )
                  begin
                    report_unknown("ME");
                    `ifdef virage_ignore_read_addx
                    if (WElatched == 1'b1)
                    begin
                      corrupt_all_loc(flaga_range_ok);
                    end // if of WElatched = 1 
                    else
                    begin
                      corrupt_q;
                    end // else of if WElatched = 1
                    `else
                    if (WElatched == 1'b1)
                    begin
                      corrupt_all_loc(flaga_range_ok);
                    end // if of WElatched = 1
                    else
                    begin
                      corrupt_q;
                      corrupt_all_loc(flaga_range_ok);
                    end // else of if WElatched = 1
                    `endif
                  end // if of MElatched = X
                  else
                  begin
                      if (flaga_range_ok && flaga_we_ok && flaga_adr_ok && flaga_d_ok && (WElatched == 1'b1))
                      begin
                        if (disp_msg_wr) checkassist_write;
                        mem_core_array[ADRlatched] = Dlatched;
                          if (!mes_all_valid)
                          begin
                            mes_all_valid = 1'b1;
                          end // if of mes_all_valid = 0
                      end // if of write
                      else
                      begin
                        checkSanityOnAport;
                      end // else of if write
                  if (TEST1latched === 1'b1)
                  begin
                     if (WElatched === 1'b0)
                     begin
                       flaga_read_ok = `False;
                       -> ev_read_out_a_port;
                       @(negedge CLK);
                     end
                     if (TEST_RNM === 1'b0)
                     -> ev_read_out_a_port;
                  end // if of TEST1latched = 1
                  else 
                  begin
                    -> ev_read_out_a_port;
                  end // else of if TEST1latched = 1
                  end // else of if MElatched = X
                end // else of if RM = X
          end // else of if TEST1latched = X
    end // if of MElatched != 0 & flaga_viol = 0
end // end of always block blk_readwrite_0




assign Q_temp = Q_local_tmp;

// Final Output Update 

always @( Q_temp )
begin : blk_output_0
    `ifdef VIRAGE_FAST_VERILOG
    #(O_delay) Q <= Q_temp;
    `else
    Q <= 8'bx;
    #0.001;
    Q <= Q_temp;
    `endif // endif of VIRAGE_FAST_VERILOG
end // end of always block blk_output_0



// Display the warning when TEST1 is 1.
always @ (TEST1)
begin : blk_test1_0
  if (CLK === 1'b1 && MElatched === 1'b1)
  begin
    corrupt_q;
    flaga_read_ok = `False;
  end
  if ( TEST1 == 1'b1 && (LS === 1'b0))
  begin
    if( (MES_CNTRL =="ON" || MES_CNTRL =="WARN") && $realtime != 0 && mes_all_valid)
    begin
      $display("\n%m <<VIRL_MEM_WARNING: Tcc value in the RAM model is for TEST1=1'b0,but input value is TEST1=1'b1>>(time %0t)\n\n", $time);
    end
  end // if TEST1 = 1 
end // end of always block blk_test1_0
always @ (TEST_RNM)
begin : blk_test_rnm_0
  if (CLK === 1'b1 && ME_old === 1'b1 && TEST1latched === 1'b1)
  begin
    if (WElatched === 1'b0)
    begin
      flaga_read_ok = `False;
      corrupt_q;
    end
    if (WElatched === 1'b1)
    begin
      flaga_d_ok = `False;
      checkSanityOnAport;
    end
  end
end // end of always block blk_test_rnm_0


endmodule
